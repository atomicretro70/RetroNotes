#############################################################################
##############################################################################
##############################################################################
##############################################################################
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######          ##############################################          ######
######          ##############################################          ######
######          ###                                        ###          ######
######          ###              Retro Notes               ###          ######
######          ###                                        ###          ######
######          ###            Classical Logics            ###          ######
######          ###                                        ###          ######
######          ##############################################          ######
######          ##############################################          ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                     AtomicRetro@outlook.com                      ######
######                                                                  ######
######                     Revision:                                    ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
##############################################################################
##############################################################################
##############################################################################
##############################################################################

....|....1....|....2....|....3....|....4....|....5....|....6....|....7....|...


==============================
To View This Document Properly
==============================
* Best if viewed in VIM using with settings
     :set columns=80
     :set encoding=utf-8

* This document must be viewed with a mono-spaced font to enjoy the layout,
  tables and diagrams.

* This document must be viewed in an editor that can display unicode utf-8.


======================================
CONTENTS
======================================
Contents
Preface
Introduction
   History
   Preliminary Definitions
   Formal Definitions
   The Laws of Logic
   Set Theory
Truth-Functional Logic (TFL)
   Language
   Semantics
   Calculus (TFC)
Predicate Logic
   Language
   Semantics
   Calculus (PC)
First-Order Quantified Logic (FOL)
   Language
   Semantics
   Calculus (FOC)
Identity Logic (IL)
   Language
   Semantics
   Calculus
Function Logic (FL)
   Language
   Semantics
   Calculus
Definite Descriptors
   Language
   Semantics
   Calculus
Second-Order Quantified Logic (SOL=)
   Language
   Calculus
Mathematical Induction
Axiomatic and Natural Deduction
Formal Theories & Axioms

=======
Preface
=======

   This book is intended for anyone seeking a reference book in classical
   logic.  However, it's not an instruction manual.  The pace is quicker
   with fewer examples and no exercises.  This should not discourage
   the student in need of a reference; the present book is detailed and
   makes a great study companion.

   The introduction begins with a brief history of logic followed by some
   preliminary information about logic: Namely a review of some important
   definitions a discussion on formal definitions, a short section on the
   laws of logic rounded out by a quick review of set theory.

   The first chapter covers propositional logic; the logic of 'not', 'and',
   'or', and similar notions.  It begins by describing the formal language:
   the lexemes and the grammar.  This is followed by a study of the
   semantics, formal descriptions of meanings of sentences in the language. 
   Then comes a modern Fitch-Style calculus for the language.

   Most of the remaining chapters follow the same pattern of language,
   semantics, calculus, with some supplementary sections here and there.
   Each chapter describes a different system of logic within the discipline
   of classical logic covering:  Predicate Logic , First-Order Quantified
   Logic (FOL), Identity Logic and FOL=, Function Logic (FL), Russell's
   Theory of Definite Descriptors, Second-Order Quantification Logic,
   and lastly Mathematical Induction.  The book closes with mentions
   of Axiomatic Deductive Systems, then Formal Theories and their Axioms.

   The notation selected for this book may vary slightly from that of whatever
   books you may have studied.  The symbols were chosen to reflect certain
   aesthetic principles.  All of the logical operators consist of straight
   lines, and all but one, negation, are symmetrical.  They are well defined
   straight lined geometric shapes to denote the well-defined rigid logical
   operations.  Parentheses, used for grouping just as in math, can be thought
   of as representing nested bubbles.  Both of these are in stark contrast
   to the large round or curvy letters used to denote more complex less well
   defined English sentences.

   This book will be updated periodically and some sections may be dropped or
   developed further based upon your feedback.  If you wish to contribute by
   reporting an error or omission, or have other comments please contact
   the author here: AtomicRetro@outlook.com.

============
Introduction
============

-------
History
-------

   Logic has a very long history.  An ancient Greek philosopher named
   Aristotle (384 - 322 BCE) who lived in Athens, perhaps the best known
   of Plato's students from the Academy, gave us the first formal logical
   system today called Categorical Logic.  His logic is complete, it proves
   everything that it can within the bounds of the logic; and it's sound,
   if used properly it can't be coerced to prove something that doesn't
   logically follow from the evidence provided.  The down side is that
   Aristotle's logic is very limited in what it can say or prove.

   Around the same time as Aristotle another philosopher named Chrysippus
   is known to have written a book about a different kind of logical system
   based upon 'not', 'if...then...', etc.  But his works are lost and only
   known of through mention by other ancient authors.  Though an important
   development, Chrysippus' logic was mostly ignored through history
   overshadowed by categorical logic.

   Aristotelian logic reigned supreme for over two thousand years.  Over the
   centuries there were many commentaries, organizational and pedagogical
   modifications, even advances in study of the logic's semantics but it
   remained the same limited logic.  There were other advances in logic
   outside of Aristotelian logic but they were limited; never producing fully
   developed logical systems.

   This changed in 1847 and 1854 when George Boole published his works
   *The Mathematical Analysis of Logic* and *An Investigation of the Laws
   of Thought* respectively.  In these books Boole outlined a new logic
   with notions similar to those of Chrysippus, however Boole's logic
   is mathematically precise.  Known today as BOOLEAN ALGEBRA, his system
   is what would eventually come to power digital logic and computers.

   Next came Friedrich Ludwig Gottlob Frege (1848 - 1925).  In 1879
   Frege published his *Begriffsschrift* in which he made the important
   advancement of a unified theory of logic joining Aristotle's and
   Boole's systems.

   Frege's logic was a revolutionary advancement in logic, but it has
   major issues.  The problem stems from the fact that Frege allowed
   self-reference.  While this gives the logic considerable expressive
   power, it also makes the logic is unsound.  Bertrand Russell (1872
   - 1970) exposed the problem within Frege's logic, by expressing
   the problem as a paradox: the set of all sets that do not contain
   themselves.  So, does the set contain itself or not?  The answer
   is both or neither, which is nonsensical from the perspective of
   Aristotle's and Boole's definition of a proposition.

   In 1903 Russell, along with Alfred North Whitehead published the first
   book of his *The Principles of Mathematics*, in which he outlined a
   repaired but more limited variation of Frege's logic.  The primary change
   Russell made was to disallow self-reference.  Russell also replaced
   Frege's notation with something less cumbersome.  Importantly it's
   more expressive than either Aristotle's or Boole's logics but also both
   sound and complete, meaning for any set of data put into the logic one
   can derive all and only valid conclusions.  Today Russell's is the
   logic most commonly studied in introductory logic courses (with a slightly
   simplified notation), it's often called Classical Logic, and it's the
   subject of this book.

Preliminary Definitions
-----------------------

   A PROPOSITION is the concept that a true or false statement denotes;
   many different statements can denote the same propositions. 

   A TRUTH-VALUE is any member of the set { true, false }.

   An ARGUMENT is a set of propositions; where one is intended as a
   CONCLUSION, a sort of finding; the rest, the PREMISES, are claimed to
   prove or provide some evidence for the conclusion.

   INFERENCE is the reasoning process expressed by an argument.

   FORMAL LOGIC is the study of arguments by means of symbolic languages
   and systems of inference that capture structures, patterns or forms of
   inference without regard to meaning.

   A DEDUCTIVE ARGUMENT is an argument who's conclusion cannot be false when
   all the premises are true.

   A VALID ARGUMENT is a deductive argument which is genuinely deductive in
   the sense defined above.

   An INVALID ARGUMENT is an argument claimed to be deductive but contains
   reasoning errors, or missing premises, or incorrect applications of
   inference rules, etc.; any argument that isn't in actually deductive.

   A COUNTEREXAMPLE is an clearly invalid argument with the same structure
   as an argument claimed to be valid.

   A DEFINITION is a declaration that two strings are identical
   in meaning and thus interchangeable.

   The DEFINIENDUM is the string in a definition being defined; often
   the string naming a new word, abbreviation or phrase.

   The DEFINIENS is the string in a definition doing the defining.

------------------
Formal Definitions
------------------

   A FORMAL DEFINITION is a declaration that two strings or groups of
   strings mean the same thing; that they're interchangeable.  Definitions
   are expressed as follows:

         *definiendum*  =df  *definiens*

   In formal definitions the  *definiendum* is usually an abbreviation
   for a *definiens*.

         *abbreviation*  =df  *definiens*

                      ⊥  =df  (P ∧ ￢P)

Definition Schemata & Variables
===============================
   
   We can introduce a DEFINITION SCHEMA (a "family" of definitions all having
   the same structure) with the help of place-holders (which we denote using
   letters towards the end of the alphabet: u,v,w,x,y,z), across which values
   are substituted uniformly to obtain a definition.

   Example: formal definition of the conditional probability operation.

                      P(X ∧ Y)
         P(X|Y)  =df  --------
                        P(Y)

   Whenever we see an instance of P(X|Y) it's interchangeable, and so can
   be replaced by, its corresponding right-hand side replacing values for
   X and Y uniformly.  The reverse operation is also possible.

   So the question, What's the probability that we Slip given that it's Dicey,
   yields the following definition.

                      P(S ∧ I)
         P(S|I)  =df  --------
                        P(I)

Packing & Unpacking
===================

   PACKING A DEFINITION is when we rewrite a string such that we replace one
   or more occurrences of a *definiens* with its *abbreviation*.

   UNPACKING A DEFINITION is when we rewrite a string expanding one or more
   occurrences of an *abbreviation* with its *definiens*.

-----------------
The Laws of Logic
-----------------

   The simplest logic has just two discrete truth-values: True and False.
   From this binary relation it's possible to construct the following logical
   principles.

   LAW OF NONCONTRADICTION (LNC)

         A proposition P is not both True and False.

   LAW OF EXCLUDED MIDDLE (LEM)

         A proposition P is either True or False.

   IDENTITY OF INDISCERNIBILITY

         If two things have all of the same properties then they're
         the same object.
      
   LAW OF INDISCERNIBILITY OF IDENTICALS (LEIBNIZ'S LAW)

         If two things are the same object then they have
         all of the same properties.


----------
Set Theory
----------

A SET is a collection of objects which has no special order but in which
each member object occurs just once.

Set Definition
==============

   Sets are defined formally within a pair of braces { and }.
   The simplest definition of a set is by exhaustive enumeration,
   listing out all the members.

         A = { my phone, empire state building, the number 6,
               the neighborhood dog that's always barking }

   The null set is a special case.

         ∅ = { } = null/empty set

   Many sets are too large to enumerate so may be described by properties
   of their members.  This is usually done using a comprehension.
   A COMPREHENSION is a set defined by properties and includes the use of
   '|', which is read as, 'such that' (sometimes ':' is used instead of '|').

         M = the set of all mammals
           = { x | x is a mammal }
           = read, "the set of all x such that x is a mammal."

         E = { x | x/2 = int(x/2) }
           = "The set of all x such that x divided by 2 equals the integer
             of x divided by 2."
           = "The set of all numbers evenly divisible by two."

         P = { x | (x is an integer) or (x is red) }
           = "The set of all integer or red things."

         Z = { x | x is an integer }
             It's customary to denote this set with a bold capital 'Z'.

   <x,y> is an ORDERED PAIR, a value which requires two numbers to be
   fully expressed, where x,y can be any two real numbers

         F = { <x,y> | (x in Z) and (y=10x) }
             The set of all ordered pairs <x,y> such that x is an integer
             and y is ten times x.

Set-Member Relations
====================

   The things that sets are composed of are called OBJECTS, ELEMENTS
   or MEMBERS.

   MEMBERSHIP ( ∊ )

         a ∊ P is read, "a is a member/element of P", or, "a is in P".
         Fido ∊ Dog, Fido is a dog.
         2 ∊ Even, 2 is even.

   Identity ( = )

         A = B, Sets A and B have exactly the same members.

   PROPER SUBSET ( ⊂ )

         A ⊂ B,  A is composed of some but not all of the objects in set B.
         E ⊂ Z,  even numbered integers are a subset of integers.

   SUBSET ( ⊆ )

         A ⊆ B, A is composed of some or all of the members in set B,
                but no others.

   PROPER SUPERSET & SUPERSET ( ⊃, ⊇ )

         ⊃ and ⊇ work similarly to the subset operators.

Set Operations
==============

   Consider,

          R = { x | x is red }
          C = { x | x is a car }

   UNION ( ∪ ) 

         The set of all things contained in two sets.

         R ∪ C
         = { x | x is red } ∪ { x | x is a car }
         = { x | (x is red) or (x is a car) }

   INTERSECTION ( ∩ )

         The set of all things common to two sets.

         R ∩ C
         = { x | x is red } ∩ { x | x is a car }
         = { x | (x is red) and (x is a car) }

   DIFFERENCE ( - )

         R - C = { x | (x is red) and (x is not a car) }

   COMPLEMENT ( ' )

         The set of all things outside of the set.

         C' = { x | x is not a car }
         C'' = C

   CARDINALITY ( || )

         The CARDINALITY of a set is how many members it contains.

         A = { a, b, c }
         |A| = 3
         |Z| = infinity

Set Properties
==============

   UNIVERSE

         U, UNIVERSE OF DISCOURSE (also DOMAIN OF DISCOURSE)
            The set of all objects in our discussion.

      The universe and the empty set are complements of each other.

         U' = { }

   DECIDABLE SET

         A set is DECIDABLE iff there's an effective method for determining
         whether an object is in the set.

   1:1 CORRESPONDENCE

         For any two sets there is a 1:1 CORRESPONDENCE iff there is a way
         to pair off each member of set A with a member of set B.  Every
         member of both must be paired uniquely, so both sets have the same
         cardinality |A| = |B|.  Every member of A is paired to exactly one
         member of B, and vice versa.

   DENUMERABLE

         A set is DENUMERABLE iff there is a 1:1 correspondence between
         it and the set of natural numbers.  Hence, the cardinality of the
         set is infinite.


===================
Propositional Logic
===================

   Propositional logic is about the truth-functions, 'and', 'not' and
   similar concepts.


--------
Language
--------

   A LANGUAGE is defined by the set of all sensical sentences in the language.

   A FORMAL LANGUAGE is the set of all grammatically correct sentences
   in a language.  Formal languages don't take semantics into
   consideration, so many such sentences may be nonsensical.

   A METALANGUAGE is the language used to talk *about* a logic.  So sentences
   in the metalanguage mention properties of the logic, arguments and all
   things that they entail.  Most of this book is written in the metalanguage.

   A LEXEME is the smallest semantic unit of a language, often called words.

Lexemes
=======

   Non-Logical Symbols
      Proposition Symbols:      A...Z
      Association Symbols:      (, )

   Logical Symbols
      Truth-Function Symbols:   ￢, ∧, ∨, ->, <->

Grammar
=======

   A FORMAL GRAMMAR is the set of rules that selects all and only the
   grammatically correct strings in a given language without regard
   to meaning.

   A grammatically correct sentence in logic is called a WELL-FORMED FORMULA
   (WFF, or FORMULA).  It's conventional to use capital Greek letters
   to represent arbitrary formulas.  A wff in propositional logic is any
   string constructed in accordance with the following clauses (called
   FORMATION RULES):

   An ATOMIC FORMULA is any single proposition symbol.

   1.  every atomic formula is a wff;
   2.  if Φ is a wff, then ￢Φ is a wff;
   3.  if Φ,Ψ are wffs, then (Φ ∧ Ψ),(Φ ∨ Ψ),(Φ -> Ψ),(Φ <-> Ψ) are wffs;
   4.  nothing else is a wff.

   Notes
   - Notices that the formation rules for wffs are recursive,
     this means that wffs can nest within other wffs to any depth.
     So, while P ∧ Q is a wff, so is (￢(P ∨ Q) -> R).

   - To aid readability we adopt the convention that if a wff
     begins with '(', we will drop the outermost pair of parentheses,
     doing so never introduces ambiguity to the formula.

   - In practice it's common to use PRIME marks ('), or numerical
     subscripts (we use postscripts) after a proposition symbol
     to increase the number of available symbols.

Substitution Instance (or Instance)
===================================

   A SUBSTITUTION INSTANCE of a wff is another wff that has the
   same structure as the first such that proposition symbols in
   the original are uniformly replaced by other subordinate wffs.
   'Instance of' relationships don't have to be symmetrical, and
   usually aren't.  P being an instance of Q, does not imply that
   Q is an instance of P.

   =============  =====   =======   ===========   ========================
   Original Form  P ∧ Q | P   ∧ Q | P       ∧ Q | P   -> (P    ∧ Q       )
   =============  =====   =======   ===========   ========================
   Substitutions  P=R   | P=￢S   | P=(C ∧ D)   | P=￢H
                  Q=S   | Q=Z     | Q=D         | Q=(￢S ∨ M)
   -------------  ----- | ------- | ----------- | ------------------------
   Instance       R ∧ S | ￢S ∧ Z | (C ∧ D) ∧ D | ￢H -> (￢H ∧ (￢S ∨ M))
   =============  =====   =======   ===========   ========================


---------
Semantics
---------

The semantics of a language are the concepts denoted by the lexemes and
sentences (our wffs) of the language.

Translation Hints
=================

   +-----------------------------------------------------------------------+
   | =================================   ================================= |
   | P                                 | ￢P                               |
   | ================================= | ================================= |
   | P                                 | it's false that P                 |
   | it's true that P                  | it's not true that P              |
   | it's the case that P              | it's not the case that P          |
   | P whether or not Q                | non-P                             |
   |   literally:  (Q ∨ ￢Q) -> P      |                                   |
   |                                   |                                   |
   | ================================= | ================================= |
   | P ∧ Q                             | ￢(P ∧ Q)                         |
   | ================================= | ================================= |
   | P and Q                           | P nand Q (in computing)           |
   | P but Q                           |                                   |
   | P yet Q                           |                                   |
   | P still Q                         |                                   |
   | P also Q                          |                                   |
   | both P and Q                      |                                   |
   | P additionally Q                  |                                   |
   | P furthermore Q                   |                                   |
   | P however Q                       |                                   |
   | P although Q                      |                                   |
   | P nevertheless Q                  |                                   |
   | P moreover Q                      |                                   |
   | P even though Q                   |                                   |
   | P even if Q                       |                                   |
   | P whereas Q                       |                                   |
   | not only P but also Q             |                                   |
   |  literally: ￢(P ∧ ￢Q) ∧ (P ∧ Q) |                                   |
   |                                   |                                   |
   | ================================= | ================================= |
   | P ∨ Q                             | ￢(P ∨ Q)                         |
   | ================================= | ================================= |
   | P or Q                            | neither P nor Q                   |
   | P except if Q                     | P nor Q (in computing)            |
   | P except when Q                   |                                   |
   | P except on condition that Q      |                                   |
   | P unless Q (weak/inclusive-or)    |                                   |
   | either P or Q (inclusive)         |                                   |
   |                                   |                                   |
   | ================================= | ================================= |
   | P -> Q                            | ￢P -> ￢Q                        |
   | ================================= | ================================= |
   | if P then Q                       | P is a necessary condition for Q  |
   | P implies Q                       | P is necessary for Q              |
   | P only if Q                       |                                   |
   | only if Q, P                      |                                   |
   | P results in Q                    |                                   |
   | P brings about Q                  |                                   |
   | P leads to Q                      |                                   |
   | not P unless also Q               |                                   |
   |  literally:  ￢P ∨ (P ∧ Q)        |                                   |
   | P is a sufficient condition for Q |                                   |
   | P is sufficient for Q             |                                   |
   | Q assuming that P                 |                                   |
   | assuming that P, Q                |                                   |
   | Q on the condition that P         |                                   |
   | on the condition that P, Q        |                                   |
   | Q given that P                    |                                   |
   | given that P, Q                   |                                   |
   | Q provided that P                 |                                   |
   | provided that P, Q                |                                   |
   | Q in case P                       |                                   |
   | in case P, Q                      |                                   |
   |                                   |                                   |
   | ================================= | ================================= |
   | P <-> Q                           | P <-> ￢Q                         |
   | ================================= | ================================= |
   | P if and only if Q                | P xor Q (computing)               |
   | P iff Q                           | P (exclusive) or Q                |
   | P just if Q                       | P unless also Q                   |
   | P just in case Q                  | P unless Q                        |
   | P exactly when Q                  | either P of Q                     |
   | P exactly if Q                    |                                   |
   | P but only if B                   |                                   |
   | P is a necessary and sufficient   |                                   |
   |    condition for Q                |                                   |
   | P is necessary and sufficient     |                                   |
   |    for Q                          |                                   |
   +-----------------------------------------------------------------------+

Conversational Implicature
==========================

   CONVERSATIONAL IMPLICATURE is what's meant by a speaker's utterance that
   are not part of the literal meaning of what's explicitly said.

   'and then'

   When 'and' is a shortened form of 'and then', it can't be translated
   into a conjunction since the word 'then' here denotes a temporal
   relationship between the clauses it joins and the operators in
   propositional logic have no notion of time.

         Keep up the good work and you'll go far.

         Alice drove home and went to bed.

   'if...then'

   It can be tempting two rewrite 'and then' as 'if...then', but it doesn't
   always result in a sentence with the same meaning.

         Keep up the good work and you'll go far.
         If you keep up the good work then you'll go far.

         Alice drove home and went to bed.
         If Alice drove home then she went to bed.

   Again this 'then' in 'if/then' denotes a temporal relationship, it can't
   be translated into a propositional logic conditional.  Consider what
   happens by negating the first rewritten example and seeing what we derive
   after applying a few boolean algebra logical equivalences.

         K -> F        if you keep up the good work then you'll go far.

         ￢(K -> F)    it's false that if you keep up the work you'll go far
         ￢(￢K ∨ F)
         K ∧ ￢F       You keep up the good work and you don't go far.


Truth-Function Anatomy
======================

   The truth-functions have "official" names, and less formal English
   conversational names; the OPERANDS, the things the truth-functions apply
   to, also have names.

         ======  =======  =============  =======  ===================
         Symbol  Example  Name           English  Operand Names
         ======  =======  =============  =======  ===================
          ￢     ￢P      NEGATION       not      P is a NEGATAND
          ∧      P ∧ Q    CONJUNCTION    and      P,Q are CONJUNCTS
          ∨      P ∨ Q    DISJUNCTION    or       P,Q are DISJUNCTS
          ->     P -> Q   CONDITIONAL    if/then  P is the ANTECEDENT
                                                  Q is the CONSEQUENT
          <->    P <-> Q  BICONDITIONAL  just if  Operands
         ======  =======  =============  =======  ===================

   ARITY is the number of subordinates an operation requires.  Example,
   negation has an arity of one because it has one subordinate; while
   conjunction has an arity of two.  The table below lists some common 
   arities and some different names they go by.

         =====  ====================  =========  ==========  ==========
         Arity  Examples              -ary name  -adic name  place name
         =====  ====================  =========  ==========  ==========
          0     P                                            0-place
          1     ￢P                   UNARY      MONADIC     1-place
          2     P ∧ Q, P ∨ Q          BINARY     DIADIC      2-place
          3     x is between y and z  TRINARY    TRIADIC     3-place
         =====  ====================  =========  ==========  ==========

Valuation Function
==================

   A TRUTH-FUNCTION operates upon true/false values.  The semantics
   of the truth-functions are formally described by a function v called
   a VALUATION FUNCTION, which encapsulates all there is to say about
   the meanings of propositional logic's truth-functional operators.

   Here's the valuation function for TFL:

         v(￢Φ)      = true if Φ is false;
                       false if Φ is true
         v(Φ ∧ Ψ)    = true if both Φ and Ψ are true;
                       false if either Φ or Ψ or both are false
         v(Φ ∨ Ψ)    = true if either Φ or Ψ or both are true;
                       false if both Φ and Ψ are false
         v(Φ -> Ψ)   = true if Φ is false or Ψ is true;
                       false if Φ is true and Ψ is false
         v(Φ <-> Ψ)  = true if both Φ and Ψ are true, or
                               both Φ and Ψ are false;
                       false if either Φ is true and Ψ is false or
                                       Φ is false and Ψ is true.

Sequents
========

   A SEQUENT is a metalogical notation expressing that a conclusion C
   follows from a set of premises, P1,...,Pn.

         P1,...,Pn  ⊢  C

         '⊢' is a TURNSTILE. It's part of the metalanguage,
         not a part of propositional logic.

TRUTH-TABLES
============

   Truth-tables allow us to visually study the semantic characteristics of
   wffs as defined by the valuation function.  Each row of the table is
   equivalent to one VALUATION of the function v upon a formula.

   Basic Truth-Tables

   Procedure
   1. Construct The table heading starting on the top left with a horizontal
      alphabetical list of all proposition symbols occurring in the formulas
      under study; followed to the right by a second horizontal list of the
      formulas themselves.

   2. Under the list of proposition symbols list all possible combinations
      of T and F for those symbols.  Usually we start with a row of all
      F and end with all T, or vice versa, according to preference.
      The values for the intermediate rows are attained as if counting
      in binary.

   3. The remainder of the table is populated row-by-row carrying the
      T or F values under each proposition symbol to the right and placing
      them under the corresponding symbol occurring in each wff.

   4. In a given row under the first formula, starting from the innermost
      parentheses and working outwards, evaluate each of the expressions
      according to the valuation function v.  Continue until a T or F can
      be placed under the top level (outermost) operator on every row.
      Repeat this valuation procedure below each wff and each row
      in the table.

   The study will only need to consider the columns under the wffs' main
   operators so it's convenient to highlight the completed column in some
   way.  Here we place an '*' at the bottom of those columns.

   Truth-Table Study of The Truth-Functions

   The valuations for our primitive truth-functions are illustrated in the
   following truth-tables.

          P   | ￢P
         ===========
          F   | T F
          T   | F T
                *

          P Q | (P ∧ Q) | (P ∨ Q) | (P -> Q) | (P <-> Q)
         ===============================================
          F F |  F F F  |  F F F  |  F T  F  |  F  T  F
          F T |  F F T  |  F T T  |  F T  T  |  F  F  T
          T F |  T F F  |  T T F  |  T F  F  |  T  F  F
          T T |  T T T  |  T T T  |  T T  T  |  T  T  T
                   *         *         *           *

   Here's the truth-table for a more complex formula

          P Q | ￢(P <-> Q) V P
         ======================
          F F | F  F  T  F  F F
          F T | T  F  F  T  T F
          T F | T  T  F  F  T T
          T T | F  T  T  T  T T
                            *

   Truth-Functional Completeness

   TRUTH-FUNCTIONAL COMPLETENESS describes any set of truth-functional
   operators from which all other truth-functions can be defined.
   Propositional logic's set of primitive operators ￢, ∧, ∨, -> and <->
   is truth-functionally complete.  But so too is our negation with any one
   of our other operators.  Some authors have defined new operators
   which are truth-functionally complete by themselves.  An example is the
   SHEFFER STROKE symbol '(P|Q)', whose valuation function is equivalent
   to our how our valuation function would apply to the form ￢(P ∧ Q).
   But any logic constructed upon just one operator is cumbersome to use.

   Example, observe that the main columns (highlighted with '*') under each
   wff the same valuation.

          P Q | (P | Q) | ￢(P ∧ Q)
         ==========================
          F F |  F T F  | T  F F F
          F T |  F T T  | T  F F T
          T F |  T T F  | T  T F F
          T T |  T F T  | F  T T T
                   *      *

   Truth-Table Study of Single WFFs

   Once the truth-table is completed examining the main column below
   the wff can reveal important properties of the formula.

   INCONSISTENT WFF
      A formula that has no true valuations; i.e. the column under the main
      operator has all F's.

      CONTRADICTION
         A kind of inconsistent formula that's structured as the conjunction
         of a wff and it's negation; i.e. any instance of 'Φ ∧ ￢Φ'.

   CONSISTENT WFF
      A wff that is true on at least one valuation (row); i.e. the column
      under the formula's main operator contains at least one T.

      CONTINGENT WFF
         A consistent formula that's true on some valuations and false on
         others; i.e. the column under the main operator contains at least
         one T and at least one F.

      TAUTOLOGY or VALIDITY
         A consistent formula that's true on all valuations; i.e. the column
         under the main operator contains all T's.

   Summary

         =======  =======  ==========================
         Num T's  Num F's  Assessment
         =======  =======  ==========================
         0        2+       inconsistent/contradiction
         1+       0+       consistent
         1+       1+       contingent
         2+       0        tautology or validity
         =======  =======  ==========================

   Truth-Table Study of Sets of WFFs

   A truth-table study of a set of wffs can give us valuable insight into
   the relationships between those formulas.

   CONSISTENT SET OF FORMULAS
      A set of wffs is CONSISTENT if there is at least one valuation (row)
      of the table on which all formulas have T under their main operators.

      LOGICALLY EQUIVALENT PAIR OF FORMULAS
         A pair of wffs is LOGICALLY EQUIVALENT if for every row of the
         table both wffs have the same value under their main operators.
         Notice that for the truth table above for the Sheffer stroke
         we've shown that it's logically equivalent to ￢(P ∧ Q).

   INCONSISTENT SET OF FORMULAS
      A set of wffs is INCONSISTENT if there is no valuation (row)
      on which all formulas have T under their main operators.

   Truth-Table Study of Sequents

   A truth-table for an argument is constructed simply by treating the set
   of premises and the conclusion as a set of wffs being studied.

   Evaluation is just a matter of reading the definition of a valid
   deductive argument directly off the table.  A deductive argument
   is an argument whose conclusion cannot be F if the premises are all T.
   Notice from the definition that the conclusion is free to hold
   any value on a valuation (row) where the premises aren't all true.

   Example

          P Q | P -> Q , ￢ Q  ⊢  ￢ P
         =============================
          F F | F T  F | T  F  |  T  F  <==
          F T | F T  T | F  T  |  T  F
          T F | T F  F | T  F  |  F  T
          T T | T T  T | F  T  |  F  T
                  *      *        *

   The row indicated with an arrow verifies that this argument is valid.

   An invalid argument is an argument that contains at least one valuation
   on which all the premises are T but the conclusion is F.

   Example

          P Q | P -> Q ,  ￢ P  ⊢  ￢ Q
         ==============================
          F F |   T    |  T    |   T  
          F T |   T    |  T    |   F  <==
          T F |   F    |  F    |   T  
          T T |   T    |  F    |   F  
                  *       *        *

   We've discovered a row on which the premises are all T, but the conclusion
   is F.  So the argument form is invalid.

   The results for an inconsistent set of premises may seem counter-intuitive.

          P Q | P , ￢ P ⊢ Q
         ====================
          F F | F | T F |  F
          F T | F | T F |  T  <==
          T F | T | F T |  F
          T T | T | F T |  T  <==
                *   *      *

   This argument is actually valid.  Since there are no rows where the
   premises are all true any conclusion whatever follows.

   A disadvantage of truth-tables is that they grow exponentially.  A set
   of wffs with n proposition symbols will have 2^n rows.

Truth-Tables ("Fast Method")
============================

   There's a faster way to construct a truth-table, though it's not as
   visually satisfying.  Rather it's an implementation of a search algorithm
   to find only those valuations on which a formula is T (or F).  It has the
   advantage over a full truth-table in that we don't have the problem of
   potentially huge tables due to a large number of proposition symbols.

   Procedure
   1. Write down in a horizontal list the wff, set of wffs or sequent.  Set
      the main operators of each formula to either T or F (depending on what
      you're trying to find - see Truth-Table Study of Single WFFs above).

   2. Now work backwards from the outermost operator down to the innermost
      parentheses.  Evaluate as many sub-expressions as possible, continuing
      until you can't do anything else (some subwffs may go undetermined).

   3. While performing step 2 if you can find the truth value of a proposition
      symbol, place that value under all other occurrences of that symbol.

   4. The search is successful you encounter a contradiction or if the
      valuation we sought is now readable off the table.  This is the set
      of values found for the proposition symbols that makes the main
      operator T (or F).

   The study is to find valuations for the proposition symbols on which the
   whole wff is T (or F).  So, it's convenient to highlight somehow the values
   of the symbols at the end of this process.  I'll place a * under them.
   
   Fast truth-table Study of Single WFFs

   To check if a wff has any valuation on which it's T, set its main
   operator to T; and to check if it has a valuation on which it's F,
   set its main operator to F.

   Examples

         1.  P ∧ Q     ￢￢P ∧ (Q ∨ P)     P ∨ ￢Q     P -> (￢Q ∨ R)
               T             T               F           F

         2.  P ∧ Q     ￢￢P ∧ (Q ∨ P)     P ∨ ￢Q     P -> (￢Q ∨ R)
             T T T     T     T    T        F F F       T F       F
             *   *

         3.            ￢￢P ∧ (Q ∨ P)     P ∨ ￢Q     P -> (￢Q ∨ R)
                       T F T T    T        F F F T     T F   F   F F
                                           *     *

         4.            ￢￢P ∧ (Q ∨ P)                 P -> (￢Q ∨ R)
                       T F T T  ? T T                  T F   F T F F
                           *    *   *                  *       *   *

   Valuations Discovered

             P=T       P=T                 P=F         P=T
             Q=F       Q=T or F            Q=T         Q=T
                                                       R=F

   Notice in the second example we couldn't find a value for Q.  However,
   upon closer examination we see that's because Q's value doesn't matter;
   both T and F for Q make the formula T.  So there are two valuations
   on which the formula is T.  In both P is T, but Q is T in one and
   F in the other.

   To test if a wff is contingent the process must be performed once with
   T under the main operator, and once with F.  The wff is contingent
   if and only if we find at least one valuation of the proposition symbols
   that makes the main operator T, and at least one valuation of the
   proposition symbols that make the main operator F.

   Fast Truth-Tables Study of Sets of WFFs

   We can use the same method to test a set of wffs for consistency or
   inconsistency by setting the main operators all to T (or all to F).
   The only extra note here is that step 3 now works *across* WFFs.
   That is, if you find the value of a proposition symbol in one wff you
   may write that value under all instances of the proposition symbol
   across all of the wffs in the set.

   Example  Test each pair of wffs for consistency

         1.  P ∧ Q    ￢(￢P ∨ ￢Q)             P ∧ Q    ￢P ∨ ￢Q
               T      T                           T          T
   
         2.  P ∧ Q    ￢(￢P ∨ ￢Q)             P ∧ Q    ￢P ∨ ￢Q
             T T T    T      F                  T T T        T  
   
         3.  P ∧ Q    ￢(￢P ∨ ￢Q)             P ∧ Q    ￢P ∨ ￢Q
             T T T    T  F   F F                T T T    F T T F T
                                                *        *     *
         4.  P ∧ Q    ￢(￢P ∨ ￢Q)             inconsistent
             T T T    T  F T F F T
               *      *
             consistent
   
   Fast Truth-Table Study of Sequents

   To test a sequent we test if it's invalid by setting the main operator of
   each premise to T and the conclusion's to F.  Then work backwards exactly
   as for a set of wffs.  If no contradiction is obtained it's indeed possible
   for the premises to be T and the conclusion F, as originally assumed, the
   argument is therefore invalid.  On the other hand if a contradiction is
   obtained then the argument is valid.
      
   Example  Test the sequent for validity

         1.  ￢P -> (Q ∨ R), ￢Q  ⊢   R -> P
                 T           T          F

         2.  ￢P -> (Q ∨ R), ￢Q  ⊢   R -> P
                 T           T F      T F  F

         3.  ￢P -> (Q ∨ R), ￢Q  ⊢   R -> P
               F T   F   T   T F      T F  F

         4.  ￢P -> (Q ∨ R), ￢Q  ⊢   R -> P
             T F T   F T T   T F      T F  F
                 *           *          *

   The search succeeded in finding a set of values that makes all the
   premises T and the conclusion F.  So the argument is invalid.

   Example  Test the argument form for validity

         1.  P -> (Q ∨ R), Q -> S, P  ⊢  ￢R -> S
               T             T     T         F

         2.  P -> (Q ∨ R), Q -> S, P  ⊢  ￢R -> S
               T             T     T     T   F  F

         3.  P -> (Q ∨ R), Q -> S, P  ⊢  ￢R -> S
             T T             T  F  T     T F F  F

         4.  P -> (Q ∨ R), Q -> S, P  ⊢  ￢R -> S
             T T     T F   F T  F  T     T F F  F

         5.  P -> (Q ∨ R), Q -> S, P  ⊢  ￢R -> S
             T T   F T F   F T  F  T     T F F  F
                     *

   We've discovered a contradiction.  The highlighted disjunction can't be
   T if Q and R are both F.  Therefore, the form is valid.

Truth-Trees
===========

   Decidability

   If there's an algorithm for determining whether or not an argument form
   expressible in a formal system such as propositional logic is valid, then
   that system is DECIDABLE.  Truth-tables and fast truth-table both
   constitute such algorithms.  Therefore, the logic is decidable.  But those
   methods can become impractical when the set of proposition symbols starts
   to grow.  Truth-trees provide a more efficient algorithm for performing
   the same tasks.

   Tree Graphs

   Below is a tree graph; which are useful in organizing some kinds of
   information.  The lines are called EDGES, which connect NODES or VERTICES.
   A node that has an edge above it is CHILD; and conversely a node that has
   an edge below it is called a PARENT.  Tree graphs are inverted from their
   counterparts in nature, so the ROOT of a tree is at the top from which
   the rest of the tree descends, and so the childless LEAVES are all at the
   bottom.  Traversing a series of edges via their joining nodes all the way
   down to a leaf is called a PATH (e.g. parent&child -> node -> leaf4).
   Trees split as we descend paths, each split is a BRANCH.

                             Root 
                             /  \
                            /    \
                        leaf1    parent&Child 
                                 /          \
                                /            \
                             child           node 
                             /   \           /   \
                            /     \         /     \
                         leaf2   leaf3   leaf4   leaf5

   Truth-Trees

   Given a set of wffs a TRUTH-TREE is an exhaustive search for ways in which
   all the wffs can be true.  The nodes of our tree will each have a list of
   one or more wffs.  A CLOSED PATH is any path that's terminated by '⊥'.
   So, an OPEN PATH is any path that's not closed.

   Procedure
   1.  Write down a vertical list of the wffs to be tested.  This list forms
       the root of the tree, so place it at the top of the page.

   2.  Repeatedly apply the following rules in any order.  The tree
       is completed when no additional rules can be applied.

   Note that while the order rules are applied rules doesn't matter, to keep
   the tree smaller, at each step always apply all non-branching rules before
   applying branching rules.

   A STAR next to a wff indicates it's no longer available to apply rules.

   ====  =====================================================================
   Name  Rule
   ====  =====================================================================
   ￢    If an open path contains both a formula and its negation, close it
         by placing '⊥' at the bottom of the path.

   ￢￢  If an open path contains an unstarred instance of ￢￢Φ, star it
         and write Φ at the bottom of every open path below it.

   ∧     If an open path contains an unstarred instance of Φ ∧ Ψ, star it
         and write both Φ and Ψ at the bottom of every open path that contains
         this newly starred wff.

   ￢∧   If an open path contains an unstarred instance of ￢(Φ ∧ Ψ), star
         it and split the bottom of each open path containing this newly
         starred wff into two branches, at the end of the first branch write
         ￢Φ and at the end of the second branch write ￢Ψ.

   ∨     If an open path contains an unstarred instance of Φ ∨ Ψ, star it
         and split the bottom of each open path containing this newly starred
         wff into two branches, at the end of the first branch write Φ and at
         the end of the second branch write Ψ.

   ￢∨   If an open path contains an unstarred instance of ￢(Φ ∨ Ψ), star
         it and write both ￢Φ and ￢Ψ at the bottom of every open path that
         contains this newly starred wff.

   ->    If an open path contains an unstarred instance of Φ -> Ψ, star it
         and split the bottom of each open path containing this newly starred
         wff into two branches, at the end of the first branch write ￢Φ and
         at the end of the second branch write Ψ.

   ￢->  If an open path contains an unstarred instance of ￢(Φ -> Ψ),
         star it and write both Φ and ￢Ψ at the bottom of every open path
         that contains this newly starred wff.

   <->   If an open path contains an unstarred instance of Φ <-> Ψ, star
         it and split the bottom of each open path containing this newly
         starred wff into two branches, at the end of the first write both
         Φ and Ψ, and at the end of the second write both ￢Φ and ￢Ψ.

   ￢<-> If an open path contains an unstarred instance of ￢(Φ <-> Ψ), star
         it and split the bottom of each open path containing this newly
         starred wff into two branches, at the end of the first write both
         Φ and ￢Ψ, and at the end of the second write both ￢Φ and Ψ.
   ====  =====================================================================

   These rules can also be described in diagrams.

           +---------------------------+---------------------------+         
           | ========================= | ========================= |
           |           ￢Rule          |            ￢￢Rule       |
           | ========================= | ========================= |
           |             Φ             |          * ￢￢Φ          |
           |            ￢Φ            |          --------         |
           |          -------          |             Φ             |
           |             ⊥             |                           |
           |                           |                           |
           | ========================= | ========================= |           
           |           ∧Rule           |           ￢∧Rule         |
           | ========================= | ========================= |
           |         * Φ ∧ Ψ           |        * ￢(Φ ∧ Ψ)        |
           |          -------          |         -----------       |
           |             Φ             |            /     \        |
           |             Ψ             |          ￢Φ     ￢Ψ      |
           |                           |                           |
           | ========================= | ========================= |
           |           ∨Rule           |           ￢∨Rule         |
           | ========================= | ========================= |
           |         * Φ ∨ Ψ           |        * ￢(Φ ∨ Ψ)        |
           |          -------          |         -----------       |
           |           /   \           |             ￢Φ           |
           |          Φ     Ψ          |             ￢Ψ           |
           |                           |                           |
           | ========================= | ========================= |
           |           ->Rule          |          ￢->Rule         |
           | ========================= | ========================= |
           |         * Φ -> Ψ          |       * ￢(Φ -> Ψ)        |
           |          --------         |        ------------       |
           |           /    \          |             Φ             |
           |         ￢Φ      Ψ        |            ￢Ψ            |
           |                           |                           |
           | ========================= | ========================= |
           |          <->Rule          |         ￢<->Rule         |
           | ========================= | ========================= |
           |        * Φ <-> Ψ          |       * ￢(Φ <-> Ψ)       |
           |         ---------         |        -------------      |
           |          /     \          |           /     \         |
           |         Φ      ￢Φ        |          Φ      ￢Φ       |
           |         Ψ      ￢Ψ        |         ￢Ψ       Ψ       |
           |                           |                           |
           +---------------------------+---------------------------+


Truth-Tree Analysis
===================

   Truth-Tree Study of Single WFFs

   To test a single wff using a truth-tree, we treat our wff as the set
   of formulas being tested.  Then conduct the search process.

   If the completed tree for one wff contains no open paths then the wff is
   inconsistent.  If it contains one or more open paths the wff is consistent.
   If it contains two or more open paths then the wff is either tautologous or
   contingent.  To find out which construct a second tree for the negation
   of the original wff.  A wff is tautologous iff its negation is
   inconsistent.  Otherwise it's contingent.

         =============   ==========================   ==========
         Condition       wff                          ￢wff
         =============   ==========================   ==========
         0  open paths   inconsistent                 tautology
         1+ open paths   consistent                   contingent
         2+ open paths   tautology or contingency     contingent
         =============   ==========================   ==========

   Truth-Tree Study of Sets of Wffs

   To test a set of wffs using a truth-tree, we list vertically the wffs
   forming the root.  Then conduct the search process by applying the above
   rules in any order.

   The set of wffs is truth-functionally consistent if the tree has at least
   one open path. If the tree has no open paths the set of wffs is
   inconsistent.

         =============   ==========================
         Condition       wff Set
         =============   ==========================
         0  open paths   inconsistent
         1+ open paths   consistent
         =============   ==========================

   Semantic-Tree Study of Sequents

   To test an argument form for validity using a truth-tree, we construct
   a list consisting of the argument's premises and negated conclusion.
   The tree is then constructed as usual.

   When the tree is completed we can assess the results.  If all paths
   are closed with a ⊥ then the argument form is valid.

   Any open paths of a finished tree for an argument form show all the
   counterexamples to that form.  Where a negated proposition symbol
   is F, and an un-negated proposition symbol is T.

         =============   ==========================
         Condition       Premises & ￢Conclusion
         =============   ==========================
         0  open paths   valid
         1+ open paths   Invalid w/ counterexamples
         =============   ==========================

------------------------------------
Propositional Calculus (Fitch Style)
------------------------------------

Formal Proofs
=============

Direct Proofs
-------------

   A PROOF is a non-circular, unambiguous, deductive argument.

   It's customary (though not necessary) to conclude the proof with the 
   letters QED (QUOD ERAT DEMONSTRANDUM; Latin for "what was to be shown");
   which signals to the reader that the proof has completed successfully.
   I'll also precede the proof with the word 'Proof' so the two surround
   the proof and serve similar roles to a pair of braces or a begin/end pair
   such as in programming.

   A FORMAL DEDUCTIVE SYSTEM (AKA CALCULUS) is a set of rules that describe
   truth-preserving inferences for a given formal language.

   Given a sequent P1,P2,...  ⊢  C; a FORMAL DERIVATION is a list
   of the steps inferred from the premises to derive C using the rules
   of a formal deductive system, a calculus.

   A TWO-COLUMN PROOF is a FORMAL PROOF laid out in a list-like fashion in
   two parallel columns such that the first column contains a line number
   (1, 2, 3, ...) followed by a proposition, the second column holds a
   justification for writing that proposition.  The justification is the
   name of an inference rule, preceded by, citations, a set of any line
   numbers of the propositions to which that rule was applied.  For our
   purposes all propositions will take the form of wffs.

            P -> (Q ∧ R), P  ⊢  Q
            Proof
            01.   P -> (Q ∧ R)     Assumption
            02.   P                Assumption
            03.   Q ∧ R            1,2 Conditional Elimination
            04.   Q                3 Conjunction Elimination
            QED

   In a Fitch style proof it's customary to begin the proof by listing the
   premises, which is what we do in steps 1 and 2.  Notice that the
   justification for those two steps are simply 'Assumption', which is
   another word for premise.  Step 3 makes use of steps 1 and 2, and so
   the justification begins by citing those steps by writing '1,2'.
   'Conditional Elimination' is the name of the inference rule that was
   applied to steps 1 and 2 to reach step 3.  For now don't worry about
   what that means, just understand the structure of the proof.  Step 4
   applies a rule called 'Conjunction Elimination' to step 3 resulting
   in the wff 'Q'.  Since Q is the conclusion form of the proof it's the
   thing we were trying to attain.  So the proof has completed successfully
   which is why the proof is closed with the 'QED'.

   Usually people abbreviate the names of the inference rules within a proof.
   Assumptions are abbreviated as 'A'.  For each truth-functional operator
   there are two inference rules: one called an 'introduction' rule, the other
   called an 'elimination' rule; these are abbreviated to 'I' and 'E'
   respectively.  The Conditional Elimination rule used above in step
   3 is abbreviated '->E'.  Similarly the Conjunction Elimination rule used
   in step 4 is abbreviated '∧E'.

   A DIRECT PROOF is any formal proof which has no indented steps.

Hypothetical Subordinate Proofs
-------------------------------

   A HYPOTHETICAL SUBORDINATE PROOF or SUBPROOF is a proof nested within
   another proof.  It's analogous to nesting blocks of code in a computer
   program, and similarly we can nest subproofs to any depth.  We indent
   subproof from the surrounding proof and draw a vertical line just to
   the right of the wffs to signal that something is a subproof.  Along
   the same lines of listing premises first in the main proof, in the first
   line of a subproof the proposition called the HYPOTHESIS, which
   is a proposition we plan to test in the subproof.

            P -> Q, ￢Q  ⊢  ￢P
            Proof
            01.   P -> Q        A            Begin by listing the premises
            02.   ￢Q           A
            03.   |   P         H (for ￢I)  Try to prove ￢P using ￢I.
            04.   |   Q         1,3 ->E      Use steps 1 & 3 to perform ->E.
            05.   |   Q ∧ ￢Q   2,4 ∧I       Use steps 2 & 4 to perform ∧I.
            06.   ￢P           3-5 ￢I      use steps 3 to 5 to perform ￢I.
            QED

   In this example the A's in the second column of steps 1 and 2 signal
   that those wffs are assumptions.  Line 3 begins a subproof with hypothesis
   (H) of P.  The contents of the parentheses communicates to the reader that
   the goal of this hypothetical proof is to eventually reach a point where
   ￢I (Negation Introduction) can operate on the hypothesis.  Line 4 applies
   ->E (Conditional Elimination) to propositions 1 and 3 resulting in 'Q'.
   In line 5 ∧I operates upon propositions 2 and 4 producing Q ∧ ￢Q.  Line
   5 ends the subproof and line 6 returns our attention to the enclosing
   proof, the main proof.  Recall that the goal of the hypothetical subproof
   was to perform ￢I; which is now performed on line 6.  Notice the citation
   is a range of steps '3-5' which is the entirety of the subproof.  This
   essentially says that the subproof provides justification for applying
   the ￢I rule to obtain ￢P, which is the conclusion form of the sequent
   so the proof completed successfully hence the 'QED'.

Regarding Notation
==================

   Φ(Q) denotes a wff Φ contains one or more occurrences
   of a sub-wff Q.

   Φ(R/Q) denotes the result of replacing one or more occurrences
   of Q in Φ(Q) with R.  R/Q is read, "R replaced one or more
   occurrences of Q", or simply "R for some Q".

   Φ(R//Q) like above but indicates replacing all occurrences of Q in Φ(Q)
   with R.  R//Q is read, "R replaced all occurrences of Q", or simply
   "R for every Q".

   ( Φ ⊢ Ψ ), indicates a subproof with hypothesis Φ concluding with Ψ.

   [ ... ] indicate that the enclosed must exist, be defined or proven
   elsewhere (external to the proof).

Primitive Inference Rules
=========================

   Here are the basic inference rules.  Some of them have multiple names
   and abbreviations for each name is in parentheses.  Use any name you
   prefer, to maintain a fitch style use the 'introduction' and 'elimination'
   names when available.

   ================================  =========================================
   Name (Abbreviation)               Rule
   ================================  =========================================
   Assumption (A)                    Introduce a premise at any step.

   Hypothesis (H)                    Introduce a hypothesis at any step
                                     provided it begins a new subproof.

   Axiom (Ax)                        Introduce an axiom at any step.

   Negation Elimination (￢E)        From ￢￢Φ, infer Φ.

   Negation Introduction (￢I)       From a subproof with hypothesis Φ
      Reductio ad absurdum (RAA)     ending in (Ψ ∧ ￢Ψ), close the subproof,
      Proof by Contradiction (PBC)   and infer ￢Φ.
      Indirect Proof (IP)

   Conjunction Elimination (∧E)      From Φ ∧ Ψ, infer Φ, or infer Ψ.
      Simplification (Simp)

   Conjunction (∧I)                  From Φ and Ψ, infer Φ ∧ Ψ,
                                     or infer Ψ ∧ Φ.

   Disjunction Elimination (∨E)      From Φ ∨ Ψ, Φ -> Θ and Ψ -> Θ, infer Θ.
      Proof by Cases (PBC)

   Disjunction Introduction (∨I)     From Φ, infer Φ ∨ Ψ, or infer Ψ ∨ Φ.
      Addition (Add)

   Conditional Elimination (->E)     From Φ -> Ψ and Φ, infer Ψ.
      Modus Ponens (MP)

   Conditional Introduction (->I)    From a subproof with hypothesis Φ
      Conditional Proof (CP)         and ending Ψ, close the subproof,
                                     and infer Ψ -> Φ.

   Biconditional Elimination (<->E)  From Φ <-> Ψ, infer Φ -> Ψ,
                                     or infer Ψ -> Φ.

   Biconditional Introduction (<->I) From Φ -> Ψ and Ψ -> Φ, infer Φ <-> Ψ

   Equivalence Substitution (EQ)     From [ Φ <-> Ψ ], and Θ(Φ), infer Θ(Ψ/Φ);
                                     or from [ Φ <-> Ψ ] and Θ(Ψ),
                                     infer Θ(Φ/Ψ).
   ================================  =========================================

   Diagrams are another way to describe these rules.  Some rules have
   multiple forms.  The horizontal lines denotes 'infer', and the vertical
   line denotes a subproof.

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  A                            |  H                            |
      | ============================= | ============================= |
      |                               |                               |
      |  ---                          |  -------                      |
      |   Φ   (Φ is a premise)        |   |   Φ   (Φ is a hypothesis) |
      |                               |                               |
      | ============================= | ============================= |
      |  ￢E                          |  ￢I                          |
      | ============================= | ============================= |
      |   ￢￢Φ                       |   |   Φ                       |
      |  -------                      |   |   ...                     |
      |   Φ                           |   |   Ψ ∧ ￢Ψ                 |
      |                               |  --------------               |
      |                               |   ￢Φ                         |
      |                               |                               |
      | ============================= | ============================= |
      |  ∧E                           |  ∧I                           |
      | ============================= | ============================= |
      |   Φ ∧ Ψ    Φ ∧ Ψ              |   Φ        Φ                  |
      |  -------  -------             |   Ψ        Ψ                  |
      |   Φ        Ψ                  |  -------  -------             |
      |                               |   Φ ∧ Ψ    Ψ ∧ Φ              |
      |                               |                               |
      | ============================= | ============================= |
      |  ∨E                           |  ∨I                           |
      | ============================= | ============================= |
      |   Φ ∨ Ψ                       |   Φ        Φ                  |
      |   Φ -> Θ                      |  -------  -------             |
      |   Ψ -> Θ                      |   Φ ∨ Ψ    Ψ ∨ Φ              |
      |  --------                     |                               |
      |   Θ                           |    (Ψ is any wff whatever)    |
      |                               |                               |
      | ============================= | ============================= |
      |  ->E                          |  ->I                          |
      | ============================= | ============================= |
      |   Φ -> Ψ                      |   |   Φ                       |
      |   Φ                           |   |   ...                     |
      |  ---------                    |   |   Ψ                       |
      |   Ψ                           |  ---------                    |
      |                               |   Φ -> Ψ                      |
      |                               |                               |
      | ============================= | ============================= |
      |  <->E                         |  <->I                         |
      | ============================= | ============================= |
      |   Φ <-> Ψ    Φ <-> Ψ          |   Φ -> Ψ     Φ -> Ψ           |
      |  ---------  ---------         |   Ψ -> Φ     Ψ -> Φ           |
      |   Φ -> Ψ     Ψ -> Φ           |  ---------  ---------         |
      |                               |   Φ <-> Ψ    Ψ <-> Φ          |
      |                               |                               |
      | ============================= | ============================= |
      |  EQ (Equiv. Substitution)     |  Ax (Axiom)                   |
      | ============================= | ============================= |
      |   [ Φ <-> Ψ ]    [ Φ <-> Ψ ]  |                               |
      |   Θ(Φ)           Θ(Ψ)         |  ---                          |
      |  -------------  ------------- |   Φ   (Φ is an axiom)         |
      |   Θ(Ψ/Φ)         Θ(Φ/Ψ)       |                               |
      |                               |                               |
      +-------------------------------+-------------------------------+

Pseudo Inference Rules
======================

   The following aren't inference rules but appear in proofs as if they
   were inference rules.

   ================================  =========================================
   Name/Alternate Names              Rule
   ================================  =========================================
   Definition Substitution (DEF)     From [ Φ =df Ψ ], Θ(Φ), infer Θ(Ψ/Φ);
                                     and [ Φ =df Ψ ], Θ(Ψ), infer Θ(Φ/Ψ).
   ================================  =========================================

Derived Inference Rules
=======================

   Use any proven sequent as a new inference rule; if a sequent is proven
   valid, then all instances of the sequent are also valid.  The following
   are traditionally important rules derivable in our system.

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Reiterate (RE)                    P  ⊢  P
   Falso Quodlibet (EFQ)             P, ￢P  ⊢  Q    (Q is any wff whatever)
   Modus Tollens (MT)                P -> Q, ￢Q  ⊢  ￢P
   Hypothetical Syllogism (HS)       P -> Q, Q -> R  ⊢  P -> R
   Absorption (Abs)                  P -> Q  ⊢  P -> (P ∧ Q)
   Constructive Dilemma (CD)         P ∨ Q, P -> R, Q -> S  ⊢  R ∨ S
   Destructive Dilemma (DD)          P -> Q, R -> S, ￢Q ∨ ￢S ⊢ ￢P ∨ ￢Q
   Disjunctive Syllogism (DS)        P ∨ Q, ￢P  ⊢  Q
   Disjunctive Syllogism (DS)        P ∨ Q, ￢Q  ⊢  P
   Theorem (THM)                     [ ⊢ P ]  ⊢  P
   ================================  =========================================

Theorems
========

   A theorem of propositional calculus is a derived rule which has no premises
   or undischarged hypotheses.  Theorems are the tautologies of propositional
   logic.  A sequent for a theorem Φ has the following form.  A theorem
   of our calculus is proven by starting the proof with a hypothesis or with
   a previously proven theorem.

         ⊢ Φ

Equivalences
============

   An equivalence is a theorem in the form of a biconditional.  The following
   are traditionally important equivalences derivable in our system.

         ⊢ Φ <-> Ψ

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Double Negation (DN)              ⊢  P <-> ￢￢P
   Tautology (TAUT)                  ⊢  P <-> (P ∧ P)
   Tautology (TAUT)                  ⊢  P <-> (P ∨ P)
   Transposition (TRANS)             ⊢  (P -> Q) <-> (￢Q -> ￢P)
   Material Implication (MI)         ⊢  (P -> Q) <-> (￢P ∨ Q)
   Association (ASSOC)               ⊢  (P ∧ (Q ∧ R)) <-> ((P ∧ Q) ∧ R)
   Association (ASSOC)               ⊢  (P ∨ (Q ∨ R)) <-> ((P ∨ Q) ∨ R)
   Commutation (COM)                 ⊢  (P ∧ Q) <-> (Q ∧ P)
   Commutation (COM)                 ⊢  (P ∨ Q) <-> (Q ∨ P)
   Exportation (EXP)                 ⊢  ((P ∧ Q) -> R) <-> (P -> (Q -> R))
   Distribution (DIST)               ⊢  (P ∧ (Q ∨ R)) <-> ((P ∧ Q) ∨ (P ∧ R))
   Distribution (DIST)               ⊢  (P ∨ (Q ∧ R)) <-> ((P ∨ Q) ∧ (P ∨ R))
   DeMorgan's law (DM)               ⊢  ￢(P ∧ Q) <-> (￢P ∨ ￢Q)
   DeMorgan's law (DM)               ⊢  ￢(P ∨ Q) <-> (￢P ∧ ￢Q)
   Material Equivalence (ME)         ⊢  (P <-> Q) <-> ((P -> Q) ∧ (Q -> P))
   Material Equivalence (ME)         ⊢  (P <-> Q) <-> ((P ∧ Q) ∨ (￢P ∧ ￢Q))
   ================================  =========================================

Consequence and Non-Consequence
===============================
   A PROOF OF CONSEQUENCE is a proof that demonstrates that some wff C is
   derivable by repeatedly applying inference rules.  It's the kind of proof
   we've been discussing all along.  The example proofs presented so far are
   all proofs of consequence.

   A PROOF OF NON-CONSEQUENCE is a demonstration that some wff C is *not*
   derivable, by any number of applications of inference rules, from a set
   of premises.  The proof constructed lists the counterexamples.

   Construct a proof of non-consequence by first listing the premises,
   then begin a subproof by hypothesizing the negation of the conclusion.
   Procede by attempting to reduce everything to atomic and negated
   atomic formulas.  Proceed until no additional rules can be applied.
   Since we never reach the conclusion the proof is uncompleted, so we
   don't write QED at the bottom.

         Example

            P -> Q, ￢P  ⊢  ￢Q
         Proof
         01.   P -> Q        A
         02.   ￢P           A
         03.   |   Q         H (for ￢I)

   Once finished the valuations can be read off the proof.  The above proof
   tells us that the counterexamples are where P is false (due to occurring
   negated in step 2), and Q is true (due to occurring un-negated in step 3).
   We can verify this with a truth-table.

          P Q | P -> Q , ￢ P  ⊢  ￢ Q
         =============================
          F F | F T  F | T F  |   T F
          F T | F T  T | T F  |   F T  <==
          T F | T F  F | F T  |   T F
          T T | T T  T | F T  |   F T
                  *      *        *

   The highlighted row is our counterexample (all true premises but
   false conclusion).  On that row P and Q have the same truth-values as
   our proof determined.


Defining ⊥ Into Propositional Logic/Calculus
============================================

   Some Fitch implementations use ⊥ (the contradiction symbol) to remove
   tedium and improve readability of proofs.  Applications ￢I are often
   preceded by ∧I, but the resulting conjunction can be quite long.  Since
   EFQ infers any wff from two contradictory propositions we can always
   infer 'P ∧ ￢P' instead of a long conjunction.  But the following
   definition is even better.

         ⊥  =df  P ∧ ￢P

   From which we derive new inferential machinery.
  
   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   ⊥ Introduction (⊥ I)              P, ￢P  ⊢  ⊥
   ⊥ Elimination (⊥ E)               (P ⊢ ⊥)  ⊢  ￢P
   ================================  =========================================

----------------------
Philosophical Concerns
----------------------

The Unnatural Conditional
=========================

   A serious concern when it comes to the propositional logic conditional
   is that it only denotes a small part of what if/then statements can
   express.  This makes it quite controversial and many doubt the full power
   of English if/then statements can ever be captured in a formal logical
   system.  Moreover, propositional logic conditional can produce some
   surprising results.  Let's revisit a prior example.

         K -> F        if you keep up the good work then you'll go far.

   Now lets consider what happens if we take it's negation.

         ￢(K -> F)    it's false that if you keep up the work you'll go far
         ￢(￢K ∨ F)   Material Implication
         K ∧ ￢F       DeMorgan's

   Studying the conclusion we determine that is says, you keep up the good
   work and you don't go far.  Does this really sound like the negation of
   the original unnegated conditional wff?

Refuting Dilemmas
=================

   A dilemma is a disjunctive premise that states exactly two options.  Being
   IN A DILEMMA or IMPALED BY THE HORNS OF A DILEMMA means that the person
   presented with the dilemma is confronted with a choice between two
   undesirable options.  GRASPING THE BULL BY THE HORNS is proving one of the
   disjuncts true.  ESCAPING BETWEEN THE HORNS is proving the disjunction
   false by either proving there's a third option, or proving that both
   disjuncts are false.

Relevance
=========

   Some philosophers have concerns over the inference rules ∨I, and H
   because they provide a way for an arguer to introduce any statement
   whatever into the proof relevant or not.   Their particular concern
   is that this exposes a serious problem for FOC.  They've gone so far
   as to introduce new systems of logic which remove such rules.

   The classical perspective is these issues don't matter because the
   inference rules are sufficient to weed out inconsistent sentences
   wherever doing so makes sense, and that conclusions found by FOC=
   always do conform to the definition of a valid deductive argument.
   If one asserts that Φ is true, then referring back to the valuation
   function v for disjunction shows that no matter what value of Ψ we
   introduce, Φ ∨ Ψ will still be true simply because Φ is true.
   While for H, it doesn't matter what we hypothesize.  If some
   hypothesis Θ is inconsistent with the premises Θ will be negated after
   the subproof is closed.  But if Θ is not inconsistent with the premises
   then by definition it's consistent relevant or not and whose to say
   what is and isn't relevant anyway.  Classical logic regards these as
   arguments adequate to justify the inclusion and current formulation
   of these rules.

Semantic Soundness & Completeness of TFC
========================================

   A calculus is SEMANTICALLY SOUND if and only if for any consistent
   set of premise wffs valid applications of the inference rules result
   in *only* valid conclusions even if rules are applied randomly.

   A calculus is SEMANTICALLY COMPLETE if and only if for any consistent set
   of premise wffs valid applications of the inference rules result in *all
   possible* valid conclusions even if rules are applied randomly.

   If a given conclusion Φ logically follows from a set of premises, then
   there exists at least one proof of Φ that has a finite number of steps.

   Propositional calculus is semantically sound and semantically complete.
   We don't prove these theorems here but it's handy to know of them.
   The calculus derives all and only valid conclusions from any given set
   of premises.

-------------------------------
TFC Proofs of The Derived Forms
-------------------------------

Important Derived Rules
=======================

⊥ Inference Rules
-----------------

   ⊥ Introduction (⊥ I):   P, ￢P  ⊢  ⊥
   Proof
   01.   P                        A
   02.   ￢P                      A
   03.   P ∧ ￢P                  1,2 ∧I
   04.   ⊥                        3 DEF ⊥
   QED

   ⊥ Elimination (⊥ E):   (P ⊢ ⊥)  ⊢  ￢P
   Schematic Proof
    i.   |   P                    H (for ->I)
    ...  |   ...                  ...
    j.   |   ⊥
    k.   P -> ⊥                   i - j ->I
    k+1. |   P                    H (for ￢I)
    k+2. |   ⊥                    k,k+1 ->E
    k+3. |   P ∧ ￢P              k+2 DEF ⊥
    k+4. ￢P                      k+1 - k+3 ￢I
    QED

The Remaining Basic Derived Rules
---------------------------------

   Reiterate (RE):   P   ⊢   P
   Proof
   01.   P                        A
   02.   P ∧ P                    1 ∧I
   03.   P                        2 ∧E
   QED

   Ex Falso Quodlibet (EFQ):   P, ￢P  ⊢  Q
   Proof
   01.   P                        A
   02.   ￢P                      A
   03.   |   ￢Q                  H (for ￢I)
   04.   |   P ∧ ￢P              1,2 ∧I
   05.   ￢￢Q                    3-4 ￢I
   06.   Q                        5 ￢E
   QED

   Modus Tollens (MT):   P -> Q, ￢Q  ⊢  ￢P
   Proof
   01.   P -> Q                   A
   02.   ￢Q                      A
   03.   |   P                    H (for ￢I)
   04.   |   Q                    1,3 ->E
   05.   |   ⊥                    2,4 ⊥ I
   06.   ￢P                      3-5 ⊥ E
   QED

   Hypothetical Syllogism (HS):   P -> Q, Q -> R  ⊢  P -> R
   Proof
   01.   P -> Q                   A
   02.   Q -> R                   A
   03.   |   P                    H (for R)
   04.   |   Q                    1,3 ->E
   05.   |   R                    2,4 ->E
   06.   P -> R                   3-5 ->I
   QED

   Absorption (ABS):  P -> Q  ⊢  P -> (P ∧ Q)
   Proof
   01.   P -> Q                   A
   02.   |   P                    H (for P ∧ Q)
   03.   |   Q                    1,2 ->E
   04.   |   P ∧ Q                2,3 ∧I
   05.   P -> (P ∧ Q)             2-4 ->I
   QED

   Constructive Dilemma (CD):   P ∨ Q, P -> R, Q -> S  ⊢  R ∨ S
   Proof
   01.   P ∨ Q                    A
   02.   P -> R                   A
   03.   Q -> S                   A
   04.   |   P                    H (for ->I)
   05.   |   R                    2,4 ->E
   06.   |   R ∨ S                5 ∨I
   07.   P -> (R ∨ S)             4-6 ->I
   08.   |   Q                    H (for ->I)
   09.   |   S                    3,8 ->E
   10.   |   R ∨ S                9 ∨I
   11.   Q -> (R ∨ S)             9-12 ->I
   12.   R ∨ S                    1,7,11 ∨E
   QED

   Destructive Dilemma (DD):    P -> Q, R -> S, ￢Q ∨ ￢S  ⊢  ￢P ∨ ￢R
   Proof
   01.   P -> Q                   A
   02.   R -> S                   A
   03.   ￢Q ∨ ￢S                A
   04.   |   ￢Q                  H (for ->I)
   05.   |   ￢P                  1,4 MT
   06.   |   ￢P ∨ ￢R            5 ∨I
   07.   ￢Q -> (￢P ∨ ￢R)       4-6 ->I
   08.   |   ￢S                  H (for ->I)
   09.   |   ￢R                  2,8 MT
   10.   |   ￢P ∨ ￢R            9 ∨I
   11.   ￢S -> (￢P ∨ ￢R)       8-10 ->I
   12.   ￢P ∨ ￢R                3,7,11 ∨E
   QED

   Disjunctive Syllogism (DS):  P ∨ Q, ￢P  ⊢  Q
   Proof
   01.   P ∨ Q                    A
   02.   ￢P                      A
   03.   |   P                    H (for ->I)
   04.   |   Q                    2,3 EFQ
   05.   P -> Q                   3-4 ->I
   06.   |   Q                    H (for ->I)
   07.   |   Q                    6 RE
   08.   Q -> Q                   6-7 ->I
   09.   Q                        1,5,8 ∨E
   QED

   Disjunctive Syllogism (DS):   P ∨ Q, ￢Q  ⊢  P
   Proof
   01.   P ∨ Q                    A
   02.   ￢Q                      A
   03.   |   P                    H (for ->I)
   04.   |   P                    3 RE
   05.   P -> P                   3-4 ->I
   06.   |   Q                    H (for ->I)
   07.   |   P                    2,6 EFQ
   08.   Q -> P                   6-7 ->I
   09.   P                        1,5,8 ∨E
   QED

Important Derived Equivalences
------------------------------

   Double Negation (DN):   ⊢  P <-> ￢￢P
   Proof
   01.   |   P                    H (for ->I)
   02.   |   |   ￢P              H (for ￢I)
   03.   |   |   ⊥                1,2 ⊥ I
   04.   |   ￢￢P                2-3 ￢I
   05.   P -> ￢￢P               1-4 ->I
   06.   |   ￢￢P                H (for ->I)
   07.   |   P                    6 ￢E
   08.   ￢￢P -> P               6,7 ->I
   09.   P <-> ￢￢P              5,8 <->I
   QED

   Tautology (TAUT):   ⊢  P <-> (P ∧ P)
   Poof
   01.   |   P                    H (for ->I)
   02.   |   P ∧ P                1,1 ∧I
   03.   P -> (P ∧ P)             2-3 ->I
   04.   |   P ∧ P                H (for ->I)
   05.   |   P                    4 ∧E
   06.   (P ∧ P) -> P             4-5 ->I
   07.   P <-> (P ∧ P)            3,6 <->I
   QED

   Tautology (TAUT):   ⊢  P <-> (P ∨ P)
   Proof
   01.   |   P                    H (for ->I)
   02.   |   P ∨ P                1 ∨I
   03.   P -> (P ∨ P)             1-2 ->I
   04.   |   P ∨ P                H (for ->I)
   05.   |   |   P                H (for ->I)
   06.   |   |   P                5 RE
   07.   |   P -> P               5-6 ->I
   08.   |   P -> P               7 RE
   09.   |   P                    4,7,8 ∨E
   10.   (P ∨ P) -> P             4-9 ->I
   11.   P <-> (P ∨ P)            3,10 <->I
   QED

   Transposition (TRANS):  ⊢  (P -> Q) <-> (￢Q -> ￢P)
   Proof
   01.   |   P -> Q               H (for ->I)
   02.   |   |   ￢Q              H (for ->I)
   03.   |   |   ￢P              1,2 MT
   04.   |   ￢Q -> ￢P           2-3 ->I
   05.   (P -> Q) -> (￢Q -> ￢P) 1-4 ->I
   06.   |   ￢Q -> ￢P           H (for ->I)
   07.   |   |   P                H (for ->I)
   08.   |   |   ￢￢P            7 DN
   09.   |   |   ￢￢Q            6,8 MT
   10.   |   |   Q                9 ￢E
   11.   |   P -> Q               7-10 ->I
   12.   (￢Q -> ￢P) -> (P -> Q)   6-11 ->I
   13.   (P -> Q) <-> (￢Q -> ￢P)  5,12 <->I
   QED

   Material Implication (MI):   ⊢  (P -> Q) <-> (￢P ∨ Q)
   Proof
   01.   |   P -> Q               H (for ->I)
   02.   |   |   ￢(￢P ∨ Q)      H (for ￢I)
   03.   |   |   |   P            H (for ￢I)
   04.   |   |   |   Q            1,3 ->E
   05.   |   |   |   ￢P ∨ Q      4 ∨I
   06.   |   |   |   ⊥            2,5 ⊥ I
   07.   |   |   ￢P              3-6 ⊥ E
   08.   |   |   ￢P ∨ Q          7 ∨I
   09.   |   |   ⊥                2,8 ⊥ I
   10.   |   ￢￢(￢P ∨ Q)        2-9 ⊥ E
   11.   |   ￢P ∨ Q              10 ￢E
   12.   (P -> Q) -> (￢P ∨ Q)    1-11 ->I
   13.   |   ￢P ∨ Q              H (for ->I)
   14.   |   |   P                H (for ￢I)
   15.   |   |   ￢￢P            14 DN
   16.   |   |   Q                13,15 DS
   17.   |   P -> Q               14-16 ->I
   18.   (￢P ∨ Q) -> (P -> Q)    13-17 ->I
   19.   (P -> Q) <-> (￢P ∨ Q)   12,18 <->I
   QED

   Association (ASSOC):   ⊢  (P ∧ (Q ∧ R)) <-> ((P ∧ Q) ∧ R)
   Proof
   01.   |   P ∧ (Q ∧ R)                         H (for ->I)
   02.   |   P                                   1 ∧E
   03.   |   Q ∧ R                               1 ∧E
   04.   |   Q                                   3 ∧E
   05.   |   R                                   3 ∧E
   06.   |   P ∧ Q                               2,4 ∧I
   07.   |   (P ∧ Q) ∧ R                         5,6 ∧I
   08.   (P ∧ (Q ∧ R)) -> ((P ∧ Q) ∧ R)          1-7 ->I
   09.   |   (P ∧ Q) ∧ R                         H (for ->I)
   10.   |   P ∧ Q                               9 ∧E
   11.   |   R                                   9 ∧E
   12.   |   P                                   10 ∧E
   13.   |   Q                                   10 ∧E
   14.   |   Q ∧ R                               11,13 ∧I
   15.   |   P ∧ (Q ∧ R)                         12,14 ∧I
   16.   ((P ∧ Q) ∧ R) -> (P ∧ (Q ∧ R))          9-15 ->I
   17.   (P ∧ (Q ∧ R)) <-> ((P ∧ Q) ∧ R)         8,16 <->I
   QED

   Association (ASSOC):   ⊢  (P ∨ (Q ∨ R)) <-> ((P ∨ Q) ∨ R)
   Proof
   01.   |   P ∨ (Q ∨ R)                         H (for ->I)
   02.   |   |   P                               H (for ->I)
   03.   |   |   P ∨ Q                           2 ∨I
   04.   |   |   (P ∨ Q) ∨ R                     3 ∨I
   05.   |   P -> ((P ∨ Q) ∨ R)                  2-4 ->I
   06.   |   |   Q ∨ R                           H (for ->I)
   07.   |   |   |   Q                           H (for ->I)
   08.   |   |   |   P ∨ Q                       7 ∨I
   09.   |   |   |   (P ∨ Q) ∨ R                 8 ∨I
   10.   |   |   Q -> ((P ∨ Q) ∨ R)              7-9 ->I
   11.   |   |   |   R                           H (for ->I)
   12.   |   |   |   (P ∨ Q) ∨ R                 11 ∨I
   13.   |   |   R -> ((P ∨ Q) ∨ R)              11-12 ->I
   14.   |   |   (P ∨ Q) ∨ R                     6,10,13 ∨E
   15.   |   (Q ∨ R) -> ((P ∨ Q) ∨ R)            6-14 ->I
   16.   |   (P ∨ Q) ∨ R                         1,5,15 ∨E
   17.   (P ∨ (Q ∨ R)) -> ((P ∨ Q) ∨ R)          1-16 ->I
   18.   |   (P ∨ Q) ∨ R                         H (for ->I)
   19.   |   |   P ∨ Q                           H (for ->I)
   20.   |   |   |   P                           H (for ->I)
   21.   |   |   |   P ∨ (Q ∨ R)                 20 ∨I
   22.   |   |   P -> (P ∨ (Q ∨ R))              20-21 ->I
   23.   |   |   |   Q                           H (for ->I)
   24.   |   |   |   Q ∨ R                       23 ∨I
   25.   |   |   |   P ∨ (Q ∨ R)                 14 ∨I
   26.   |   |   Q -> (P ∨ (Q ∨ R))              23-25 ->I
   27.   |   |   P ∨ (Q ∨ R)                     19,22,26 ∨E
   28.   |   (P ∨ Q) -> (P ∨ (Q ∨ R))            19-27 ->I
   29.   |   |   R                               H (for ->I)
   30.   |   |   Q ∨ R                           29 ∨I
   31.   |   |   P ∨ (Q ∨ R)                     30 ∨I
   32.   |   R -> (P ∨ (Q ∨ R))                  29-31
   33.   |   P ∨ (Q ∨ R)                         13,28,32 ∨E
   34.   ((P ∨ Q) ∨ R) -> (P ∨ (Q ∨ R))          18-33 ->I
   35.   (P ∨ (Q ∨ R)) <-> ((P ∨ Q) ∨ R)         17,34 <->I
   QED

   Commutation (COM):   ⊢  (P ∧ Q) <-> (Q ∧ P)
   Proof
   01.   |   P ∧ Q                               H (for ->I)
   02.   |   P                                   1 ∧E
   03.   |   Q                                   1 ∧E
   04.   |   Q ∧ P                               2,3 ∧I
   05.   (P ∧ Q) -> (Q ∧ P)                      1-4 ->I
   06.   |   Q ∧ P                               H (for ->I)
   07.   |   Q                                   ∧E
   08.   |   P                                   ∧E
   09.   |   P ∧ Q                               ∧I
   10.   (Q ∧ P) -> (P ∧ Q)                      6-9 ->I
   11.   (P ∧ Q) <-> (Q ∧ P)                     5,10 <->I
   QED

   Commutation (COM):   ⊢  (P ∨ Q) <-> (Q ∨ P)
   Proof
   01.   |   P ∨ Q                               H (for ->I)
   02.   |   |   P                               H (for ->I)
   03.   |   |   Q ∨ P                           2 ∨I
   04.   |   P -> (Q ∨ P)                        2-4 ->I
   05.   |   |   Q                               H (for ->I)
   06.   |   |   Q ∨ P                           5 ∨I
   07.   |   Q -> (Q ∨ P)                        5-6 ->I
   08.   |   Q ∨ P                               1,4,7 ∨E
   09.   (P ∨ Q) -> (Q ∨ P)                      1-8 ->I
   10.   |   Q ∨ P                               H (for ->I)
   11.   |   |   Q                               H (for ->I)
   12.   |   |   P ∨ Q                           11 ∨I
   13.   |   Q -> (P ∨ Q)                        11-12 ->I
   14.   |   |   P                               H (for ->I)
   15.   |   |   P ∨ Q                           14 ∨I
   16.   |   P -> (P ∨ Q)                        14-15 ->I
   17.   |   P ∨ Q                               10,13,16 ∨E
   18.   (Q ∨ P) -> (P ∨ Q)                      10-17 ->I
   19.   (P ∨ Q) <-> (Q ∨ P)                     9,18 <->I
   QED

   Exportation (EXP):   ⊢  ((P ∧ Q) -> R) <-> (P -> (Q -> R))
   Proof
   01.   |   (P ∧ Q) -> R                        H (for ->I)
   02.   |   |   P                               H (for ->I)
   03.   |   |   |   Q                           H (for ->I)
   04.   |   |   |   P ∧ Q                       2,3 ∧I
   05.   |   |   |   R                           1,4 ->E
   06.   |   |   Q -> R                          3-5 ->I
   07.   |   P -> (Q -> R)                       2-6 ->I
   08.   ((P ∧ Q) -> R) -> (P -> (Q -> R))       1-7 ->I
   09.   |   P -> (Q -> R)                       H (for ->I)
   10.   |   |   P ∧ Q                           H (for ->I)
   11.   |   |   P                               13 ∧E
   12.   |   |   Q -> R                          9,11 ->E
   13.   |   |   Q                               10 ∧E
   14.   |   |   R                               12,13 ->E
   15.   |   (P ∧ Q) -> R                        10-14 ->I
   16.   (P -> (Q -> R)) -> ((P ∧ Q) -> R)       9-15 ->I
   17.   ((P ∧ Q) -> R) <-> (P -> (Q -> R))      8,16 <->I
   QED

   Distribution (DIST):   ⊢  (P ∧ (Q ∨ R)) <-> ((P ∧ Q) ∨ (P ∧ R))
   Proof
   01.   |   P ∧ (Q ∨ R)                         H (for ->I)
   02.   |   P                                   1 ∧E
   03.   |   Q ∨ R                               1 ∧E
   04.   |   |   Q                               H (for ->I)
   05.   |   |   P ∧ Q                           2,4 ∧I
   06.   |   |   (P ∧ Q) ∨ (P ∧ R)               5 ∨I
   07.   |   Q -> ((P ∧ Q) ∨ (P ∧ R))            4-6 ->I
   08.   |   |   R                               H (for ->I)
   09.   |   |   P ∧ R                           2,8 ∧I
   10.   |   |   (P ∧ Q) ∨ (P ∧ R)               9 ∨I
   11.   |   R -> ((P ∧ Q) ∨ (P ∧ R))            8-10 ->I
   12.   |   (P ∧ Q) ∨ (P ∧ R)                   3,7,11 ∨E
   13.   (P ∧ (Q ∨ R)) -> ((P ∧ Q) ∨ (P ∧ R))    1-12 ->I
   14.   |   (P ∧ Q) ∨ (P ∧ R)                   H (for ->I)
   15.   |   |   P ∧ Q                           H (for ->I)
   16.   |   |   P                               15 ∧E
   17.   |   |   Q                               15 ∧E
   18.   |   |   Q ∨ R                           17 ∨I
   19.   |   |   P ∧ (Q ∨ R)                     17,18 ∧I
   20.   |   (P ∧ Q) -> (P ∧ (Q ∨ R))            15-18 ->I
   21.   |   |   P ∧ R                           H (for ->I)
   22.   |   |   P                               21 ∧E
   23.   |   |   R                               21 ∧E
   24.   |   |   Q ∨ R                           23 ∨I
   25.   |   |   P ∧ (Q ∨ R)                     24 ∧I
   26.   |   (P ∧ R) -> (P ∧ (Q ∨ R))            21-25 ->I
   27.   |   P ∧ (Q ∨ R)                         14,20,26 ∨E
   28.   ((P ∧ Q) ∨ (P ∧ R)) -> (P ∧ (Q ∨ R))    14-27 ->I
   29.   (P ∧ (Q ∨ R)) <-> ((P ∧ Q) ∨ (P ∧ R))   13,28 <->I
   QED

   Distribution (DIST):   ⊢  (P ∨ (Q ∧ R)) <-> ((P ∨ Q) ∧ (P ∨ R))
   Proof
   01.   |   P ∨ (Q ∧ R)                         H (for ->I)
   02.   |   |   P                               H (for ->I)
   03.   |   |   P ∨ Q                           2 ∨I
   04.   |   |   P ∨ R                           2 ∨I
   05.   |   |   (P ∨ Q) ∧ (P ∨ R)               3,4 ∧I
   06.   |   P -> ((P ∨ Q) ∧ (P ∨ R))            2-5 ->I
   07.   |   |   Q ∧ R                           H (for ->I)
   08.   |   |   Q                               7 ∧E
   09.   |   |   R                               7 ∧E
   10.   |   |   P ∨ Q                           8 ∨I
   11.   |   |   P ∨ R                           9 ∨I
   12.   |   |   (P ∨ Q) ∧ (P ∨ R)               10,11 ∧I
   13.   |   (Q ∧ R) -> ((P ∨ Q) ∧ (P ∨ R))      7-12 ->I
   14.   |   (P ∨ Q) ∧ (P ∨ R)                   1,6,13 ∨E
   15.   (P ∨ (Q ∧ R)) -> ((P ∨ Q) ∧ (P ∨ R))    1-14 ->I
   16.   |   (P ∨ Q) ∧ (P ∨ R)                   H (for ->I)
   17.   |   P ∨ Q                               18 ∧E
   18.   |   P ∨ R                               16 ∧E
   19.   |   |   P                               H (for ->I)
   20.   |   |   P ∨ (Q ∧ R)                     19 ∨I
   21.   |   P -> (P ∨ (Q ∧ R))                  19-20 ->I
   22.   |   |   Q                               H (for ->I)
   23.   |   |   |   R                           H (for ->I)
   24.   |   |   |   Q ∧ R                       22,23 ∧I
   25.   |   |   |   P ∨ (Q ∧ R)                 24 ∨I
   26.   |   |   R -> (P ∨ (Q ∧ R))              23-25 ->I
   27.   |   |   P ∨ (Q ∧ R)                     28,21,26 ∨E
   28.   |   Q -> (P ∨ (Q ∧ R))                  22-26 ->I
   29.   |   P ∨ (Q ∧ R)                         17,21,28 ∨E
   30.   ((P ∨ Q) ∧ (P ∨ R)) -> (P ∨ (Q ∧ R))    16-29 ->I
   31.   (P ∨ (Q ∧ R)) <-> ((P ∨ Q) ∧ (P ∨ R))   15,30 <->I
   QED

   DeMorgan's law (DM): ⊢  ￢(P ∧ Q) <-> (￢P ∨ ￢Q)
   Proof
   01.   |   ￢(P ∧ Q)                           H (for ->I)
   02.   |   |   ￢(￢P ∨ ￢Q)                   H (for ￢I)
   03.   |   |   |   ￢P                         H (for ￢I)
   04.   |   |   |   ￢P ∨ ￢Q                   3 ∨I
   05.   |   |   |   ⊥                           2,4 ⊥ I
   06.   |   |   ￢￢P                           3-5 ⊥ E
   07.   |   |   P                               6 ￢E
   08.   |   |   |   ￢Q                         H (for ￢I)
   09.   |   |   |   ￢P ∨ ￢Q                   8 ∨I
   10.   |   |   |   ⊥                           2,9 ⊥ I
   11.   |   |   ￢￢Q                           9-10 ⊥ E
   12.   |   |   Q                               11 ￢E
   13.   |   |   P ∧ Q                           7,12 ∧I
   14.   |   |   ⊥                               1,13 ⊥ I
   15.   |   ￢￢(￢P ∨ ￢Q)                     2-14 ⊥ E
   16.   |   ￢P ∨ ￢Q                           15 ￢E
   17.   ￢(P ∧ Q) -> (￢P ∨ ￢Q)                1-16 ->I
   18.   |   ￢P ∨ ￢Q                           H (for ->I)
   19.   |   |   P ∧ Q                           H (for ￢I)
   20.   |   |   P                               19 ∧E
   21.   |   |   Q                               19 ∧E
   22.   |   |   ￢￢P                           20 DN
   23.   |   |   ￢Q                             18,22 DS
   24.   |   |   ⊥                               21,23 ⊥ I
   25.   |   ￢(P ∧ Q)                           19-24 ⊥ E
   26.   (￢P ∨ ￢Q) -> ￢(P ∧ Q)                18-25 ->I
   27.   ￢(P ∧ Q) <-> (￢P ∨ ￢Q)               17,26 <->I
   QED

   DeMorgan's law (DM)  ⊢  ￢(P ∨ Q) <-> (￢P ∧ ￢Q)
   Proof
   01.   |   ￢(P ∨ Q)                           H (for ->I)
   02.   |   |   ￢(￢P ∧ ￢Q)                   H (for ￢I)
   03.   |   |   |   P                           H (for ￢I)
   04.   |   |   |   P ∨ Q                       3 ∨I
   05.   |   |   |   ⊥                           1,4 ⊥ I
   06.   |   |   ￢P                             3-5 ⊥ E
   07.   |   |   |   Q                           H (for ￢I)
   08.   |   |   |   P ∨ Q                       7 ∨I
   09.   |   |   |   ⊥                           1,8 ⊥ I
   10.   |   |   ￢Q                             7-9 ⊥ E
   11.   |   |   ￢P ∧ ￢Q                       6,10 ∧I
   12.   |   |   ⊥                               2,11 ⊥ I
   13.   |   ￢P ∧ ￢Q                           2-12 ⊥ E
   14.   ￢(P ∨ Q) -> (￢P ∧ ￢Q)                1-13 ->I
   15.   |   ￢P ∧ ￢Q                           H (for ->I)
   16.   |   |   P ∨ Q                           H (for ￢I)
   17.   |   |   ￢P                             15 ∧E
   18.   |   |   ￢Q                             15 ∧E
   19.   |   |   Q                               16,18 DS
   20.   |   |   ⊥                               18,19 ⊥ I
   21.   |   ￢(P ∨ Q)                           16-20 ⊥ E
   22.   (￢P ∧ ￢Q) -> ￢(P ∨ Q)                15-21 ->I
   23.   ￢(P ∨ Q) <-> (￢P ∧ ￢Q)               14,22 <->I
   QED

   Material Equivalence (ME):  ⊢  (P <-> Q) <-> ((P -> Q) ∧ (Q -> P))
   Proof
   01.   |   P <-> Q                             H (for ->I)
   02.   |   P -> Q                              1 <->E
   03.   |   Q -> P                              1 <->E
   04.   |   (P -> Q) ∧ (Q -> P)                 2,3 ∧I
   05.   (P <-> Q) -> ((P -> Q) ∧ (Q -> P))      1-4 ->I
   06.   |   (P -> Q) ∧ (Q -> P)                 H (for ->I)
   07.   |   P -> Q                              6 ∧E
   08.   |   Q -> P                              6 ∧E
   09.   |   P <-> Q                             7,8 <->I
   10.   ((P -> Q) ∧ (Q -> P)) -> (P <-> Q)      6-9 ->I
   11.   (P <-> Q) <-> ((P -> Q) ∧ (Q -> P))     5,10 <->I
   QED

   Material Equivalence (ME):  ⊢  (P <-> Q) <-> ((P ∧ Q) ∨ (￢P ∧ ￢Q))
   Proof
   01.   |   P <-> Q                             H (for ->I)
   02.   |   P -> Q                              1 <->E
   03.   |   Q -> P                              1 <->E
   04.   |   |   ￢((P ∧ Q) ∨ (￢P ∧ ￢Q))       H (for ￢I)
   05.   |   |   ￢(P ∧ Q) ∧ ￢(￢P ∧ ￢Q)       4 DM
   06.   |   |   ￢(P ∧ Q)                       5 ∧E
   07.   |   |   ￢(￢P ∧ ￢Q)                   5 ∧E
   08.   |   |   ￢P ∨ ￢Q                       6 DM
   09.   |   |   P ∨ Q                           7 DM
   10.   |   |   |   ￢P                         H (for ->I)
   11.   |   |   |   ￢Q                         2,10 MT
   12.   |   |   |   P                           9,10 DS
   13.   |   |   |   ⊥                           10,11 ⊥ I
   14.   |   |   ￢P -> ⊥                        10-13 ->I
   15.   |   |   |   ￢Q                         H (for ->I)
   16.   |   |   |   ￢P                         2,15 MT
   17.   |   |   |   P                           9,15 DS
   18.   |   |   |   ⊥                           16,17 ⊥ I
   19.   |   |   ￢Q -> ⊥                        15-18 ->I
   20.   |   |   ⊥                               8,14,19 ∨E
   21.   |   (P ∧ Q) ∨ (￢P ∧ ￢Q)               4-20 ⊥ E
   22.   (P <-> Q) -> ((P ∧ Q) ∨ (￢P ∧ ￢Q))    1-21 ->I
   23.   |   (P ∧ Q) ∨ (￢P ∧ ￢Q)               H (for ->I)
   24.   |   |   P ∧ Q                           H (for ->I)
   25.   |   |   |   P                           H (for ->I)
   26.   |   |   |   Q                           24 ∧E
   27.   |   |   P -> Q                          25-26 ->I
   28.   |   |   |   Q                           H (for ->I)
   29.   |   |   |   P                           24 ∧E
   30.   |   |   Q -> P                          28-29 ->I
   31.   |   |   P <-> Q                         27,30 <->I
   32.   |   (P ∧ Q) -> (P <-> Q)                24-31 ->I
   33.   |   |   ￢P ∧ ￢Q                       H (for ->I)
   34.   |   |   |   ￢P                         H (for ->I)
   35.   |   |   |   ￢Q                         33 ∧E
   36.   |   |   ￢P -> ￢Q                      34-35 ->I
   37.   |   |   Q -> P                          36 TRANS
   38.   |   |   |   ￢Q                         H (for ->I)
   39.   |   |   |   ￢P                         33 ∧E
   40.   |   |   ￢Q -> ￢P                      37-38 ->I
   41.   |   |   P -> Q                          40 TRANS
   42.   |   |   P <-> Q                         37,41 <->I
   43.   |   (￢P ∧ ￢Q) -> (P <-> Q)            33-42 ->I
   44.   ((P ∧ Q) ∨ (￢P ∧ ￢Q)) -> (P <-> Q)    23-44 ->I
   45.   (P <-> Q) <-> ((P ∧ Q) ∨ (￢P ∧ ￢Q))   22,44 <->I
   QED


====================
Predicate Logic
====================

Predicate logic is a way to analyze proposition symbols down into more
basic components.


--------
Language
--------

Lexemes
=======

   Non-Logical Symbols

      Object Symbols
         Constants:             a...t
      Predicate Symbols:        A...Z
      Association Symbols:      ( )

   Logical Symbols

      Truth-Function Symbols:   ￢, ∧ ∨ -> <->

Grammar
=======

   It's conventional to use capital Greek letters to stand for arbitrary
   wffs, and lower-case Greek letters to stand for arbitrary constant
   object symbols.

   An ATOMIC FORMULA consists of a Predicate symbol followed by zero
   or more constant object Symbols.

   Formation Rules for wffs
   1.  every atomic formula is a wff;
   2.  if Φ is a wff, then so is ￢Φ;
   3.  if Φ, Ψ are wffs, then so are (Φ ∧ Ψ), (Φ ∨ Ψ), (Φ -> Ψ), (Φ <-> Ψ);
   4.  Nothing else is a wff.

   Notes

   - In a dictionary we'll use letters from the end of the alphabet
     (x, y and z), as place holders for arbitrary object symbols
     within a dictionary.

   - Identical sequences of symbols that form single atomic formulas should
     be regarded as if they were the same proposition symbol, while different
     sequences should be regarded as different proposition symbols.


---------
Semantics
---------

Model
=====

   Very roughly, a MODEL is a limited representation of some state of affairs
   which is expressed using set theory.  Since a set theory model can be a
   mathematical representation of something about the actual world, we can for
   our current purposes, informally regard the actual world as our model.
  
The Dictionary
==============

   It's necessary to create a dictionary before constructing an atomic
   formula.  When we begin to investigate a new situation with logic
   we want to be clear in what the atomic formulas and their components
   mean.  A dictionary is a list of the symbols and what they denote
   in the current universe (of discourse).  By convention letters towards
   the end of the alphabet (u,v,w,x,y,z) may serve as placeholders which
   allow us to more clearly define a predicate's meaning.

Properties
----------

   A property asserts that some object is a member of some particular
   set which when combined denotes a characteristic of the object.

         Dictionary
         ----------------
         Object Symbols        1-Place Predicates
         a,   Alice            Bx,   x is blonde
         b,   Bob              Kx,   x is brunette
         c,   Charlie          Sx,   x is scaled

   By substituting one of the object symbols in place of a place-holder
   in a predicate definition, we construct an atomic formula.

         Ba,  Alice is blonde.
         Kb,  Bob is brunette.
         Sc,  Charlie is scaled.

         Sc -> ￢(Bc ∨ Kc)
         If Charlie is scaled then Charlie is neither blonde nor brunette.

   A properties always have just one place-holder in the dictionary.
   Any property Pc means, c is in set P, c is P, or c has property P.

Relations
---------

   Much as it sounds a relation denotes a relationship between two or more
   objects.  Let's expand the dictionary:

         2-Place Predicates
         Txy,  x is taller than y.

   'Tall', while a property, wouldn't be a very good predicate for logic
   because 'tall' is vague.  E.g. a tall building and a tall glass of water
   don't mean the same thing.  However, 'taller' is objective, making
   it ideal for logical reasoning.

         (Tab ∧ Tbc) -> Tac
         If Alice is taller than Bob and Bob is taller than Charlie,
            then Alice is taller than Charlie.

   Any predicate with more than 1-place expresses a relation.

         3-Place Predicates
         Bxyz,     x is between y and z

         Bbac,     Bob is between Alice and Charlie

         Bbac -> (￢Babc ∧ ￢Bcab)
         If Bob is between Alice and Charlie then, Alice isn't between Bob
         and Charlie and Charlie isn't between Alice and Bob.

   Any number of places is acceptable, including 0.  0-place predicates are
   just proposition symbols.

         0-Place Predicates
         R,        it's raining
         W,        the ground is wet

         R -> W
         If it's raining then the ground is wet.

Translation Hints
=================

              +-----------------------------------------------+             
              | ============================================= |
              | 0-Place Predicate (Proposition Symbols)       |
              | ============================================= |
              | S,    Zelda is at the store.                  |
              | C,    cake is delicious.                      |
              | R,    It's raining.                           |
              |                                               |
              | ============================================= |
              | 1-Place (Monadic) Predicates (Properties)     |
              | ============================================= |
              | Px,   x is P, x in set P                      |
              |                                               |
              | Ms,   Susy is a mammal.                       |
              | Dr,   Rex is a dog.                           |
              | Qp,   Palmer is quiet.                        |
              | En,   n is an even number.                    |
              |                                               |
              | ============================================= |
              | 2-Place (Diadic) Predicates (Relations)       |
              | ============================================= |
              | Pxy,  x,y are related through P               |
              |                                               |
              | Sta,  Tom sees Agatha.                        |
              | Tab,  Alice is taller than Bob.               |
              | Pac,  lines a and c are perpendicular.        |
              | Los,  one is less than six.                   |
              |                                               |
              | ============================================= |
              | 3-Place (Triadic) Predicates (Relations)      |
              | ============================================= |
              | Pxyz,  x,y,z are related through P            |
              |                                               |
              | Bxyz,  x is between y and z                   |
              | Pxyz,  x purchased y from z                   |
              | Stsb,  Tom saw Sally steal from Barbara.      |
              |                                               |
              +-----------------------------------------------+

Truth-Tables
============

   Truth-tables technically can be constructed for predicate logic.
   However, the number of atomic formulas gets very large very fast
   which makes tables impractical.

Truth-Trees
===========

   Truth trees are constructed according to the same rules as trees for
   propositional logic.


------------------
Predicate Calculus
------------------

   The calculus for constructing proofs in predicate logic is largely
   unmodified and from TFC.  The primary difference is in the definition
   of an atomic formula.

         Dictionary
         ----------
         Constants            Predicates
         g,    Gandalf        Axy,   x abandons y
         f,    Frodo
         s,    Sam

         Agf -> Ags, ￢Ags  ⊢  ￢Agf

   Here 'Agf' and 'Ags' are separate atomic formulas.


===========================
First-Order Predicate Logic
===========================

   FOL introduces new concepts which build upon predicate logic enabling
   the expression of, among other things, the Aristotelian proposition
   forms which denote relations among sets.

         A:  All P is Q.
         E:  No P is Q.
         I:  Some P is Q.
         O:  Some P is not Q.

   FOL brings in quantifiers, which denote quantities, and variable object
   symbols which denote arbitrary objects.


------------------
Regarding Notation
------------------

   In the current chapter there are some notations that you should
   be aware of.

   A capital Greek letter (Φ, Ψ, Θ, Δ, etc.) denotes any arbitrary formula,
   and a lower case Greek letter (α, β, δ, etc.) denotes any arbitrary
   object symbol.

   Φ(Ψ) indicates that a wff Φ contains one or more occurrences of
   a sub-wff Ψ.

   Φ(Θ/Ψ) indicates the result of replacing one or more occurrences
   of Ψ in Ψ with Θ.  Θ/Ψ is read, "Θ replaced one or more occurrences of Ψ".

   Φ (Θ//Ψ) like above but indicates replacing all occurrences of Ψ in Φ with
   Θ.  Θ//Ψ is read, "Θ replaced all occurrences of Ψ"

   Φ(β),Φ(α/β),Φ(α//β), similar to the above but α and β are object symbols.

   ( Φ ⊢ Ψ ), denotes a subproof with hypothesis Φ concluding with Ψ.

   [ ... ] indicates that the enclosed must exist, be defined or proved
   elsewhere.


--------
Language
--------

Lexemes
=======

   Non-Logical Symbols
      Object symbols
         constants:            a...t
         variables:            u...z
      Predicate Symbols:       A...Z
      Association Symbols:     (, )

   Logical Symbols
      Truth-Function Symbols:  ￢, ∧, ∨, ->, <->
      Quantifiers
         universal:            ∀
         existential:          ∃

Grammar
=======

   An ATOMIC FORMULA is a predicate symbol followed by zero or more
   constants.

   1.  Every atomic formula is a wff;
   2.  if Φ is a wff, then so is ￢Φ;
   3.  if Φ,Ψ are wffs, then so are (Φ ∧ Ψ), (Φ ∨ Ψ), (Φ -> Ψ), (Φ <-> Ψ);
   4.  if Φ(α) (α is a const object in a wff Ψ) is a wff,
       then ∀xΦ(x/α) and ∃xΦ(x/α) are wffs (where x is some new
       variable in Φ);
   5.  Nothing else is a wff.


---------
Semantics
---------

Predicates & Constants
======================

   Truth-functions, predicates and constants continue to work as presented.
   The one note, in consistency with predicate logic is that use of letters
   such as x,y,z within a dictionary are not variables but placeholders.

         Dictionary (where x,y,z are placeholders)
         -----------------------------------
         Px,    x has some property P, x in set P, x is P.
         Pxy,   x has some relation P to y
         Bxyz,  x has some relation P to y and z.

         Proof (where x,y,z are variables)
         01.   ∀x(Mx -> Vx)       A
         02.   Ma                 A
         03.   Ma -> Va           2 ∀ E (a/x)
         04.   Va                 3,4 ->E
         QED

Quantifiers & Variables
=======================

   A quantifier expression is a quantifier followed by a variable symbol
   and then a sub-wff.  The quantifier is said BIND the variable, or the
   variable is BOUND to the quantifier.

         ∀xΦ       For every object x in our universe of discourse,
                   Φ.holds.

         ∃xΦ       There exists at least one object x in our universe
                   of discourse such that, Φ holds.

   Once the variable is bound it can be used within the wff.  In our FOL
   implementation a variable in a wff is always bound provided formation
   rules are applied correctly.

         Dictionary
         ---------------------
         Predicates
         Cx,   x is a cat
         Dx,   x is a dog
         Mx,   x is a mammal
         Sx,   x likes to swim
         Lxy,  x loves y

         ∀xCx,     For each x in our universe, x is a cat.
                   = Everything is a cat.

         ∃xDx,     There exists x in our universe such that, x is a dog.
                   = Some (one or more) dogs exist.

   Existential Import

   ∃xΦ has existential import.  It asserts that at least one thing exists
   in the universe of discourse.

         ∃xSx      There exists some object in our universe that
                   likes to swim.

   ∀x lacks existential import.  It makes no claim that something actually
   exists in the universe of discourse.

         ∀xSx      Everything in our universe (if anything exists
                   at all) likes to swim.

   Scope

   SCOPE refers to the substring in a quantified wff over which the
   quantifier-variable binding holds.  In FOL this substring
   is the complete wff which follows the quantifier; if the expression
   that follows is in parentheses then the scope ranges from the opening
   to the matching closing parenthesis.

         ∀x(Dx -> Mx) ∧ ∃xRx

   In this expression the x bound by ∀ is in scope within between
   the pair of parentheses.  The x used with the atomic formula
   Rx is a different x which is bound by ∃ and whose scope is only
   the expression 'Rx'.

   Free Variables

   A FREE VARIABLE is a variable that appears within a wff but is not
   bound by a quantifier.  Our implementation of FOL doesn't have
   free variables provided the formation rules are applied correctly.
   However, some implementations do allow free variables.  Be aware that
   a free variable doesn't denote anything; while a variable bound
   by ∀ denotes *any* arbitrary object in our universe, and a variable
   bound by ∃ denotes at least one object in our universe though
   we may not know which.

Single Quantifiers
==================

   A universal quantifier is nearly always paired with the conditional.

         ∀x(Cx -> Mx),   For each object x in our universe,
                             if x is a cat then x is a mammal.
                         = all cats are mammals.

         ∀x(Cx -> ￢Sx),  For each object x in our universe,
                             if x is a cat then x doesn't like to swim.
                         = no cats like to swim.

   An existential quantifier is nearly always paired with conjunction.

         ∃x(Dx ∧ Mx),    There's at least one object x in our universe
                             such that, x is a dog and x is a mammal.
                         = Some dogs are mammals.

         ∃x(Dx ∧ Sx),    There's at least one object x in our universe
                             such that, x is a dog and x likes to swim.
                         = Some dogs like to swim.

   This notion of ∀ with ->, and ∃ with ∧, is further supported
   by occurrence of these forms negated.

         ￢∀x(Cx -> ￢Sx)  It's false that all cats don't like to swim.

   Applying some equivalences to this wff we should get a new formula
   that means the same thing.

         ∃x￢(Cx -> ￢Sx)    ￢∀ is equivalent to ∃￢ 
         ∃x￢(￢Cx ∨ ￢Sx)   By material implication
         ∃x(￢￢Cx ∧ ￢￢Sx) DeMorgans
         ∃x(Cx ∧ Sx)         Double Negation

   So the conclusion reads, some cats like to swim.  Notice that we
   started with ∀ ->, and ended with ∃ ∧.  So ∃ with ∧ follows naturally
   from the occurrence of ∀ with ->; they are complementary forms.

Multiple Quantifiers
====================

   Just as with many other features of FOL, quantifiers can be recursively
   combined.  When the same quantifier is repeated the order of the
   quantifiers doesn't change the meaning of the wff.

         ∀x∀yLxy         Everyone loves everyone including themselves.
         ∀y∀xLxy         Everyone loves everyone including themselves.

         ∃x∃yLxy         Someone loves someone (perhaps themselves).
         ∃y∃xLxy         Someone loves someone (perhaps themselves).

   In the first form ∀x has scope over the following formula which
   is ∀yLxy.  It's similarly the case with the remaining forms.  However,
   if the quantifiers are mixed the meaning changes depending upon order.

         ∃x∀yLxy         Someone loves everyone (including themselves).
         ∀x∃yLxy         Everyone loves someone (perhaps themselves).

Translation Hints
=================

   The Aristotelian Forms

   The Aristotelian forms under any interpretation can
   all be represented in FOL.

   The TRADITIONAL INTERPRETATION assigns existential import to all forms.
   The singular forms always denote particular objects in the universe
   and so always have existential import.

                                    Quality  
                     +----------------------+------------------------+
                     | Affirmatives         | Negatives              |
      Q +------------+----------------------+------------------------+
      u | Universal  | ∀x(Sx -> Px) ∧ ∃xSx  | ∀x(Sx -> ￢Px) ∧ ∃xSx  | < EI
      a |            |                      |                        |
      n | Particular | ∃x(Sx ∧ Px)          | ∃x(Sx ∧ ￢Px)          | < EI
      t +------------+----------------------+------------------------+
      i | Singular   | Sa                   | ￢Sa                   | < EI
      t |            | c=e                  | ￢c=e                  | < EI
      y +------------+----------------------+------------------------+

   The MODERN INTERPRETATION denies existential import to the universals.

                                    Quality  
                     +----------------------+------------------------+
                     | Affirmatives         | Negatives              |
      Q +------------+----------------------+------------------------+
      u | Universal  | ∀x(Sx -> Px)         | ∀x(Sx -> ￢Px)         |
      a |            |                      |                        |
      n | Particular | ∃x(Sx ∧ Px)          | ∃x(Sx ∧ ￢Px)          | < EI
      t +------------+----------------------+------------------------+
      i | Singular   | Sa                   | ￢Sa                   | < EI
      t |            | c=e                  | ￢c=e                  | < EI
      y +------------+----------------------+------------------------+

   An alternative interpretation might assign EI to the affirmatives.

                                    Quality  
                     +----------------------+------------------------+
                     | Affirmatives         | Negatives              |
      Q +------------+----------------------+------------------------+
      u | Universal  | ∀x(Sx -> Px) ∧ ExSx  | ∀x(Sx -> ￢Px)         |
      a |            |                      |                        |
      n | Particular | ∃x(Sx ∧ Px)          | ∃x(Sx ∧ ￢Px)          |
      t |            |                      |    ∨ ￢∃xSx v ￢∃xPx   |
      i +------------+----------------------+------------------------+
      t | Singular   | Sa                   | ￢Sa                   | < EI
      y |            | c=e                  | ￢c=e                  | < EI
        +------------+----------------------+------------------------+
                       ^^^^
                        EI

   Another interpretation might assign EI to the negatives.

                                    Quality  
                     +----------------------+------------------------+
                     | Affirmatives         | Negatives              |
      Q +------------+----------------------+------------------------+
      u | Universal  | ∀x(Sx -> Px)         | ∀x(Sx -> ￢Px) ∧ ExSx  |
      a |            |                      |                        |
      n | Particular | ∃x(Sx ∧ Px)          | ∃x(Sx ∧ ￢Px)          |
      t |            |    ∨ ￢∃xSx ∨ ￢∃xPx |                        |
      i +------------+----------------------+------------------------+
      t | Singular   | Sa                   | ￢Sa                   | < EI
      y |            | c=e                  | ￢c=e                  | < EI
        +------------+----------------------+------------------------+
                                             ^^^^
                                              EI

   It's even possible to assign EI to a diagonal pair and deny it to the other
   pair, or deny it to all universals and particulars.

   English Quantification

   When translating from English, it's usually best to first paraphrase
   a sentence such that it's closer in structure to a wff.

   Quantifier Placement (Default Rule)

         Write the quantifiers in the same order as they occur in English.
         Note that this rule has many exceptions.

   Any/Anybody/Anyone/Anything/Anywhere

   Any has different meanings depending upon how it's used.  It can indicate
   either quantifier.  Generally, try to rephrase the proposition
   so it doesn't use 'any'.

         Not any...   ->   No...
         If any...    ->   If some...
         Any ...      ->   All...

   In the remaining cases to translate 'any', put a ∀x at the beginning
   of the wff regardless of where 'any' occurs in the sentence.

Validity / Valid Formula
========================

   A VALIDITY or VALID FORMULA, like a tautology, is true in all cases,
   however the term is more broad.  Tautology only refers to something being
   true in all cases in virtue of truth-functions.  While 'validity' refers
   to all expressions of this nature.  The following is valid in FOL.

         ∀x￢Px  <->  ￢∃xPx,    where P is an arbitrary predicate.

Truth-Trees
===========

   Construction of Truth-trees in FOL is similar to how they are constructed
   in predicate logic the addition of a few extra rules for handling
   the quantifiers.

   ====  =====================================================================  
   Name  Rule
   ====  =====================================================================
   ∀     If ∀xΦ(x) appears on an open path, and α occurs in some wff on
         that path, write Φ(α//x) (the result of replacing each occurrence
         of x in Φ with α) at the bottom of the path.  If no wff containing
         α appears on the path, choose any α .

   ￢∀   If ￢∀xΦ(x) appears on an open path, star it and write ∃x￢Φ(x)
         at the bottom of every open path that contains the newly
         starred wff.

   ∃     If ∃xΦ(x) appears on an open path, star it.  Choose a constant α
         that doesn't appear on that path and write Φ(α//x) (the results of
         replacing each occurrence of x by α in Φ) at the bottom of every
         open path that contains the newly starred wff.

   ￢∃   If ￢∃xΦ(x) appears on an open path, star it and write ∀x￢Φ(x)
         at the bottom of every open path that contains the newly
         starred wff.
   ====  =====================================================================

   These rules are often described with diagrams instead of words.

            +--------------------------+--------------------------+
            | ======================== | ======================== |
            |          ∀Rule           |          ￢∀Rule         |
            | ======================== | ======================== |
            |          ∀xΦ(x)          |       * ￢∀xΦ(x)         |
            |         --------         |        ----------        |
            |          Φ(c/x)          |         ∃x￢Φ(x)         |
            |                          |                          |
            | if possible c is not new |                          |
            |                          |                          |
            | ======================== | ======================== |
            |          ∃Rule           |          ￢∃Rule         |
            | ======================== | ======================== |
            |       * ∃xΦ(x)           |       * ￢∃xΦ(x)         |
            |        ---------         |        -----------       |
            |         Φ(c//x)          |         ∀x:￢Φ(x)        |
            |                          |                          |
            |         c is new         |                          |
            |                          |                          |
            +--------------------------+--------------------------+

Truth-Tree Analysis
===================

   The rules for assessing completed trees are the same as those for TFL.

   Truth-Tree Assessment of a Single WFF

         =============   ============================   ==========
         condition       wff                            ￢wff
         =============   ============================   ==========
         0               inconsistent                   validity
         1+              consistent                     contingent
         2+              validity or contingency        contingent
         =============   ============================   ==========

   Truth-Tree Assessment of a set of WFFs

         =============   ============================
         condition       wff Set
         =============   ============================
         0               inconsistent
         1+              consistent
         =============   ============================

   Truth-Tree Assessment of a Sequent

         =============   ============================
         Condition       Premises & ￢Conclusion
         =============   ============================
         0  open paths   valid
         1+ open paths   Invalid w/ counterexamples
         =============   ============================

--------------------------------------------------
First-Order Predicate Calculus (FOC - Fitch Style)
--------------------------------------------------

Primitive Inference Rules
=========================

   Let α represent any constant symbol, and x represent any variable.
   A boxed constant [α] introduces a *new* constant into a subproof which
   subsequently goes out of scope when the subproof closes (just like
   a local variable in a computer program) meaning once the subproof
   is ended α is no longer accessible.

   ================================  =========================================
   Name/Alternate Names              Rule
   ================================  =========================================
   Universal Elimination (∀E)        From ∀xΦ infer Φ(α//x);
                                     where α is any constant object.

   Universal Introduction (∀I)       From a subproof with hypothesis [α] and
                                     ending Ψ(α), close the subproof and
                                     infer ∀xΨ(x//α); where α is new.
                                    
   Existential Elimination (∃E)      From ∃xΦ(x), and a subproof with
                                     hypothesis [α] Φ(α//x) and ending Ψ,
                                     close the subproof and infer Ψ;
                                     where α is new.  Ψ mustn't contain α.

   Existential Introduction (∃I)     From Φ(α), infer ∃xΦ(x/α)
   ================================  =========================================

   These rules can also be described in diagrams.

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  ∀E                           |  ∀I                           |
      | ============================= | ============================= |
      |   ∀xΦ                         |   |[α]     (new α)            |
      |  --------                     |   |   ...                     |
      |   Φ(α/x)  (any α)             |   |   Ψ(α)                    |
      |                               |  -----------                  |
      |                               |   ∀xΨ(x//α)                   |
      |                               |                               |
      | ============================= | ============================= |
      |  ∃E                           |  ∃I                           |
      | ============================= | ============================= |
      |   ∃xΦ(x)                      |   Φ(α)                        |
      |   |[α] Φ(α//x)  (new α)       |  ----------                   |
      |   |   ...                     |   ∃xΦ(x/α)                    |
      |   |   Ψ                       |                               |
      |  --------------               |                               |
      |   Ψ                           |                               |
      |                               |                               |
      +-------------------------------+-------------------------------+

Derived Inference Rules
=======================

   Once a sequent is proved it may be used as a new inference rule.  The
   following are important derived rules in FOC:

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Dual                              ⊢  ￢∀xΦ <-> ∃x￢Φ
                                     ⊢  ￢∃xΦ <-> ∀x￢Φ 
   ================================  =========================================

Proofs of Non-Consequence
=========================
@@@ Need to fill this in with examples too.


------------------------------------------
Proofs of Some Aristotelian Argument Forms
------------------------------------------

   All Q is R
   All P is Q
   ∴ All P is R

   ∀x(Qx -> Rx), ∀x(Px -> Qx)  ⊢  ∀x(Px -> Rx)
   Proof
   01.   ∀x(Qx -> Rx)             A
   02.   ∀x(Px -> Qx)             A
   03.   |[a]                     H (for ∀I)
   04.   |   |   Pa               H (for ->I)
   05.   |   |   Qa -> Ra         1 ∀E (a/x)
   06.   |   |   Pa -> Qa         2 ∀E (a/x)
   06.   |   |   Qa               4,6 ->E
   07.   |   |   Ra               5,7 ->E
   08.   |   Pa -> Ra             4-7 ->I
   09.   ∀x(Px -> Rx)             3-8 AI
   QED

   All P is Q
   ∴ Some P is Q

   ∀x(Px -> Qx)  ⊢  ∃x(Px ∧ Qx)
   Proof
   01.   ∀x(Px -> Qx)             A
   02.   |   ￢∃x(Px ∧ Qx)        H (for ->I)
   03.   |   ∀x￢(Px ∧ Qx)        2 Dual
   04.   |   ∀x(￢Px ∨ ￢Qx)      3 DM
   05.   |   ￢Pa ∨ ￢Qa          4 ∀E (a/x)
   06.   |   Pa -> Qa             1 ∀E (a/x)
   07.   |   ￢Pa ∨ Qa            6 MI
       A proof can't be found so the form is invalid.

   All P is Q
   some P exist
   ∴ Some P is Q

   ∀x(Px -> Qx), ∃xPx  ⊢  ∃x(Px ∧ Qx)
   Proof
   01.   ∀x(Px -> Qx)             A
   02.   ∃xPx                     A
   03.   |   ￢∃x(Px ∧ Qx)        H (for ￢I)
   04.   |   ∀x￢(Px ∧ Qx)        3 QE
   05.   |   ∀x(￢Px ∨ ￢Qx)      4 DM
   06.   |   |[a]Pa               H (for ∃E, 2, a/x)
   07.   |   |   Pa -> Qa         1 ∀E (a/x)
   08.   |   |   Qa               6,7 ->E
   09.   |   |   ￢Pa ∨ ￢Qa      5 ∀E (a/x)
   10.   |   |   ￢Pa             8,9 DS
   11.   |   |   ⊥                6,10 ⊥ I
   12.   |   ⊥                    2,6-11 ∃E
   13.   ￢￢∃x(Px ∧ Qx)          3-12 ⊥ E
   14.   ∃x(Px ∧ Qx)              13 ￢E
   QED


============================
Identity Logic (IL and FOL=)
============================

   Identity Logic is the logic of the identity predicate = defined in the
   context of FOL.  The logic of the combined system is called First-Order
   Predicate Logic with Identity (FOL=).


--------
Language
--------

Lexemes
=======

   Non-Logical Symbols
      Object symbols
         constants:            a...t
         variables:            u...z
      Predicate Symbols:       A...Z, =
      Association Symbols:     (, )

   Logical Symbols
      Truth-Function Symbols:  ￢, ∧, ∨, ->, <->
      Quantifiers
         universal:            ∀
         existential:          ∃

Grammar
=======

   An ATOMIC FORMULA is a predicate symbol followed by zero or more
   constants; or 'α=β' (where α,β are constants, and can be the same symbol).

   1.  Every atomic formula is a wff;
   2.  if Φ is a wff, then so is ￢Φ;
   3.  if Φ,Ψ are wffs, then so are (Φ ∧ Ψ), (Φ ∨ Ψ), (Φ -> Ψ), (Φ <-> Ψ);
   4.  if Φ(α) (α is some constant) is a wff, then ∀xΦ(x/α) and ∃xΦ(x/α)
       are wffs (where x is new to Φ).
   5.  Nothing else is a wff.


---------
Semantics
---------

   The identity predicate does just one thing:  asserts that two object
   symbols denote the same object; that the two symbols are like synonyms.

Translation Hints
=================

   Numerical Quantification

   One of the powers of identity is that it allows us to say things
   about the number of members in a set Φ without using numbers.  Recall
   |A| is the cardinality of a set A, which equals the number of members
   A contains.

           ========  ===============================================
           Quantity  Proposition
           ========  ===============================================
           |P| = 0   ￢∃xPx
           |P| = 1   ∃x∀y(Px <-> y=x)
           |P| = 2   ∃x∃y(￢x=y ∧ ∀z(Pz <-> (z=x ∨ z=y)))
           |P| = 3   ∃w∃x∃y(￢w=x ∧ ￢w=y ∧ ￢x=y ∧
                                  ∀z(Pz <-> (z=w ∨ z=x ∨ z=y)))
           --------  -----------------------------------------------
           |P| >= 1  ∃xPx
           |P| >= 2  ∃x∃y(￢x=y ∧ Px ∧ Py)
           |P| >= 3  ∃x∃y∃z(￢x=y ∧ ￢y=z ∧ ￢x=z ∧ Px ∧ Py ∧ Pz)
           --------  -----------------------------------------------
           |P| <= 1  ∃x∀y(Px -> y=x)
           |P| <= 2  ∃x∃y∀z(Pz -> (z=x ∨ z=y))
           |P| <= 3  ∃x∃y∃z∀w(Pw -> (w=x ∨ w=y ∨ x=z))
           ========  ===============================================


Properties of Relations
=======================

   The identity predicate enables further discussion into 2-place
   predicates (sometimes called binary relations).  Binary relations
   can have interesting properties which can be used to impart logical
   meanings upon those relations.  Understanding these relations can
   go a long way in teaching the student of logic how to translate
   sentences into FOL=.

      Let,
         R,        be any binary relation (predicate)
         x,y,z,    be any object symbols
         a,b,c,    be any constant symbols

    ================  ================================  =================
    Property          Characteristics                   Examples
    ================  ================================  =================
    Symmetric(R)      =df ∀x∀y(Rxy -> Ryx)              Sibling(x,y)
                                                        x=y

    Transitive(R)     =df ∀x∀y∀z((Rxy ∧ Ryz) -> Rxz)    x=y
                                                        a=b ∧ b=c -> a=c
                                                        Descendant(x,y)

    Reflexive(R)      =df ∀xRxx                         x=x
                                                        SameHeight(x,y)

    Asymmetric(R)     =df ∀x∀y(Rxy -> ￢Ryx)             x<y
                                                         Child(x,y)

    Antisymmetric(R)  =df ∀x∀y((Rxy ∧ Ryx) -> x=y)       x>=y


    Nonsymmetric(R)   =df ￢( Symmetric(R) ∨             Brother(bob,kim)
                              Asymmetric(R) ∨
                              Antisymmetric(R) )

    Intransitive(R)   =df ∀x∀y∀z((Rxy ∧ Rxz) -> ￢Rxz)   OppositeSide(x,y)

    Nontransitive(R)  =df ￢( Transitive(R) ∨            ChildOf(x,y)
                              Intransitive(R) )

    Irreflexive(R)    =df ∀x￢Rxx                        x<y
                                                         Left(x,y)

    nonreflexive(R)   =df ￢( Reflexive(R) ∨
                              Irreflexive(R) )

    Equivalent(R)     =df Reflexive(R) ∧                Congruent(x,y)
                          Symmetric(R) ∧
                          Transitive(R)
    ================  ================================  =================

Truth Trees
===========

   Truth trees in FOL= are nearly identical to those in FOL; identity
   is just a predicate though with some special standing in FOL=.  Therefore,
   we introduce two new tree rules.

   ====  =====================================================================  
   Name  Rule
   ====  =====================================================================
   =     If α=β appears on an open path along with either Φ(α) or Φ(β)
         unstarred, write at the bottom of the path any wff not already
         on the path which is the result of replacing one of more occurrences
         of either of these name letters by the other in Φ. Do not check
         either α=β or Φ.

   ￢=   Close any path on which ￢α=α occurs.
   ====  =====================================================================

   These rules are often described with diagrams instead of words.

            +--------------------------+--------------------------+
            | ======================== | ======================== |
            |          =Rule           |         ￢=Rule          |
            | ======================== | ======================== |
            |       α=β       α=β      |          ￢α=α           |
            |       Φ(α)      Φ(β)     |         --------         |
            |      --------  --------  |          ⊥               |
            |       Φ(β/α)    Φ(α/β)   |                          |
            |                          |                          |
            +--------------------------+--------------------------+


------------------------------------
Identity Calculus (IC - Fitch Style)
------------------------------------

   Identity Calculus combined with FOC is called FOC=.

Primitive Inference Rules
=========================

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Identity Elimination (=E)         From α=β or β=α, and P(α), infer P(β/α).

   Identity Introduction (=I)        Introduce α=α (for any constant α)
                                     as a new line in the proof.
   ================================  =========================================

   These rules can also be described in diagrams.

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  =E                           |  =I                           |
      | ============================= | ============================= |
      |   α=β                         |                               |
      |   Φ(α)                        |  -----                        |
      |  --------                     |   α=α     α is any constant   |
      |   Φ(β/α)                      |                               |
      |                               |                               |
      +-------------------------------+-------------------------------+


----------------------
Philosophical Concerns
----------------------

Identity Peculiarity
====================

   FOL= classifies the following as wffs though they're nonsensical:

         ∀x￢x=α
         ￢∀xx=x

   Their existential duals are just as problematic.

         ￢∃xx=x
         ∃x￢x=x


===================
Function Logic (FL)
===================

   Function logic, constructed upon FOL=, provides a new way to analyze atomic
   formulas by adding more expression.  FL however, doesn't add any new power
   to the logic, it just adds new ways to say things FOL= can already say.
   It assigns valid/invalid to all the same forms.  For this reason when
   working with functions we're still in FOL=.


--------
Language
--------

Lexemes
=======

   Non-Logical Symbols
      Object symbols
         constants:            a...t
         variables:            u...z
         functions:            a(x)...z(x)
      Predicate Symbols:       A...Z, =
      Association Symbols:     (, )

   Logical Symbols
      Truth-Function Symbols:  ￢, ∧, ∨, ->, <->
      Quantifiers
         universal:            ∀
         existential:          ∃

Grammar (Formation Rules)
=========================

   An ATOMIC FORMULA is a predicate symbol followed by zero or more constants;
   or 'α=β' (where α,β are any constants; and could be the same constant).
   In addition to a constant object symbol, a function symbol with a
   constant argument is also a constant object symbol since functions are just
   objects.  Functions can also be composed (take functions as arguments).

   1.  Every atomic formula is a wff;
   2.  if Φ is a wff, then so is ￢Φ;
   3.  if Φ,Ψ are wffs, then so are (Φ ∧ Ψ), (Φ ∨ Ψ), (Φ -> Ψ), (Φ <-> Ψ);
   4.  if Φ(α) (α a is some constant) is a wff, then ∀xΦ(x/α) and ∃xΦ(x/α)
       are wffs (where x is new to Φ).
   5.  Nothing else is a wff.


---------
Semantics
---------

Function Symbol Denotation
==========================

   A FUNCTION maps one set (called a DOMAIN SET) of objects onto another
   set (called a RANGE SET) of objects; each domain set object is mapped
   to exactly one range set object though multiple domain objects can map
   to the same range object.  For any function expression f(x), we read
   it as "f of x." There are various ways to define function mappings but
   for FOL= often it's necessary to just list all the mappings along with
   the other propositions describing the state of affairs.

         Domain Set          Range Set
         +---------+         +---------+
         |         |    f    |         |
         |    a ---+---------+--> r    |
         |         |         |         |
         |    b ----------------> s    |
         |         |         |         |
         |    c ---+---------+--> t    |
         |         |         |   /     |
         |    d ---+---------+--/      |
         |         |         |         |
         |         |         |    u    |   (u has no mapping to it)
         |         |         |         |
         +---------+         +---------+

   In the diagram each domain object maps to just one range object.  However,
   two domain objects c and d map to the same range object.  The following
   denotes the state of affairs in the diagram.

         Dictionary
         ----------------------------------------
         Object Symbols     Function Symbols
         a,    Alice        f(x), the father of x
         b,    Bob
         c,    Charlie
         d,    Donna
         r,    Rob
         s,    Steve
         t,    Tom
         u,    Uden

         State of Affairs in Universe
         -------------------------------------------
         f(a) = r   or   f = { <a,r>,
         f(b) = s              <b,s>,
         f(c) = t              <c,t>,
         f(d) = t              <d,t> }

   Charlie and Donna have the same father so they're siblings so,
   f(d) = f(c) = r.  FOL= functions are general functions as in algebra
   and calculus.  They aren't required to conform to a more limited
   definition such as being one-to-one.

Inverse Functions
=================

   An INVERSE FUNCTION is a function that reverses the mapping of another
   function; a function must be bijective to have an inverse.  If our
   universe is the set of all integers, the successor s(x) function always
   denotes the integer *after* x, and is bijective.  So, its inverse
   function is predecessor p(x) which of course denotes the integer
   *before* x.

   Our father function f(x) tempts one to define an inverse function
   child c(x).  However, this isn't possible because some people like Uden
   don't have any children, while others like Tom have more than one.  It
   might also be tempting to challenge this requirement by just having c(x)
   return a set of objects containing the children of the argument x.
   But the requirement is that a function maps an object to one object.
   So c(x) can't be a function.  Note that is that while functions have these
   restriction, there's nothing preventing anyone from defining a relation
   like Cxy, "x is a child of y" so 'Cct' and 'Cdt' are perfectly good
   predicates.

Variable Function Arguments
===========================
   
   A function with a constant object argument always denotes the object that
   the function maps the argument to, making the string of symbols denoting
   use of a function itself a constant object symbol.  Each of the
   following is a constant object symbol.

         f(a), the father of Alice.
         f(b), the father of Bob.       
         f(c), the father of Charlie.
         f(d), the father of Donna.

   However, when a variable is the argument to a function, the function
   doesn't denote an object; not until the variable is replaced with
   a constant object symbol.  But functions with variable arguments
   can still contribute semantically to general assertions.

         Dictionary
         -------------------------------------------------
         Predicates                Functions
         Px,    x is a person.     f(x),  the father of x.

         ∀x( Px -> ∃yy=f(x) )  Everyone has a father.

Functions in WFFs
=================

   A function is just another way to denote objects, and so can occur
   anywhere object symbols can occur.  All of the following expressions
   are well formed.

         a=c,        a and c denote the same object.
         m(s)=g,     the mother of Susan is Gloria; Susan's mother is Gloria.
         m=s(n),     m is the successor of integer n.
         a(r)=v,     the address of my residence is v.

         Mx,         x is a millionaire.
         Mf(m)       my father is a millionaire.
         Txy,        x is taller than y.
         Tf(y)f(m),  your father is taller than my father.

         ∀x∀y( Txy       -> ￢Tyx       )
         ∀x∀y( Tf(x)f(y) -> ￢Tf(y)f(x) )

Translation Hints
=================

   Simple Functions

         l(x),     the length of x.
         l(p),     the length of the pool.
         h(x),     the home planet of x.
         h(e),     the home planet of E.T..

   Composed Functions

         m(x),     the mother of x.
         m(m(x)),  the mother of the mother of x.  (x's grandmother)

         0,        zero
         s(0),     1 (the successor of zero).
         s(s(0)),  2
         s(s(n)),  n + 2

   Non-Functions

         None of the following is a function, because none is guaranteed to
         always map any object to exactly one object.

         d(m),     the daughters of Mike.
         b(x),     the brothers of x.
         s(h),     the shingles of my house.


----------------------
Function Calculus (FC)
----------------------

   All the inference rules of FOC= are valid in Function Logic.  Function
   calculus doesn't add any new inference rules, since functions only add
   a new way to name existing objects.  Thus, functions don't require the
   addition of new inference rules.  However, they do allow us to analyze
   sentences in a new way.  In these ways FL is analogous to predicate logic.

Functions in Proofs
===================

   Any constant function can be used within the body of a proof anywhere
   that constant object symbols can.  For example, such a function can
   be the replacement value for a variable x in applying ∀E.

         Dictionary
         --------------------------
         Predicates
         Mx,    x is a mammal
         Vx,    x is a vertebrate

         Functions
         f(x),  the father of x


         i.   ∀x(Mx -> Vx)
              ...
         j.   Mf(e) -> Vf(e)        i ∀E (f(e)/x)

   alternatively, the function might already be in the wff with a
   variable argument.

         i.   ∀x:(Mf(x) -> Vf(x))
              ...
         j.   Mf(c) -> Vf(c)        i ∀E (c/x)


====================
Definite Descriptors
====================

   In his *The Principles of Mathematics* Bertrand Russell introduced a
   concept called a Definite Descriptor.  A definite descriptor, is
   any noun phrase of the form "the x such that Px" which he wrote as
   as ℩xPx (℩ is an inverted Greek lower case letter iota).  Like functions,
   descriptors don't add anything new to FOL=; the FOL= concepts covered
   so far can already say the same thing.

         B(℩xPx)    =df    ∃x(∀y(Py <-> y=x) ∧ Bx)
                    =df    ∃x(Ax ∧ ∀y(Ay -> y=x) ∧ Bx)

         B(℩xKx), the king of France is bald.
                  the x such that x is the king of France is Bald
         =∃x(Kx ∧ ∀y(Ky -> y=x) ∧ Bx)



====================================
Second-Order Quantified Logic (SOL=)
====================================

   Second order logic adds new quantifiers and new variables that reign
   over predicates.

         ∀x∃VVx    Every object has some (1 or more) property.


--------
Language
--------

Lexemes
=======

   Non-Logical Symbols
      Object symbols
         constants:            a...t
         variables:            u...z
         functions:            a(x)...z(x)
      Predicate Symbols
         constants:            A...T, =
         variables:            U...Z
      Association Symbols:     (, )

   Logical Symbols
      Truth-Function Symbols:  ￢, ∧, ∨, ->, <->
      Quantifiers
         universal:            ∀
         existential:          ∃

Grammar
=======

   An ATOMIC FORMULA is a constant predicate symbol followed by zero or more
   constant object symbols; or 'α=β' (where α,β are constant object symbols;
   and could be the same symbol).  A constant object; may also consist of a
   function symbol with some constant objects in the parentheses since
   constant functions are just constant objects.  Functions can also be
   composed (take functions as arguments).

   1.  Every atomic formula is a wff;
   2.  if Φ is a wff, then so is ￢Φ;
   3.  if Φ,Ψ are wffs, then so are (Φ ∧ Ψ), (Φ ∨ Ψ), (Φ -> Ψ), (Φ <-> Ψ);
   4.  if Φ(α) (α a is some constant object symbol) is a wff,
       then ∀xΦ(x/α) and ∃xΦ(x/α) are wffs (where x is new to Φ).
   5.  if Φ(Ψ) (Φ,Ψ are constant predicates) is a wff, then ∀VΦ(V/Ψ) and
       ∃VΦ(V/Ψ) are wffs where V is a variable predicate symbol and
       V is new to Φ.
   6.  Nothing else is a wff.


---------
Semantics
---------

   The quantifiers of FOL are here OVERLOADED, redefined so that they
   still accept additional kinds of arguments.  In this case they're
   overloaded to accept variable object symbols as their first argument
   and they accept variable predicate symbols.  They are read the same
   way and mean nearly the same as their FOL counterparts.  The variable
   predicates are capital letters at the end of the alphabet (U,V,W,X,Y,Z)
   which signals to the reader that the quantifier and variable reign over
   arbitrary predicates as opposed to objects.

         ∀VVc,     c has every property.
         ∃VVc,     c has at least one property.

         ∀x∃VVx,   Everything has at least one property.
         ∃V∀xVx,   There are some properties that everything has.
         ∀V∃xVx,   For all properties there exist some who have them.
         ∃x∀VVx,   Some have all properties


---------------------------
Second-Order Calculus (SOC)
---------------------------

   The four quantifier inference rules from FOL are expanded to these
   two new quantifiers in more-or-less the same way as they are used
   for variable object symbols.  However, variable types must not
   be mixed.  If a quantifier reigns over a predicate variable it must
   only be replaced by a predicate constant, and if a quantifier reigns
   over an object it must only be replaced by a constant object.


----------------------
Philosophical Concerns
----------------------

   The most important concern is that SOC is not semantically complete.
   That is, we are not guaranteed to be able to find a proof for a conclusion
   form that does actually follow from a set of premises.  A conclusion
   may *actually be* a consequence of some premises and yet there is no
   proof that gets us from the premises to the conclusion.  However, SOC
   is still sound.  There's no way to derive a proof to a formula that
   doesn't follow from the premises.  So, SOL can still be useful.


======================
Mathematical Induction
======================

   Mathematical induction is used to prove that all members of an infinite
   enumerable set have some property P.  Such an argument has two parts,
   an inductive definition that enumerates all members of the set we're
   reasoning about; and an inductive inference which proves that all members
   have a property P.

Inductive Definitions
=====================

   INDUCTIVE DEFINITIONS describe how to enumerate all members of a set.
   They are constructed recursively consisting of three types of numbered
   clauses.  The first clause is the BASE CLAUSE.  It identifies the most
   basic elements of the set and is non-recursive.  The FINAL CLAUSE states
   that if something isn't in accordance with the prior clauses then it's not
   a member of the set and is also non-recursive.  The INDUCTIVE CLAUSES
   (intermediate clauses) tell us how to *recursively* generate all non-base
   case elements of the set.

   The formation rules for all of the classical logics are examples
   of inductive definitions.  Here are the formation rules for
   propositional logic.

         1.   Every atomic formula is a wff.
         2.   If P is a wff, then so is ￢P.
         3.   If P,Q are wffs, then so are
              (P ∧ Q), (P ∨ Q), (P -> Q), (P <-> Q)
         4.   Nothing else is a wff.

   Clause 1 establishes our base case: any atomic formula is a wff.

   Clause 4 our final clause excludes anything that's not enumerated
   by the full definition.

   Clauses 2 & 3 tell us how to generate all the intermediate members
   of the set.

   There are a few sets for which we don't need an inductive definition.
   For example, the inductive proof alone is often all we need to reason
   about integers.

Zero and The Successor Function
===============================

   Mathematical induction introduces a new constant object symbol 0 which
   denotes the number zero; it also introduces the SUCCESSOR function s;
   the number that comes after its argument.  Because the successor function
   is often composed with itself many times it's common to omit
   the parentheses.

         s0     =  s(0)       = the successor of 0  = 1
         ss0    =  s(s(0))    = 2
         sss0   =  s(s(s(0))) = 3
         ...

Inductive Inference
===================

   Mathematical induction is used to construct a proof that all members
   of the set enumerated by the inductive definition have some property P.
   Once we have the definition an INDUCTIVE INFERENCE proceeds in two
   steps.  The BASE case, and the inductive case.  The BASE CASE of the
   proof requires that we prove that members denoted by the base clause
   of the inductive definition have property P.  The INDUCTIVE CASE
   is a hypothetical proof.  The method is to prove the conditional that
   for any x in our set, if x has the property P, then the successor
   of x also has property P.

   Mathematical Induction can be expressed over the natural numbers as an
   axiom in second-order logic, an axiom schema in first-order logic,
   or an inference rule in first-order logic.  All of the following are
   different ways to express the same thing.

         2nd-order axiom             ∀P((P0 ∧ ∀x(Px -> Psx)) -> ∀xPx)

         1st-order axiom schema      (P0 ∧ ∀x(Px -> Psx)) -> ∀xPx

         1st-order Inference Rule    from P0 and ∀x(Px -> Psx), infer ∀xPx


===============================
Axiomatic and Natural Deduction
===============================

The Fitch-style calculi presented thus far are known as NATURAL DEDUCTION
systems, which consist only of inference rules.  These systems are called
'natural' because they are more intuitive and more closely resemble how one
reasons informally.  An AXIOMATIC DEDUCTION system, in contrast, consists
of a minimal set of inference rules, often just one, and one or more
axiom schemata.  All instances of the schemata are axioms of the logic.
Axiomatic deduction systems are usually simpler than Fitch in that they have
fewer parts, but they are also more complicated and cumbersome to use and
quite dissimilar to how one reasons informally.  Given all this, the one
important similarity is that both kinds of systems count the same
forms as valid.

       +--------------------------------------------------------------+
       | ============================================================ |
       | Axiomatic Propositional Logic & Calculus                     |
       | ============================================================ |
       |                                                              |
       | Lexemes                                                      |
       |    Non-Logical Symbols                                       |
       |       Proposition Symbols:      A...Z                        |
       |       Association Symbols:      (, )                         |
       |                                                              |
       |    Logical Symbols                                           |
       |       Truth-Function Symbols:   ￢, ->                       |
       |                                                              |
       | Grammar                                                      |
       |                                                              |
       |    An ATOMIC FORMULA is any single proposition symbol.       |
       |                                                              |
       |    1.  Every atomic formula is a wff;                        |
       |    2.  if Φ is a wff, then ￢Φ is a wff;                     |
       |    3.  if Φ ,Ψ is wffs, then so is (Φ -> Ψ);                 |
       |    4.  nothing else is a wff.                                |
       |                                                              |
       | Definitions                                                  |
       |                                                              |
       |    (P ∧ Q)     =df  ￢(P -> ￢Q)                             |
       |    (P ∨ Q)     =df  ￢P -> Q                                 |
       |    (P <-> Q)   =df  ((P -> Q) ∧ (Q -> P))                    |
       |                                                              |
       | Inference Rule                                               |
       |                                                              |
       |    Given Φ -> Ψ, and Φ infer Ψ.                              |
       |                                                              |
       | Axiom Schemata                                               |
       |                                                              |
       |    AxS1.  P -> (Q -> P)                                      |
       |    AxS2.  (P -> (Q -> R)) -> ((P -> Q) -> (P -> R))          |
       |    AxS3.  (-P -> ￢Q) -> ((-P -> Q) -> P)                    |
       |                                                              |
       |    Every instance of these schemata is an axiom              |
       |    of the calculus.                                          |
       |                                                              |
       +--------------------------------------------------------------+


===============
Formal Theories
===============

   A SYSTEM is a set of object, properties and relationships; while A MODEL
   is a limited representation of a system.  A THEORY is all the true
   propositions that can be said about a model.

   Since any interesting theory has a large number (usually infinite number)
   of propositions, it would clearly be impractical to uncover all those
   truths.  The way we attempt to tackle this problem is with a set of first
   principles we can reason about to uncover the rest of the theory.  In this
   way the first principles combined with logical reasoning we say GENERATES
   theorems.  It's easy to construct a theory that OVER GENERATES, proves too
   many things, ie. theorems that aren't actually true of the model; or UNDER
   GENERATES, doesn't prove all of the things that there are to say about
   the model.

   The FIRST PRINCIPLES of a theory are those things from which the rest
   of the theory may be derived; they include but may not be limited to
   inference rules, axioms and definitions.

   An AXIOM is a proposition within a theory that describes the logical
   relationships between the various concepts of the theory (usually
   predicates and objects).  Many axioms follow some of the schema listed
   under Properties of Relations in the chapter on Identity Logic.

   POSTULATE is a synonym for axiom; another synonym is LAW.  Some theorists
   uses these terms as categories as a way to group different kinds of axioms,
   others pick just one of the terms to use.  However from the perspective
   of logic they are all the same thing.  Postulate, law and axiom all mean
   the same thing.

   A SCHEMA (plural is SCHEMATA) is a general statement about definitions
   or axioms which contain placeholders and whose substitution instances
   are actual definitions or axioms.

   A THEOREM is any proposition derived only from a theory's first
   principles or other theorems, via reasoning.  Theorems are propositions
   that are true in all cases.  So an argument with premises is not a theorem
   in logic, since it depends upon things other than the first principals for
   its validity.

   A THEORY is the plural of theorem; a theory consists of the combined
   set of first principles plus all the theorems (whether proved or not).

   A LEMMA is a theorem that has no use other than to serve
   as an intermediate step in the proof of another theorem.  The purpose
   of the lemma is to make the proof of an otherwise long theorem shorter.
   Proving lemmas before proving a theorem is a divide and conquer approach
   to proving the intended theorem.

   A COROLLARY is a theorem that "follows easily" from a first principle
   or other theorem; ie. the corollary is only a few reasoning steps away
   from what it's claimed to follow from.

   A CONJECTURE is any proposition which cannot be proved as a theorem in any
   known theory but is still taken as a principle due to its usefulness.
   The well known Occam's razor is sometimes called as a conjecture.  Einstein
   took Galileo's equivalence principal, a conjecture, and raised it up to an
   axiom of his own theory of relativity.


==================
Taller-Than Theory
==================

   Predicates

         Txy,  x is taller than y.

   Axioms

         Ax1.  ∀x∀y(Txy -> ￢Tyx)                 T is Asymmetric
         Ax2.  ∀x∀y∀z((Txy ∧ Tyz) -> Txz)         T is Transitive
         Ax3.  ∀x∀y(Txy -> ∃z(Txz ∧ Tzy))         T is Dense


=================
Formal Arithmetic
=================

Formal arithmetic is a theory about arithmetic of whole numbers (non neg
integers).

   Dictionary
         0,    constant object symbol zero.
         sx,   function, the successor of x.
         +     to signify addition
         *     to signify multiplication.

   Axioms
         A1.   ∀x￢0=sx
         A2.   ∀x∀y(sx=sy -> x=y)
         A3.   ∀x(x+0)=x
         A4.   Ax∀y(x+sy)=s(x+y)
         A5.   ∀x(x*0)=0
         A6.   ∀x∀y(x*sy)=((x*y)+x)

   Mathematical Induction Axiom
      MI.   ∀P((P0 ∧ ∀x(Px -> Psx)) -> ∀xPx)


=====================================
Appendix A: Combined Logic & Calculus
=====================================

------------------
Regarding Notation
------------------

   The following notations are used in the formal descriptions that follow.

   A capital Greek letter (Φ, Ψ, Θ, Δ, etc.) denotes any arbitrary formula,
   and a lower case Greek letter (α, β, δ, etc.) denotes any arbitrary
   object symbol.

   Φ(Ψ) indicates that a wff Φ contains one or more occurrences of
   a sub-wff Ψ.

   Φ(Θ/Ψ) indicates the result of replacing one or more occurrences
   of Ψ in Ψ with Θ.  Θ/Ψ is read, "Θ replaced one or more occurrences of Ψ".

   Φ (Θ//Ψ) like above but indicates replacing all occurrences of Ψ in Φ with
   Θ.  Θ//Ψ is read, "Θ replaced all occurrences of Ψ"

   Φ(β),Φ(α/β),Φ(α//β), similar to the above but α and β are object symbols.

   ( Φ ⊢ Ψ ), denotes a subproof with hypothesis Φ concluding with Ψ.

   [ ... ] indicates that the enclosed must exist, be defined or proved
   elsewhere.

Lexemes
=======

   Non-Logical Symbols
      Object symbols
         constants:            a...t
         variables:            u...z
         functions:            a(x)...z(x)
      Predicate Symbols
         constants:            A...T, =
         variables:            U...Z
      Association Symbols:     (, )


   Logical Symbols
      Truth-Function Symbols:  ￢, ∧, ∨, ->, <->
      Quantifiers
         universal:            ∀
         existential:          ∃

Grammar
=======

Formation Rules
---------------

   An ATOMIC FORMULA is a constant spredicate symbol followed by zero or more
   constants; or 'α=β' (where α,β are consts; and could be the same symbol).
   A constant; may also consist of a function symbol with some constant
   in the parentheses since constant functions are just constant objects.
   Functions can also be composed (take functions as arguments).

   1.  Every atomic formula is a wff;
   2.  if Φ is a wff, then so is ￢Φ;
   3.  if Φ,Ψ are wffs, then so are (Φ ∧ Ψ), (Φ ∨ Ψ), (Φ -> Ψ), (Φ <-> Ψ);
   4.  if Φ(α) (α a is some constant object symbol) is a wff,
       then ∀xΦ(x/α) and ∃xΦ(x/α) are wffs (where x is new to Φ).
   5.  if Φ(Ψ) (Φ,Ψ are const predicates) is a wff, then ∀VΦ(V/Ψ) and
       ∃VΦ(V/Ψ) are wffs where V is a variable predicate symbol and
       V is new to Φ.
   6.  Nothing else is a wff.

Definitions
-----------

   Definition Schema

         ⊥  =df  (P ∧ ￢P)

Primitive Inference Rules
=========================

   ================================  =========================================
   Name (Abbreviation)               Rule
   ================================  =========================================
   Assumption (A)                    Introduce a premise at any step.

   Hypothesis (H)                    Introduce a hypothesis at any step
                                     provided it begins a new subproof.

   Axiom (Ax)                        Introduce an axiom at any step.

   Negation Elimination (￢E)        From ￢￢Φ, infer Φ.

   Negation Introduction (￢I)       From a subproof with hypothesis Φ
      Reductio ad absurdum (RAA)     ending in (Ψ ∧ ￢Ψ), close the subproof,
      Proof by Contradiction (PBC)   and infer ￢Φ.
      Indirect Proof (IP)

   Conjunction Elimination (∧E)      From Φ ∧ Ψ, infer Φ, or infer Ψ.
      Simplification (Simp)

   Conjunction (∧I)                  From Φ and Ψ, infer Φ ∧ Ψ,
                                     or infer Ψ ∧ Φ.

   Disjunction Elimination (∨E)      From Φ ∨ Ψ, Φ -> Θ and Ψ -> Θ, infer Θ.
      Proof by Cases (PBC)

   Disjunction Introduction (∨I)     From Φ, infer Φ ∨ Ψ, or infer Ψ ∨ Φ.
      Addition (Add)

   Conditional Elimination (->E)     From Φ -> Ψ and Φ, infer Ψ.
      Modus Ponens (MP)

   Conditional Introduction (->I)    From a subproof with hypothesis Φ
      Conditional Proof (CP)         and ending Ψ, close the subproof,
                                     and infer Ψ -> Φ.

   Biconditional Elimination (<->E)  From Φ <-> Ψ, infer Φ -> Ψ,
                                     or infer Ψ -> Φ.

   Biconditional Introduction (<->I) From Φ -> Ψ and Ψ -> Φ, infer Φ <-> Ψ

   Equivalence Substitution (EQ)     From [ Φ <-> Ψ ], and Θ(Φ), infer Θ(Ψ/Φ);
                                     or from [ Φ <-> Ψ ] and Θ(Ψ),
                                     infer Θ(Φ/Ψ).

   --------------------------------  -----------------------------------------

   Definition Substitution (DEF)     From [ Φ =df Ψ ], Θ(Φ), infer Θ(Ψ/Φ);
                                     and [ Φ =df Ψ ], Θ(Ψ), infer Θ(Φ/Ψ).

   --------------------------------  -----------------------------------------

   Universal Elimination (∀E)        From ∀xP infer P(α//x);
                                     where α is any constant object.

   Universal Introduction (∀I)       From a subproof with hypothesis [α] and
                                     ending Ψ(α), close the subproof and
                                     infer ∀xΨ(x//α); where α is new.
                                    
   Existential Elimination (∃E)      From ∃xΦ(x), and a subproof with
                                     hypothesis [α] Φ(α//x) and ending Ψ,
                                     close the subproof and infer Ψ;
                                     where α is new.  Ψ mustn't contain α.

   Existential Introduction (∃I)     From Φ(α), infer ∃xΦ(x/α)

   --------------------------------  -----------------------------------------

   Identity Elimination (=E)         From α=β, and Φ(α) infer Φ(β/α).

   Identity Introduction (=I)        Introduce α=α (for any constant α)
                                     as a new line in the proof.

   --------------------------------  -----------------------------------------

   Mathematical Induction (MInd)     from P0 and ∀x(Px -> Psx), infer ∀xPx
   ================================  =========================================

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  A                            |  H                            |
      | ============================= | ============================= |
      |                               |                               |
      |  ---                          |  -------                      |
      |   Φ   (Φ is a premise)        |   |   Φ   (Φ is a hypothesis) |
      |                               |                               |
      | ============================= | ============================= |
      |  ￢E                          |  ￢I                          |
      | ============================= | ============================= |
      |   ￢￢Φ                       |   |   Φ                       |
      |  -------                      |   |   ...                     |
      |   Φ                           |   |   Ψ ∧ ￢Ψ                 |
      |                               |  --------------               |
      |                               |   ￢Φ                         |
      |                               |                               |
      | ============================= | ============================= |
      |  ∧E                           |  ∧I                           |
      | ============================= | ============================= |
      |   Φ ∧ Ψ    Φ ∧ Ψ              |   Φ        Φ                  |
      |  -------  -------             |   Ψ        Ψ                  |
      |   Φ        Ψ                  |  -------  -------             |
      |                               |   Φ ∧ Ψ    Ψ ∧ Φ              |
      |                               |                               |
      | ============================= | ============================= |
      |  ∨E                           |  ∨I                           |
      | ============================= | ============================= |
      |   Φ ∨ Ψ                       |   Φ        Φ                  |
      |   Φ -> Θ                      |  -------  -------             |
      |   Ψ -> Θ                      |   Φ ∨ Ψ    Ψ ∨ Φ              |
      |  --------                     |                               |
      |   Θ                           |    (Ψ is any wff whatever)    |
      |                               |                               |
      | ============================= | ============================= |
      |  ->E                          |  ->I                          |
      | ============================= | ============================= |
      |   Φ -> Ψ                      |   |   Φ                       |
      |   Φ                           |   |   ...                     |
      |  ---------                    |   |   Ψ                       |
      |   Ψ                           |  ---------                    |
      |                               |   Φ -> Ψ                      |
      |                               |                               |
      | ============================= | ============================= |
      |  <->E                         |  <->I                         |
      | ============================= | ============================= |
      |   Φ <-> Ψ    Φ <-> Ψ          |   Φ -> Ψ     Φ -> Ψ           |
      |  ---------  ---------         |   Ψ -> Φ     Ψ -> Φ           |
      |   Φ -> Ψ     Ψ -> Φ           |  ---------  ---------         |
      |                               |   Φ <-> Ψ    Ψ <-> Φ          |
      |                               |                               |
      | ============================= | ============================= |
      |  EQ (Equiv. Substitution)     |  Ax (Axiom)                   |
      | ============================= | ============================= |
      |   [ Φ <-> Ψ ]    [ Φ <-> Ψ ]  |                               |
      |   Θ(Φ)           Θ(Ψ)         |  ---                          |
      |  -------------  ------------- |   Φ   (Φ is an axiom)         |
      |   Θ(Ψ/Φ)         Θ(Φ/Ψ)       |                               |
      |                               |                               |
      | ============================= | ============================= |
      |  ∀E                           |  ∀I                           |
      | ============================= | ============================= |
      |   ∀x:Φ                        |   |[α]     (new α)            |
      |  --------                     |   |   ...                     |
      |   Φ(α/x)  (any α)             |   |   Ψ(α)                    |
      |                               |  ------------                 |
      |                               |   ∀x:Ψ(x//α)                  |
      |                               |                               |
      | ============================= | ============================= |
      |  ∃E                           |  ∃I                           |
      | ============================= | ============================= |
      |   ∃xΦ(x)                      |   Φ(α)                        |
      |   |[α] Φ(α//x)  (new α)       |  -----------                  |
      |   |   ...                     |   ∃xΦ(x/α)                    |
      |   |   Ψ                       |                               |
      |  ---------------              |                               |
      |   Ψ                           |                               |
      |                               |                               |
      | ============================= | ============================= |
      |  =E                           |  =I                           |
      | ============================= | ============================= |
      |   α=β                         |                               |
      |   Φ(α)                        |  -----                        |
      |  --------                     |   α=α     α is any constant   |
      |   Φ(β/α)                      |                               |
      |                               |                               |
      | ============================= |                               |
      |  MInd                         |                               |
      | ============================= |                               |
      |   P0                          |                               |
      |   ∀x(Px -> Psx)               |                               |
      |  ---------------              |                               |
      |   ∀xPx                        |                               |
      +-------------------------------+-------------------------------+

Derived Inference Rules
=======================

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Reiterate (RE)                    P  ⊢  P
   Falso Quodlibet (EFQ)             P, ￢P  ⊢  Q    (Q is any wff whatever)
   Modus Tollens (MT)                P -> Q, ￢Q  ⊢  ￢P
   Hypothetical Syllogism (HS)       P -> Q, Q -> R  ⊢  P -> R
   Absorption (Abs)                  P -> Q  ⊢  P -> (P ∧ Q)
   Constructive Dilemma (CD)         P ∨ Q, P -> R, Q -> S  ⊢  R ∨ S
   Destructive Dilemma (DD)          P -> Q, R -> S, ￢Q ∨ ￢S ⊢ ￢P ∨ ￢Q
   Disjunctive Syllogism (DS)        P ∨ Q, ￢P  ⊢  Q
   Disjunctive Syllogism (DS)        P ∨ Q, ￢Q  ⊢  P
   Theorem (THM)                     [ ⊢ P ]  ⊢  P
   --------------------------------  -----------------------------------------
   ⊥ Introduction (⊥ I)              P, ￢P  ⊢  ⊥
   ⊥ Elimination (⊥ E)               (P ⊢ ⊥)  ⊢  ￢P
   ================================  =========================================

Derived Equivalences
====================

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Double Negation (DN)              ⊢  P <-> ￢￢P
   Tautology (TAUT)                  ⊢  P <-> (P ∧ P)
   Tautology (TAUT)                  ⊢  P <-> (P ∨ P)
   Transposition (TRANS)             ⊢  (P -> Q) <-> (￢Q -> ￢P)
   Material Implication (MI)         ⊢  (P -> Q) <-> (￢P ∨ Q)
   Association (ASSOC)               ⊢  (P ∧ (Q ∧ R)) <-> ((P ∧ Q) ∧ R)
   Association (ASSOC)               ⊢  (P ∨ (Q ∨ R)) <-> ((P ∨ Q) ∨ R)
   Commutation (COM)                 ⊢  (P ∧ Q) <-> (Q ∧ P)
   Commutation (COM)                 ⊢  (P ∨ Q) <-> (Q ∨ P)
   Exportation (EXP)                 ⊢  ((P ∧ Q) -> R) <-> (P -> (Q -> R))
   Distribution (DIST)               ⊢  (P ∧ (Q ∨ R)) <-> ((P ∧ Q) ∨ (P ∧ R))
   Distribution (DIST)               ⊢  (P ∨ (Q ∧ R)) <-> ((P ∨ Q) ∧ (P ∨ R))
   DeMorgan's law (DM)               ⊢  ￢(P ∧ Q) <-> (￢P ∨ ￢Q)
   DeMorgan's law (DM)               ⊢  ￢(P ∨ Q) <-> (￢P ∧ ￢Q)
   Material Equivalence (ME)         ⊢  (P <-> Q) <-> ((P -> Q) ∧ (Q -> P))
   Material Equivalence (ME)         ⊢  (P <-> Q) <-> ((P ∧ Q) ∨ (￢P ∧ ￢Q))
   Dual                              ⊢  ￢∀x￢Φ <-> ∃xΦ
                                     ⊢  ￢∀xΦ <-> ∃x￢Φ
                                     ⊢  ∀x￢Φ <-> ￢∃xΦ
                                     ⊢  ∀xΦ <-> ￢∃x￢Φ
   ================================  =========================================


================================================
Appendix B: Combined Truth-Tree Rules & Analysis
================================================

   ====  =====================================================================
   Name  Rule
   ====  =====================================================================
   ￢    If an open path contains both a formula and its negation, close it
         by placing '⊥' at the bottom of the path.

   ￢￢  If an open path contains an unstarred instance of ￢￢Φ, star it
         and write Φ at the bottom of every open path below it.

   ∧     If an open path contains an unstarred instance of Φ ∧ Ψ, star it
         and write both Φ and Ψ at the bottom of every open path that contains
         this newly starred wff.

   ￢∧   If an open path contains an unstarred instance of ￢(Φ ∧ Ψ), star
         it and split the bottom of each open path containing this newly
         starred wff into two branches, at the end of the first branch write
         ￢Φ and at the end of the second branch write ￢Ψ.

   ∨     If an open path contains an unstarred instance of Φ ∨ Ψ, star it
         and split the bottom of each open path containing this newly starred
         wff into two branches, at the end of the first branch write Φ and at
         the end of the second branch write Ψ.

   ￢∨   If an open path contains an unstarred instance of ￢(Φ ∨ Ψ), star
         it and write both ￢Φ and ￢Ψ at the bottom of every open path that
         contains this newly starred wff.

   ->    If an open path contains an unstarred instance of Φ -> Ψ, star it
         and split the bottom of each open path containing this newly starred
         wff into two branches, at the end of the first branch write ￢Φ and
         at the end of the second branch write Ψ.

   ￢->  If an open path contains an unstarred instance of ￢(Φ -> Ψ),
         star it and write both Φ and ￢Ψ at the bottom of every open path
         that contains this newly starred wff.

   <->   If an open path contains an unstarred instance of Φ <-> Ψ, star
         it and split the bottom of each open path containing this newly
         starred wff into two branches, at the end of the first write both
         Φ and Ψ, and at the end of the second write both ￢Φ and ￢Ψ.

   ￢<-> If an open path contains an unstarred instance of ￢(Φ <-> Ψ), star
         it and split the bottom of each open path containing this newly
         starred wff into two branches, at the end of the first write both
         Φ and ￢Ψ, and at the end of the second write both ￢Φ and Ψ.

   ----  ---------------------------------------------------------------------

   ∀     If ∀xΦ(x) appears on an open path, and α occurs in some wff on
         that path, write Φ(α//x) (the result of replacing each occurrence
         of x in Φ with α) at the bottom of the path.  If no wff containing
         α appears on the path, choose any α .

   ￢∀   If ￢∀xΦ(x) appears on an open path, star it and write ∃x￢Φ(x)
         at the bottom of every open path that contains the newly
         starred wff.

   ∃     If ∃xΦ(x) appears on an open path, star it.  Choose a constant α
         that doesn't appear on that path and write Φ(α//x) (the results of
         replacing each occurrence of x by α in Φ) at the bottom of every
         open path that contains the newly starred wff.

   ￢∃   If ￢∃xΦ(x) appears on an open path, star it and write ∀x￢Φ(x)
         at the bottom of every open path that contains the newly
         starred wff.

   ----  ---------------------------------------------------------------------

   =     If α=β appears on an open path along with either Φ(α) or Φ(β)
         unstarred, write at the bottom of the path any wff not already
         on the path which is the result of replacing one of more occurrences
         of either of these name letters by the other in Φ. Do not check
         either α=β or Φ.

   ￢=   Close any path on which ￢α=β occurs.
   ====  =====================================================================


   These rules can also be described in diagrams.

           +---------------------------+---------------------------+         
           | ========================= | ========================= |
           |           ￢Rule          |            ￢￢Rule       |
           | ========================= | ========================= |
           |             Φ             |          * ￢￢Φ          |
           |            ￢Φ            |          --------         |
           |          -------          |             Φ             |
           |             ⊥             |                           |
           |                           |                           |
           | ========================= | ========================= |           
           |           ∧Rule           |           ￢∧Rule         |
           | ========================= | ========================= |
           |         * Φ ∧ Ψ           |        * ￢(Φ ∧ Ψ)        |
           |          -------          |         -----------       |
           |             Φ             |            /     \        |
           |             Ψ             |          ￢Φ     ￢Ψ      |
           |                           |                           |
           | ========================= | ========================= |
           |           ∨Rule           |           ￢∨Rule         |
           | ========================= | ========================= |
           |         * Φ ∨ Ψ           |        * ￢(Φ ∨ Ψ)        |
           |          -------          |         -----------       |
           |           /   \           |             ￢Φ           |
           |          Φ     Ψ          |             ￢Ψ           |
           |                           |                           |
           | ========================= | ========================= |
           |           ->Rule          |          ￢->Rule         |
           | ========================= | ========================= |
           |         * Φ -> Ψ          |       * ￢(Φ -> Ψ)        |
           |          --------         |        ------------       |
           |           /    \          |             Φ             |
           |         ￢Φ      Ψ        |            ￢Ψ            |
           |                           |                           |
           | ========================= | ========================= |
           |          <->Rule          |         ￢<->Rule         |
           | ========================= | ========================= |
           |        * Φ <-> Ψ          |       * ￢(Φ <-> Ψ)       |
           |         ---------         |        -------------      |
           |          /     \          |           /     \         |
           |         Φ      ￢Φ        |          Φ      ￢Φ       |
           |         Ψ      ￢Ψ        |         ￢Ψ       Ψ       |
           |                           |                           |
           | ========================= | ========================= |
           |           ∀Rule           |           ￢∀Rule         |
           | ========================= | ========================= |
           |           ∀xΦ(x)          |        * ￢∀xΦ(x)         |
           |          --------         |         ----------        |
           |           Φ(c/x)          |          ∃x￢Φ(x)         |
           |                           |                           |
           | if possible c is not new  |                           |
           |                           |                           |
           | ========================= | ========================= |
           |           ∃Rule           |           ￢∃Rule         |
           | ========================= | ========================= |
           |        * ∃xΦ(x)           |        * ￢∃xΦ(x)         |
           |         ---------         |         -----------       |
           |          Φ(c//x)          |          ∀x:￢Φ(x)        |
           |                           |                           |
           |          c is new         |                           |
           |                           |                           |
           | ========================= | ========================= |
           |           =Rule           |         ￢=Rule           |
           | ========================= | ========================= |
           |       α=β       α=β       |          ￢α=α            |
           |       Φ(α)      Φ(β)      |         --------          |
           |      --------  --------   |          ⊥                |
           |       Φ(β/α)    Φ(α/β)    |                           |
           |                           |                           |
           +---------------------------+---------------------------+

Truth-Tree Analysis
===================

   Truth-Tree Assessment of a Single WFF

         =============   ============================   ==========
         condition       wff                            ￢wff
         =============   ============================   ==========
         0               inconsistent                   validity
         1+              consistent                     contingent
         2+              validity or contingency        contingent
         =============   ============================   ==========

   Truth-Tree Assessment of a set of WFFs

         =============   ============================
         condition       wff Set
         =============   ============================
         0               inconsistent
         1+              consistent
         =============   ============================

   Truth-Tree Assessment of a Sequent

         =============   ============================
         Condition       Premises & ￢Conclusion
         =============   ============================
         0  open paths   valid
         1+ open paths   Invalid w/ counterexamples
         =============   ============================


=================================
Appendix D: UTF-8 Character Codes
=================================

   Symbol                                              hex code
   ==================================================  ========
   Logical Symbols

   ∴            therefore                              2234
   ∵            because                                2235
   ￢           negation                               FFE2
   ∧            conjunction                            2227
   ∨            disjunction                            2228
   →            conditional                            2192
   ↔            biconditional                          2194
   ←            reverse conditional, only if           2190
   ∀            universal quantifier                   2200
   ∃            existential quantifier                 2203
   ℩            definite descriptor (inverted iota)    2129
   ▫            box                                    25AB
   ⋄            diamond                                22C4
   ▪            solid box                              25AA
   ♦            solid diamond                          2666
   T            tautology, valid wff                   22A4
   ⊥            contradiction (inverted T)             22A5
   ⊢            entails (turnstile)                    22A2
   ⊬            doesn't entail                         22AC
   ⊨            satisfies                              22A8
   ⊭            doesn't satisfy                        22AD
   𝕸            model function                         0001D578

   Set Thoery Symbols

   ∅  or  null  empty set                              2205
   ∊            membership                             220A
   ⊂            proper subset                          2282
   ⊆            subset                                 2286
   ⊃            proper superset                        2283
   ⊇            superset                               2287
   ∪            union                                  222A
   ∩            intersection                           2229
   
   Mathematical Symbols

   ≠            is not equal to                        2260
   ≤            is less than or equal to               2264
   ≥            is greater than or equal to            2265

   Box Drawing Symbols

   ┌            top left                               250C
   ┐            top right                              2510
   ─            horizontal                             2500
   │            vertical                               2502
   ┬            horizontal down                        252C
   ┴            horizontal up                          2534
   ┼            plus                                   253C
   ├            vertical right                         251C
   ┤            vertical left                          2524
   └            bottom left                            2514
   ┘            bottom right                           2518

   ═            double horizontal                      2550
   ║            double vertical                        2551


==============================
Appendix E: The Greek Alphabet
==============================

   The Greek Alphabet

       Upper                  Lower

   Sym   Name         Sym   Name
   -------------     ------------------
   Α     ALPHA        α     alpha
   Β     BETA         β     beta
   Γ     GAMMA        γ     gamma
   Δ     DELTA        δ     delta
   Ε     EPSILON      ε     epsilon
   Ζ     ZETA         ζ     zeta
   Η     ETA          η     eta
   Θ     THETA        θ     theta
   Ι     IOTA         ι     iota
   Κ     KAPPA        κ     kappa
   Λ     LAMBDA       λ     lambda
   Μ     MU           μ     mu
   Ν     NU           Ν     nu
   Ξ     XI           χ     xi
   Ο     OMICRON      ο     omicron
   Π     PI           π     pi
   Ρ     RHO          ρ     rho
   Σ     SIGMA        σ     sigma
   Τ     TAU          τ     tau
   Υ     UPSILON      υ     upsilon
   Φ     PHI          φ     phi
   Χ     CHI          χ     chi
   Ψ     PSI          ψ     psi
   Ω     OMEGA        ω     omega


