##############################################################################
##############################################################################
##############################################################################
##############################################################################
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######          ##############################################          ######
######          ##############################################          ######
######          ###                                        ###          ######
######          ###              Retro Notes               ###          ######
######          ###                                        ###          ######
######          ###            Classical Logics            ###          ######
######          ###                                        ###          ######
######          ##############################################          ######
######          ##############################################          ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                     AtomicRetro@outlook.com                      ######
######                                                                  ######
######                     Revision:                                    ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
##############################################################################
##############################################################################
##############################################################################
##############################################################################


==============================
To View This Document Properly
==============================
   * Best viewed in VIM using with settings
         :set columns=80
         :set encoding=utf-8

   * This document must be viewed with a mono-spaced font to enjoy the layout,
     tables and diagrams.

   * This document must be viewed in an editor that can display unicode utf-8.


======================================
CONTENTS
======================================
   Contents
   Preface
   Introduction
      Preliminary Definitions
      Formal Definitions
      The Laws of Logic
      Set Theory
   Propositional Logic (PL)
      Language
      Semantics
      Calculus (PC)
   Predicate Logic
      Language
      Semantics
      Calculus
   First-Order Quantified Logic (FOL)
      Language
      Semantics
      Calculus (FOC)
   Identity Logic (IL/FOL=)
      Language
      Semantics
      Calculus
   Function Logic (FL/FOL=)
      Language
      Semantics
      Calculus
   Definite Descriptors
      Language
      Semantics
      Calculus
   Second-Order Quantified Logic (SOL=)
      Language
      Calculus
   Mathematical Induction
   Axiomatic and Natural Deduction
   Formal Theories & Axioms


=======
Preface
=======

   I wrote these books for anyone who needs a reference in logic.
   The concepts are presented concisely but clearly with all necessary
   detail.  Nevertheless, the information density is higher than would
   be found in a textbook.

   The introduction begins with some preliminary information about logic:
   Namely a review of some basic though important definitions, a discussion
   on formal definitions, a short section on the laws of logic finished off
   by a quick review of some basic set theory.

   The first chapter covers propositional logic; the logic of 'not', 'and',
   'or' and similar notions.  It begins by describing the formal language:
   the lexemes and the grammar.  Next is a study of the language's semantics
   with formal descriptions of the lexemes and the sentences.  The chapter
   rounds out with an investigation into inference, introducing a modern
   deductive calculus.

   Most of the remaining chapters follow the same pattern of language,
   semantics, calculus, with some supplementary sections here and there.
   Each chapter describes a different system within classical logic covering:
   Predicate Logic, First-Order Quantified Logic (FOL), Identity Logic and
   FOL=, Function Logic (FL), Russell's Theory of Definite Descriptors,
   Second-Order Quantified Logic (SOL), and lastly, Mathematical Induction.
   The book closes with mentions of Axiomatic Deductive Systems, then Formal
   Theories and their Axioms.

   The notation selected for this book may vary slightly from that of other
   books.  However, the symbol set was selected to reflect aesthetic
   principles.  The logical operator symbols consist of well-defined straight
   lines in symmetrical arrangements to reflect the similarly well-defined
   rigid logical operations.  Parentheses, used for grouping just as in math,
   can be thought of as representing nested bubbles.  Both of these are in
   stark contrast to the large round or curvy letters used to denote more
   complex, less well-defined English sentences.

   The reader ought to be aware of some conventions used in this book.  When
   a term is defined, it will appear in all capital letters to facilitate
   searching.  A pair of asterisks denote italics.  Single quotes will denote
   a mention, vs. a use, of a symbol.  Most of the time, single quotes will
   be implicit.  Strings surrounded by single quotes denote something
   that is to be taken literally.  To avoid confusion this book ignores
   the usual English grammar rules for punctuation within quotations when
   following the rules can lead to confusion.

   This book will be updated periodically, and some sections may be removed
   or developed further based upon reader feedback.  Please contribute by
   reporting an error or omission or submitting other comments by contacting
   the author here: AtomicRetro@outlook.com.


============
Introduction
============


-----------------------
Preliminary Definitions
-----------------------

   TRUTH-VALUE

      any member of the set { true, false }.

   PROPOSITION

      the concept that a true or false statement denotes; many different
      statements can denote the same proposition. 

   ARGUMENT

      a set of propositions; one of which is intended as a CONCLUSION, a sort
      of finding; the rest, the PREMISES, are claimed to provide some evidence
      for the conclusion.

   INFERENCE

      the reasoning process expressed by an argument.

   DEDUCTIVE ARGUMENT

      an argument whose conclusion cannot be false when all the premises
      are true.

   VALID ARGUMENT

      a deductive argument which is genuinely deductive in the sense
      defined above.

   SOUND ARGUMENT

      a valid argument whose premises are all true.

   INVALID ARGUMENT

      an INVALID ARGUMENT is an argument claimed to be deductive but contains
      reasoning errors, or missing premises, or incorrect applications of
      inference rules, and so on; any argument that is not really deductive.

   COUNTEREXAMPLE

      a clearly invalid argument having the same structure as an argument
      claimed to be valid.

   FORMAL LOGIC

      the study of argument forms or patterns without regard to meaning.
      Formal logic is recognizable because it makes use of symbol languages.


------------------
Formal Definitions
------------------

   A FORMAL DEFINITION is a statement that two strings, called the
   DEFINIENDUM and the DEFINIENS, are interchangeable; that they mean the
   same thing.  Express definitions formally as follows:

         *definiendum*   =df  *definiens*

   In formal definitions, the *definiendum* is usually an abbreviation
   for the *definiens*.

         *abbreviation*  =df  *definiens*

                      ⊥  =df  (P ∧ -P)

Definition Schemata
===================

   A DEFINITION SCHEMA is a "family" of definitions all having the same
   structure.  A schema includes place-holders denoted by letters towards
   the end of the alphabet: u,v,w,x,y,z, across which values are substituted
   uniformly to obtain a definition.

   Example: definition schema of the 'probability of X given that Y'.

                      P(X ∧ Y)
         P(X|Y)  =df  --------
                        P(Y)

   Whenever we see an instance of P(X|Y), the definition informs us that
   it is interchangeable with and so can be replaced by the corresponding
   right-hand side, replacing values for X, and Y uniformly.  The reverse
   operation is also entailed in the definition.

   So the question, what is the probability that Sally slips given that
   it is icy, yields the following definition.

                      P(S ∧ I)
         P(S|I)  =df  --------
                        P(I)

   If a definiens is replaced by its abbreviation it's called PACKING, while
   UNPACKING is replacing an abbreviation with its definiens.


-----------------
The Laws of Logic
-----------------

   The simplest logic has just two discrete truth-values: True and False;
   which are complements of eachother:  false =df not true.  From this binary
   relation, it is possible to construct the following logical principles.

   LAW OF NON-CONTRADICTION (LNC)

      A proposition P is not both True and False.

   LAW OF EXCLUDED MIDDLE (LEM)

      A proposition P is either True or False.

   IDENTITY OF INDISCERNIBILITY

      If two things have all of the same properties, then they are
      the same object.

   LAW OF INDISCERNIBILITY OF IDENTICALS (LEIBNIZ'S LAW)

      If two things are the same object, then they have all of the
      same properties.


----------
Set Theory
----------

   A SET is a collection of objects which has no particular order but in which
   each member object occurs just once.

Set Definition
==============

   Sets are defined formally within a pair of braces { and }.
   The simplest definition of a set is by exhaustive enumeration,
   listing out all the members.

         A = { my phone, empire state building, the number 6,
               the neighborhood dog that's always barking }

   The empty set called NULL has its own symbol.

         ∅ = { } = null/empty set

   Many sets are too large to enumerate, so instead of enumerating their
   members, their members' properties define them; this is accomplished using
   a comprehension.  A COMPREHENSION is a set defined by properties and
   includes the use of a '|', which is read as, 'such that.'

         M = the set of all mammals
           = { x | x is a mammal }
           = read, "the set of all x such that x is a mammal."

         E = { x | x/2 = int(x/2) }
           = "The set of all x such that x divided by 2 equals the integer
             of x divided by 2."
           = "The set of all numbers evenly divisible by two."

         P = { x | (x is an integer) or (x is red) }
           = "The set of all integers or red things."

         Z = { x | x is an integer }
             It is customary to denote this set with a bold capital 'Z'.

   <x,y> is an ORDERED PAIR, a value which requires two numbers to be
   fully expressed, where x,y can be any two real numbers.

         F = { <x,y> | (x in Z) and (y=10x) }
             The set of all ordered pairs <x,y> such that x is an integer
             and y is ten times x.

Set-Member Relations
====================

   The things that sets are composed of are called OBJECTS, ELEMENTS
   or MEMBERS; a set *is* its membership.

   MEMBERSHIP ( ∊ )

         a ∊ P says, "a is a MEMBER/ELEMENT of P," or, "OBJECT a is in P."
         Fido ∊ Dog, Fido is a dog.
         2 ∊ Even, 2 is even.

   IDENTITY ( = )

         A = B, Sets A and B have the same members.
         x = y, symbols x and y denote the same object.

   PROPER SUBSET ( ⊂ )

         A ⊂ B, set A is composed of some but not all of the objects in set B.
         E ⊂ Z, even-numbered integers are a subset of integers.

   SUBSET ( ⊆ )

         A ⊆ B, A is composed of some or all of the members in set B,
                but no others.

   PROPER SUPERSET & SUPERSET ( ⊃, ⊇ )

         ⊃ and ⊇ work similarly to the subset operators.

Set Operations
==============

   Consider,

         R = { x | x is red }
         C = { x | x is a car }

   UNION ( ∪ ) 

      The UNION of two sets is the set of all things contained in both
      of those sets combined.

         R ∪ C
         = { x | x is red } ∪ { x | x is a car }
         = { x | (x is red) or (x is a car) }

   INTERSECTION ( ∩ )

      The INTERSECTION of two sets is the set of all things common to those
      two sets.

         R ∩ C
         = { x | x is red } ∩ { x | x is a car }
         = { x | (x is red) and (x is a car) }

   DIFFERENCE ( - )

         R - C = { x | (x is red) and (x is not a car) }

   COMPLEMENT ( ' )

      The COMPLEMENT of a set is the set of all things *not* in the set.

         C' = { x | x is not a car }
         C'' = C

   CARDINALITY ( || )

      The CARDINALITY of a set is how many members it contains.

         A = { a, b, c }
         |A| = 3
         |Z| = infinity

Set Properties
==============

   UNIVERSE

      U, UNIVERSE OF DISCOURSE (also DOMAIN OF DISCOURSE) is the set of all
      objects in our discussion.

      The universe and the empty set are complements of each other.

         U' = { }

   DECIDABLE SET

      A set is DECIDABLE if and only if there is an effective method
      for determining whether an object is in the set.

   1:1 CORRESPONDENCE

      There is a 1:1 CORRESPONDENCE between sets A and B if and only if there
      is a way to pair off each member of set A with a unique member of set
      B.  Therefore, both sets have the same cardinality; |A| = |B|.  Every
      member of A pairs to exactly one member of B, and vice versa.

   DENUMERABLE

      A set is DENUMERABLE if and only if there is a 1:1 correspondence
      between it and the set of natural numbers.  Hence, the cardinality of
      the set is infinite.


===================
Propositional Logic
===================

   Propositional logic is about the truth-functions, 'and,' 'not' and
   similar concepts.


--------
Language
--------

   LANGUAGE

      defined by the set of all sensical sentences in the language

   LEXEME

      the smallest semantic unit of a language, often called a word

   FORMAL LANGUAGE

      the set of all grammatically correct sentences in a language.  Formal
      languages do not consider semantics, so many such sentences may
      be nonsensical.

   METALOGIC

      the discipline that studies and proves things about logic.

   METALANGUAGE

      the language used to talk about logic.  So sentences in the metalanguage
      mention properties of the logic, arguments, and things they entail.
      Most of this book is written in the metalanguage.

Lexemes
=======

   Non-Logical Symbols
      Proposition Symbols:      A...Z
      Association Symbols:      (, )

   Logical Symbols
      Truth-Function Symbols:   -, ∧, ∨, →, ↔

Grammar
=======

   FORMAL GRAMMAR

      The set of rules that selects all and only the grammatically correct
      strings in a given formal language without regard to meaning.

   A grammatically correct sentence in logic is called a WELL-FORMED FORMULA
   (WFF, or FORMULA).  It is conventional to use Greek capital letters
   to represent arbitrary formulas.  A wff in propositional logic is any
   string constructed by the following clauses (called FORMATION RULES):

   An ATOMIC FORMULA is any single proposition symbol.

   1.  Each atomic formula is a wff;
   2.  if Φ is a wff, then -Φ is a wff;
   3.  if Φ, Ψ are wffs, then (Φ ∧ Ψ),(Φ ∨ Ψ),(Φ → Ψ),(Φ ↔ Ψ) are wffs;
   4.  nothing else is a wff.

   Notes

   - Notice that the formation rules for wffs are recursive, meaning that
     wffs can nest within other wffs to any depth.  While P ∧ Q is a wff,
     so is (-(P ∨ Q) → R).

   - To aid readability, I adopt the convention that if a wff begins with
     '(', I will drop the outermost pair of parentheses.

   - In practice, it is common to use PRIME marks ('), or numerical
     subscripts after a proposition symbol to increase the number of
     available symbols.  E.g. P, P' and P₂ are distinct atomic formulas.

Alternative Notation
--------------------

         Negation       ￢ ～
         Conjunction    &  *
         Disjunction    +
         Conditional    ⊃
         Biconditional  =  ⇔  ≡

Syntax Trees
============

Truth-Function Anatomy
----------------------

   Below are the formal, informal, and metalogical names of the operations
   and operands.

         ======  ========  =============  =======  ====================
         Formal  Informal  Metalogical    Example  Operand Names
         ======  ========  =============  =======  ====================
          -      not       NEGATION       -P       P is a NEGATAND
          ∧      and       CONJUNCTION    P ∧ Q    P,Q are CONJUNCTS
          ∨      or        DISJUNCTION    P ∨ Q    P,Q are DISJUNCTS
          →      if/then   CONDITIONAL    P → Q    P is the ANTECEDENT,
                                                    Q is the CONSEQUENT
          ↔      just if   BICONDITIONAL  P ↔ Q    Operands
         ======  ========  =============  =======  ====================

   ARITY is the number of subordinates an operation requires.  For example,
   negation has an arity of one because it has one subordinate, while
   conjunction has two.  The table below lists some common arities and some
   different names by which they go.

         =====  =========  ==========  ==========  ====================
         Arity  -ary name  -adic name  place name  Examples
         =====  =========  ==========  ==========  ====================
          0                            0-place     P
          1     UNARY      MONADIC     1-place     -P
          2     BINARY     DIADIC      2-place     P ∧ Q, P ∨ Q
          3     TRINARY    TRIADIC     3-place     x is between y and z
         =====  =========  ==========  ==========  ====================

Tree Graphs
-----------

   Below is a tree graph.  Tree graphs are useful in organizing some kinds
   of information.  The lines are called EDGES, which connect NODES
   or VERTEXES.  A node that has an edge above it is CHILD, and conversely,
   a node that has an edge below it is called a PARENT.  Tree graphs are
   inverted from their counterparts in nature.  Thus the ROOT of a tree graph
   is at the top.   The rest of the tree descends from the root-placing
   the childless LEAVES all at the bottom.  Traversing a series of nodes
   via their joining edges down to a leaf is called a PATH
   (e.g., parent&child > node > leaf4).  Descending a path sees children
   splitting into BRANCHES.

                             Root 
                             /  \
                            /    \
                        leaf1    parent&Child 
                                 /          \
                                /            \
                             child           node 
                             /   \           /   \
                            /     \         /     \
                         leaf2   leaf3   leaf4   leaf5

Syntax Trees
------------

   Wff's can be diagrammed into a recursive tree structure in which
   operators are parent nodes and atomic and non-atomic subordinate wff's
   are the child nodes.  The number of children an operator node has is equal
   to the arity of that operator.

         -(P → (Q V -R))

                               -
                               |
                               |
                               →
                             /    \
                           /        \
                         P            ∨
                                    /   \
                                  /       \
                                Q           -
                                            |
                                            |
                                            R

   The operator at the root of the tree is called the MAIN OPERATOR or
   TOP-LEVEL Operator.  In the example the main operator is negation.

Substitution Instance
=====================

   A SUBSTITUTION INSTANCE of a wff has the same structure as the original
   but where *new* wffs uniformly replace proposition symbols in the original.
   'Instance of' relationships do not have to be symmetrical and usually are
   not.  P being an instance of Q, does not imply that Q is an instance of P.

   =============  =====   =======   ===========   ====================
   Original Form  P ∧ Q | P  ∧ Q  | P ∧ Q       | P  → (P  ∧ Q       )
   =============  =====   =======   ===========   ====================
   Substitutions  P=R   | P=-S    | P=D         | P=-H
                  Q=S   | Q=Z     | Q=(C → D)   | Q=(-S ∨ M)
   -------------  ----- | ------- | ----------- | --------------------
   Instance       R ∧ S | -S ∧ Z  | D ∧ (C → D) | -H → (-H ∧ (-S ∨ M))
   =============  =====   =======   ===========   ====================


---------
Semantics
---------

The semantics of a language are the concepts denoted by the lexemes and
sentences (propositional logic wffs).

Translation Hints
=================

   +-----------------------------------------------------------------------+
   | =================================   ================================= |
   | P                                 | -P                                |
   | ================================= | ================================= |
   | P                                 | it's false that P                 |
   | it's true that P                  | it's not true that P              |
   | it's the case that P              | it's not the case that P          |
   | P whether or not Q                | non-P                             |
   |   literally:  (Q ∨ -Q) → P        |                                   |
   |                                   |                                   |
   | ================================= | ================================= |
   | P ∧ Q                             | -(P ∧ Q)                          |
   | ================================= | ================================= |
   | both P and Q                      | P nand Q (in computing)           |
   | P but Q                           |                                   |
   | P yet Q                           |                                   |
   | P still Q                         |                                   |
   | P also Q                          |                                   |
   | P additionally Q                  |                                   |
   | P furthermore Q                   |                                   |
   | P however Q                       |                                   |
   | P although Q                      |                                   |
   | P nevertheless Q                  |                                   |
   | P moreover Q                      |                                   |
   | P even if/though Q                |                                   |
   | P whereas Q                       |                                   |
   |                                   |                                   |
   | ================================= | ================================= |
   | P ∨ Q                             | -(P ∨ Q)                          |
   | ================================= | ================================= |
   | P or Q (or both)                  | neither P nor Q                   |
   | P except if/when Q                | P nor Q (in computing)            |
   | P except on condition that Q      |                                   |
   | P unless Q                        |                                   |
   |                                   |                                   |
   | ================================= | ================================= |
   | P → Q                             | -P → -Q                           |
   | ================================= | ================================= |
   | if P then Q                       | P is a necessary condition for Q  |
   | P implies Q                       | P is necessary for Q              |
   | P only if Q                       |                                   |
   | P results in Q                    |                                   |
   | P brings about Q                  |                                   |
   | P leads to Q                      |                                   |
   | P is a sufficient condition for Q |                                   |
   | P is sufficient for Q             |                                   |
   | Q assuming that P                 |                                   |
   | Q on the condition that P         |                                   |
   | Q given that P                    |                                   |
   | Q provided that P                 |                                   |
   | Q in case P                       |                                   |
   |                                   |                                   |
   | ================================= | ================================= |
   | P ↔ Q                             | P ↔ -Q                            |
   | ================================= | ================================= |
   | P if and only if (iff) Q          | P xor Q (in computing)            |
   | P just if Q                       | either P or Q (but not both)      |
   | P just in case Q                  | P unless also Q                   |
   | P exactly if/when Q               | P unless Q                        |
   | P but only if Q                   | either P or Q                     |
   | P is a necessary and sufficient   |                                   |
   |    condition for Q                |                                   |
   | P is necessary and sufficient     |                                   |
   |    for Q                          |                                   |
   +-----------------------------------------------------------------------+

Conversational Implicature
==========================

   CONVERSATIONAL IMPLICATURE is what is meant by a speaker's utterance that
   is not part of the literal meaning of what is explicitly said.

   'and then'

   When 'and' is a shortened form of 'and then,' it cannot be translated
   into a conjunction since the word 'then' here denotes a temporal
   relationship between the clauses it joins and the conjunction operator
   in propositional logic has no notion of time.

         Keep up the good work, and you'll go far.

         Alice drove home and went to bed.

   'if...then'

   It can be tempting to rewrite 'and then' as 'if...then,' but it doesn't
   always result in a sentence with the same meaning.

         Keep up the good work, and you'll go far.
         If you keep up the good work, then you'll go far.

         Alice drove home and went to bed.
         If Alice drove home, then she went to bed.

   Again the use of 'then' in these 'if/then' examples denotes a temporal
   relationship; it cannot be translated into a propositional logic
   conditional.  Consider what happens by negating the first rewritten example
   and seeing what is derived after applying a few logical equivalences.

         K → F,      if you keep up the good work, then you'll go far.

         -(K → F),   it's false that if you keep up the work, you'll go far
         -(-K ∨ F)
         K ∧ -F,     You keep up the good work, and you don't go far.

Valuation Function
==================

   A TRUTH-FUNCTION is any of our five operations.  These functions operate
   upon true/false values.  The semantics of the truth-functions are formally
   described by a function v called a VALUATION FUNCTION. v encapsulates all
   there is to say about the meanings of propositional logic's
   truth-functional operators.

   Here is the valuation function for propositional logic,

         v(-Φ)    = true if Φ is false;
                    false if Φ is true
         v(Φ ∧ Ψ) = true if both Φ and Ψ are true;
                    false if either Φ or Ψ or both are false
         v(Φ ∨ Ψ) = true if either Φ or Ψ or both are true;
                    false if both Φ and Ψ are false
         v(Φ → Ψ) = true if Φ is false or Ψ is true;
                    false if Φ is true and Ψ is false
         v(Φ ↔ Ψ) = true if both Φ and Ψ are true, or
                            both Φ and Ψ are false;
                    false if either Φ is true and Ψ is false, or
                                    Φ is false and Ψ is true.

Sequents
========

   A SEQUENT is a metalogical notation expressing that a conclusion C
   follows from a set of premises, P1,...,Pn.

         P1,...,Pn  ⊢  C

   '⊢' is a TURNSTILE.  It's part of the metalanguage, not a part of
   propositional logic.

   An ARGUMENT FORM is another name for a sequent.  Formal logic studies
   argument forms (reasoning patterns).

TRUTH-TABLES
============

   Truth-tables allow us to visually study the semantic characteristics of
   wffs as defined by the valuation function.  Each row of the table is
   equivalent to one VALUATION of the function v upon a formula.

Truth-Table Construction
------------------------

  Procedure

   1.  Construct The table heading starting on the top left with a horizontal
       alphabetical list of all proposition symbols occurring in the formulas
       under study, followed to the right by a second horizontal list of the
       formulas themselves.

   2.  Under the list of proposition symbols list all possible combinations
       of T and F for those symbols.  The table starts with a row of all
       F and end with all T, or vice versa, according to preference.
       The values for the intermediate rows are attained as if counting
       in binary.

   3.  The remainder of the table is populated row-by-row carrying the
       T or F values under each proposition symbol to the right and placing
       them under the corresponding symbol occurring in each wff.

   4.  In a given row under the first formula, starting from the innermost
       parentheses and working outwards, evaluate each of the expressions
       according to the valuation function, v.  Continue until a T or F can
       be placed under the top-level operator on every row.  Repeat this
       valuation procedure below each wff and each row in the table.

   The study will only need to consider the columns under each formula's main
   operator, so it is convenient to highlight the completed column somehow.
   Here I place an '*' at the bottom of those columns.

Truth-Table Study of The Truth-Functions
----------------------------------------

   The valuations for the primitive truth-functions are illustrated in the
   following truth-tables.

          P   | - P
         ===========
          F   | T F
          T   | F T
                *

          P Q | (P ∧ Q) | (P ∨ Q) | (P → Q) | (P ↔ Q)
         =============================================
          F F |  F F F  |  F F F  |  F T F  |  F T  F
          F T |  F F T  |  F T T  |  F T T  |  F F  T
          T F |  T F F  |  T T F  |  T F F  |  T F  F
          T T |  T T T  |  T T T  |  T T T  |  T T  T
                   *         *         *         *

Truth-Table Study of A Single WFF
---------------------------------

   More typical of a truth-table is its construction for a more complex
   formula.  Here's an example,

          P Q | -(P ↔ Q) V P
         ======================
          F F | F F T F  F F
          F T | T F F T  T F
          T F | T T F F  T T
          T T | F T T T  T T
                         *

   Once the truth-table is completed examining the column below the main
   operator can reveal important properties of the formula.

   INCONSISTENT WFF

      A formula that has no true valuations; i.e. the column under the main
      operator has all F's.

   CONTRADICTION

      A kind of inconsistent formula that's structured as the conjunction
      of a wff and its negation; i.e. any instance of 'Φ ∧ -Φ'.

   CONSISTENT WFF

      A wff that is true on at least one valuation (row); i.e. the column
      under the formula's main operator contains at least one T.

   CONTINGENT WFF

      A consistent formula that's true on some valuations and false on
      others; i.e. the column under the main operator contains at least
      one T and at least one F.

   TAUTOLOGY or VALIDITY

      A consistent formula that's true on all valuations; i.e. the column
      under the main operator contains all T's.

   Summary

         =======  =======  ==========================
         Num T's  Num F's  Assessment
         =======  =======  ==========================
         0        2+       inconsistent/contradiction
         1+       0+       consistent
         1+       1+       contingent
         2+       0        tautology or validity
         =======  =======  ==========================

Truth-Table Study of A Set of WFFs
----------------------------------

   A truth-table study of a set of wffs can give us insight into the
   relationships between those formulas.

   CONSISTENT SET OF FORMULAS

      A set of wffs is CONSISTENT if there is at least one valuation (row)
      of the table on which every formula has T under its main operator.

   INCONSISTENT SET OF FORMULAS

      A set of wffs is INCONSISTENT if there is no valuation (row)
      on which all formulas have T under their main operators.

   LOGICALLY EQUIVALENT PAIR OF FORMULAS

      A pair of wffs is LOGICALLY EQUIVALENT if for every valuation (row)
      of the table, both wffs have the same value under their main
      operators.  Notice that each of the following pair of formulas
      is logically equivalent.

          R S | R → S | - R ∨ S
          ========================
          F F | F T F | T F T F
          F T | F T T | T F T T
          T F | T F F | F T F F
          T T | T T T | F T T T
                  *         *

Truth-Table Study of A Sequent
------------------------------

   A truth-table for an argument is constructed simply by treating the set
   of premises and the conclusion as a set of wffs under study.

   Evaluation is just a matter of reading the definition of a valid deductive
   argument directly off the table.  A deductive argument is an argument
   whose conclusion cannot be F if the premises are all T.  Notice from the
   definition that the conclusion is free to hold any value on a valuation
   (row) where the premises are not all true.

   Example

          P Q | P → Q , - Q  ⊢  - P
         ===========================
          F F | F T F | T F  |  T F  <==
          F T | F T T | F T  |  T F
          T F | T F F | T F  |  F T
          T T | T T T | F T  |  F T
                  *     *       *

   The row indicated with an arrow verifies that this argument is valid.

   An invalid argument is an argument that contains at least one valuation
   on which all the premises are T, but the conclusion is F.

   Example

          P Q | P → Q ,  - P  ⊢  - Q
         ============================
          F F |   T   |  T    |  T F
          F T |   T   |  T    |  F T  <==
          T F |   F   |  F    |  T F
          T T |   T   |  F    |  F T
                  *      *       *

   We have discovered a row on which the premises are all T, but the
   conclusion is F, so the argument form is invalid.

   The results for an inconsistent set of premises may seem counter-intuitive.

          P Q | P , - P ⊢  Q
         ====================
          F F | F | T F |  F
          F T | F | T F |  T  <==
          T F | T | F T |  F
          T T | T | F T |  T  <==
                *   *      *

   This argument is valid.  Since there are no rows where the premises
   are all true; any conclusion whatever follows.

   A disadvantage of truth-tables is that they grow exponentially.  A set
   of wffs with n proposition symbols will have 2^n rows.

Truth-Functional Completeness
-----------------------------

   TRUTH-FUNCTIONAL COMPLETENESS describes any set of truth-functional
   operators from which all other truth-functions can be defined.
   Propositional logic's set of primitive operators -, ∧, ∨, → and ↔
   is truth-functionally complete.  But so too is negation with any other
   single operator.  Some authors have defined new operators that are
   singularly truth-functionally complete.  An example is the SHEFFER STROKE
   symbol '(P|Q)', whose valuation function is logically equivalent to the
   form -(P ∧ Q).  However, any logic constructed upon just one operator
   is cumbersome to use.

   For example, observe in the two examples that the columns under the
   main operators (highlighted with '*') under each wff have the same
   value in the same valuation.

          P Q | (P | Q) | -(P ∧ Q)
         ==========================
          F F |  F T F  | T F F F
          F T |  F T T  | T F F T
          T F |  T T F  | T T F F
          T T |  T F T  | F T T T
                   *      *

Truth-Tables ("Fast Method")
============================

   There is a faster way to construct a truth-table, though it is not
   as visually satisfying.  Instead, it implements a search algorithm
   to find only those valuations on which a formula is T (or F).  It has
   the advantage over a full truth-table in that we escape the problem
   of potentially huge tables due to a large number of proposition symbols.

   Procedure

   1.  Write down in a horizontal list of the wff, set of wffs, or sequent
       under study.  Write T or F (depending on what you are trying to find -
       see Truth-Table Study of Single WFFs above) below the main operator of
       each formula.

   2.  Now work backwards from the main operator down to the innermost
       parentheses.  Evaluate as many sub-expressions as possible, continuing
       until it is not possible to do anything else - some sub-wffs may
       go undetermined.

   3.  While performing step 2 if you can find the truth-value of
       a proposition symbol, place that value under all other occurrences
       of that symbol in each of the wffs under study.

   4.  The search is successful upon finding a contradiction or if the
       valuation sought is now readable off the table.  This is the set
       of values found for the proposition symbols that makes the main
       operator T (or F).

   The study is to find valuations for the proposition symbols on which
   the whole wff is T (or F).  So, it is convenient to highlight somehow
   the symbols' values at the end of this process.  I will place
   an '*' under them.

Fast truth-table Study of A Single WFF
--------------------------------------

   To check if a wff has any valuation on which it is T, set its main
   operator to T; and to check if it has a valuation on which it is F,
   set its main operator to F.

   Examples

         1.  P ∧ Q     --P ∧ (Q ∨ P)     P ∨ -Q     P → (- Q ∨ R)
               T           T               F          F

         2.  P ∧ Q     --P ∧ (Q ∨ P)     P ∨ -Q     P → (- Q ∨ R)
             T T T     T   T    T        F F F      T F    F
             *   *

         3.            --P ∧ (Q ∨ P)     P ∨ - Q    P → (- Q ∨ R)
                       TFT T    T T      F F F T    T F  F   F F
                                         *     *

         4.            --P ∧ (Q ∨ P)                P → (- Q ∨ R)
                       TFT T  ? T T                 T F  F T F F
                         *    *   *                 *      *   *

   Valuations Discovered

             P=T       P=T                 P=F         P=T
             Q=F       Q=T or F            Q=T         Q=T
                                                       R=F

   Notice in the second example a value for Q was not found.  However,
   upon closer examination it should become apparent that's because Q's value
   doesn't matter; both T and F for Q make the formula T.  So there are two
   valuations on which the formula is T.  In both P is T, but Q is T in one
   and F in the other.

   To test if a wff is contingent the process must be performed once with
   T under the main operator, and once with F.  The wff is contingent if
   and only if at least one valuation of the proposition symbols that makes
   the main operator T is found, and at least one valuation of the
   proposition symbols that make the main operator F is found.

Fast Truth-Table Study of A Set of WFFs
---------------------------------------

   We can use the same method to test a set of wffs for consistency or
   inconsistency by setting the main operators all to T (or all to F).
   The only extra note here is that step 3 now works *across* WFFs.
   That is, upon finding the value of a proposition symbol in one wff
   write that value under all instances of the proposition symbol
   in each wff in the set.

   Example  Test each pair of wffs for consistency

         1.  P ∧ Q    -(- P ∨ - Q)             P ∧ Q    -P ∨ -Q
               T      T                          T         T
   
         2.  P ∧ Q    -(- P ∨ - Q)             P ∧ Q    -P ∨ -Q
             T T T    T     F                  T T T       T  
   
         3.  P ∧ Q    -(- P ∨ - Q)             P ∧ Q    - P ∨ - Q
             T T T    T F   F F                T T T    F T T F T
                                               *   *        
         4.  P ∧ Q    -(- P ∨ - Q)             inconsistent
             T T T    T F T F F T
             *   *        *     *
             consistent

             P=T
             Q=T
   
Fast Truth-Table Study of A Sequent
-----------------------------------

   To test a sequent, test if it is invalid by setting each premise's
   main operator to T and the conclusion's to F.  Then work backwards exactly
   as for a set of wffs.  If no contradiction is obtained, it is indeed
   possible for the premises to be T and the conclusion F, as initially
   assumed; therefore, the argument is invalid.  On the other hand,
   if a contradiction is obtained, then the argument is valid.
      
   Example  Test the sequent for validity

         1.  - P → (Q ∨ R), - Q  ⊢   R → P
                 T          T          F

         2.  - P → (Q ∨ R), - Q  ⊢   R → P
                 T          T F      T F F

         3.  - P → (Q ∨ R), - Q  ⊢   R → P
               F T  F   T   T F      T F F

         4.  - P → (Q ∨ R), - Q  ⊢   R → P
             T F T  F T T   T F      T F F
                 *          *          *

   The search succeeded in finding a set of values that make all the
   premises T and the conclusion F.  So the argument is invalid.

   Example  Test the sequent for validity

         1.  P → (Q ∨ R), Q → S, P  ⊢  - R → S
               T            T    T         F

         2.  P → (Q ∨ R), Q → S, P  ⊢  - R → S
               T            T    T     T   F F

         3.  P → (Q ∨ R), Q → S, P  ⊢  - R → S
             T T            T F  T     T F F F

         4.  P → (Q ∨ R), Q → S, P  ⊢  - R → S
             T T    T F   F T F  T     T F F F

         5.  P → (Q ∨ R), Q → S, P  ⊢  - R → S
             T T  F T F   F T F  T     T F F F
                    ?

   We've discovered a contradiction.  The highlighted disjunction can't be
   T if both Q and R are F.  Therefore, the form is valid.

Truth-Trees
===========

   Decidability

   If there is an algorithm for determining whether an argument form
   expressible in a propositional logic is valid, then that system is
   DECIDABLE.  Truth-tables and fast truth-tables both constitute such
   algorithms.  Therefore, the logic is decidable.  However, those methods
   can become impractical when the set of proposition symbols starts to grow.
   Truth-trees provide a more efficient algorithm for performing the same
   tasks.

   Truth-Trees

   Given a set of wffs, a TRUTH-TREE is an exhaustive search for ways
   in which all the wffs can be true.  The nodes of the tree will each have
   a list of one or more wffs.  A CLOSED PATH is any path that's terminated
   by '⊥'.  So, an OPEN PATH is any path that's not so terminated.

   Procedure

   1.  Write down a vertical list of the wffs to be tested.  This list forms
       the root of the tree, so place it at the top of the page.

   2.  Repeatedly apply the following rules in any order.  The tree
       is completed when all paths are closed or no additional rules can
       be applied.

   Note that while the order rules are applied does not matter, to keep the
   tree smaller, at each step, always apply all non-branching rules before
   applying branching rules.

   A STAR next to a wff indicates it is no longer available to apply rules.

   ====  =====================================================================
   Name  Rule
   ====  =====================================================================
   -     If an open path contains both a formula and its negation, close it
         by placing '⊥' at the bottom of the path.

   --    If an open path contains an unstarred instance of --Φ, star it
         and write Φ at the bottom of every open path below it.

   ∧     If an open path contains an unstarred instance of Φ ∧ Ψ, star it
         and write both Φ and Ψ at the bottom of every open path that contains
         this newly starred wff.

   -∧    If an open path contains an unstarred instance of -(Φ ∧ Ψ), star
         it and split the bottom of each open path containing this newly
         starred wff into two branches, at the end of the first branch write
         -Φ and at the end of the second branch write -Ψ.

   ∨     If an open path contains an unstarred instance of Φ ∨ Ψ, star it
         and split the bottom of each open path containing this newly starred
         wff into two branches, at the end of the first branch write Φ and at
         the end of the second branch write Ψ.

   -∨    If an open path contains an unstarred instance of -(Φ ∨ Ψ), star
         it and write both -Φ and -Ψ at the bottom of every open path that
         contains this newly starred wff.

   →     If an open path contains an unstarred instance of Φ → Ψ, star it
         and split the bottom of each open path containing this newly starred
         wff into two branches, at the end of the first branch write -Φ and
         at the end of the second branch write Ψ.

   -→    If an open path contains an unstarred instance of -(Φ → Ψ),
         star it and write both Φ and -Ψ at the bottom of every open path
         that contains this newly starred wff.

   ↔     If an open path contains an unstarred instance of Φ ↔ Ψ, star
         it and split the bottom of each open path containing this newly
         starred wff into two branches, at the end of the first write both
         Φ and Ψ, and at the end of the second write both -Φ and -Ψ.

   -↔    If an open path contains an unstarred instance of -(Φ ↔ Ψ), star
         it and split the bottom of each open path containing this newly
         starred wff into two branches, at the end of the first write both
         Φ and -Ψ, and at the end of the second write both -Φ and Ψ.
   ====  =====================================================================

   These rules can also be expressed in diagrams.

           +---------------------------+---------------------------+         
           | ========================= | ========================= |
           |             -             |            --             |
           | ========================= | ========================= |
           |             Φ             |          * --Φ            |
           |            -Φ             |         --------          |
           |          -------          |             Φ             |
           |             ⊥             |                           |
           |                           |                           |
           | ========================= | ========================= |           
           |             ∧             |            -∧             |
           | ========================= | ========================= |
           |         * Φ ∧ Ψ           |        * -(Φ ∧ Ψ)         |
           |          -------          |        -----------        |
           |             Φ             |           /     \         |
           |             Ψ             |         -Φ       -Ψ       |
           |                           |                           |
           | ========================= | ========================= |
           |             ∨             |            -∨             |
           | ========================= | ========================= |
           |         * Φ ∨ Ψ           |        * -(Φ ∨ Ψ)         |
           |          -------          |         -----------       |
           |           /   \           |             -Φ            |
           |          Φ     Ψ          |             -Ψ            |
           |                           |                           |
           | ========================= | ========================= |
           |             →             |            -→             |
           | ========================= | ========================= |
           |         * Φ → Ψ           |       * -(Φ → Ψ)          |
           |          --------         |        -----------        |
           |           /    \          |             Φ             |
           |         -Φ      Ψ         |            -Ψ             |
           |                           |                           |
           | ========================= | ========================= |
           |            ↔              |           -↔              |
           | ========================= | ========================= |
           |        * Φ ↔ Ψ            |       * -(Φ ↔ Ψ)          |
           |         ---------         |        -----------        |
           |          /     \          |          /     \          |
           |         Φ      -Φ         |         Φ       -Φ        |
           |         Ψ      -Ψ         |        -Ψ        Ψ        |
           |                           |                           |
           +---------------------------+---------------------------+

Truth-Tree Analysis
===================

Truth-Tree Study of A Single WFF
--------------------------------

   To test a single wff using a truth-tree, treat the wff as the set
   of formulas.  Then conduct the search process.

   If the completed tree for one wff contains no open paths, then the
   wff is inconsistent.  If it contains one or more open paths, the wff
   is consistent.  If it contains two or more open paths, then the wff is
   either tautological or contingent.  To find out which construct a second
   tree for the negation of the original wff.  The wff is tautological if and
   only if its negation is inconsistent.  Otherwise, it is contingent.

         =============   ==========================   ===========
         Condition       wff                          -wff
         =============   ==========================   ===========
         0  open paths   inconsistent                 tautologous
         1+ open paths   consistent                   contingent
         2+ open paths   tautologous or contingent    contingent
         =============   ==========================   ===========

Truth-Tree Study of A Set of Wffs
---------------------------------

   To test a set of wffs using a truth-tree, list vertically the wffs to form
   the root.  Then conduct the search process by applying the above rules
   in any order.

   The set of wffs is truth-functionally consistent if the tree has at least
   one open path.  If the tree has no open paths, the set of wffs
   is inconsistent.

         =============   ==========================
         Condition       wff Set
         =============   ==========================
         0  open paths   inconsistent
         1+ open paths   consistent
         =============   ==========================

Truth-Tree Study of A Sequent
-----------------------------

   To test an argument form for validity using a truth-tree, construct
   a list consisting of the argument's premises and negated conclusion.
   Construct the tree as usual.

   When the tree is complete, assess the results.  If all paths
   are closed then the argument form is valid.

   Any open paths of a finished tree for an argument form show all the
   counterexamples to that form.  Where a negated proposition symbol
   is F, and an unnegated proposition symbol is T.

         =============   ==========================
         Condition       Premises & -Conclusion
         =============   ==========================
         0  open paths   valid
         1+ open paths   Invalid w/ counterexamples
         =============   ==========================

   Example

   Let's test the argument P → Q, -Q ⊢ -P.  Begin by listing the assumptions
   and negated conclusion.

                             P → Q
                             - Q
                             - - P

   We can either apply the → rule or the -- rule.  The former is a
   branching rule so we'll apply the non-branching --rule first.

                             P → Q
                             - Q
                           * - - P
                             P

   Next apply the → rule

                           * P → Q
                             - Q
                           * - - P
                             P
                           /       \
                         /           \
                       - P             Q

   Notice P and -P on the first branch, also notice -Q and Q on the second
   branch.  According to the - rule we need to close these branches.

                           * P → Q
                             - Q
                           * - - P
                             P
                           /       \
                         /           \
                       - P             Q
                        ⊥              ⊥

   Since all paths are closed no more rules can be applied.  Therefore the
   tree is completed.  The table above says that since there are 0 open paths
   the argument is valid.


----------------------
Propositional Calculus
----------------------

Formal Proofs
=============

Direct Proofs
-------------

   PROOF

      a non-circular, unambiguous, deductive argument.

   QED
   
      It is customary (though not necessary) to conclude the proof with the 
      letters QED (QUOD ERAT DEMONSTRANDUM; Latin for "what was to be shown");
      which signals to the reader that the proof has been completed
      successfully.  I will also precede the proof with the word 'Proof'
      so the two surround the proof and serve similar roles to a pair
      of braces in programming.

   CALCULUS (aka FORMAL DEDUCTIVE SYSTEM)

      a set of rules that describe valid inferences for a given
      formal language.

   FORMAL PROOF (FORMAL DERIVATION)

      Given a sequent P1, P2, ...  ⊢  C; a FORMAL PROOF is a list
      of the steps inferred from the premises to derive C using the rules
      of a calculus.

   A TWO-COLUMN PROOF is a formal proof laid out in a list-like fashion in
   two parallel columns such that the first column contains a line number
   (1, 2, 3, ...) followed by a proposition, the second column holds
   a justification for writing that proposition.  The justification
   is the name of an inference rule, preceded by citations.  The citations
   are a set of any line numbers of the premises to which that rule was
   applied.  All propositions in the formal proof take the form of wffs.

            P → (Q ∧ R), P  ⊢  Q
            Proof
            01.   P → (Q ∧ R)      Assumption
            02.   P                Assumption
            03.   Q ∧ R            1,2 Conditional Elimination
            04.   Q                3 Conjunction Elimination
            QED

   It is customary to begin the proof by listing the premises seen here in
   steps 1 and 2.  Notice that the justification for those two steps
   is 'ASSUMPTION', which is another word for 'premise'.  Step 3 makes use of
   steps 1 and 2, and so the justification begins by citing those steps by
   writing '1,2'.  'Conditional Elimination' is the name of the inference rule
   applied to steps 1 and 2 to reach step 3.  For now, do not worry about what
   that means; just understand the structure of the proof.  Step 4 applies a
   rule called 'Conjunction Elimination' to step 3, resulting in the wff 'Q'.
   Since Q is the conclusion form of the sequent and the justified formula
   on step 4. the proof has completed successfully.  Hence, the proof is
   closed with 'QED'.

   Usually, people abbreviate the names of the inference rules within a proof.
   Assumptions are abbreviated as 'A'.  For each truth-functional operator,
   there are two inference rules: one called an 'introduction' rule, the other
   called an 'elimination' rule; which are abbreviated 'I' and 'E'
   respectively.  The Conditional Elimination rule used above in step
   3 is abbreviated '→ E'.  Similarly, the Conjunction Elimination rule
   used in step 4 is abbreviated '∧E'.

   A DIRECT PROOF is any formal proof that has no indented steps.

Hypothetical Subordinate Proofs
-------------------------------

   A HYPOTHETICAL SUBORDINATE PROOF or SUBPROOF is a proof nested within
   another proof.  It is analogous to nesting blocks of code in a computer
   program, and similarly, subproofs can be nested to any depth.  Indent
   subproof from the surrounding proof and draw a vertical line just to the
   right of the wffs to signal that something is a subproof.  The first wff
   of a subproof is called the HYPOTHESIS.

            P → Q, -Q  ⊢  -P
            Proof
            01.   P → Q         A            Begin by listing the premises
            02.   -Q            A
            03.   |   P         H (for -I)   Try to prove -P using -I.
            04.   |   Q         1,3 → E      Use steps 1 & 3 to perform →E.
            05.   |   Q ∧ -Q    2,4 ∧I       Use steps 2 & 4 to perform ∧I.
            06.   -P            3-5 -I       use steps 3 to 5 to perform -I.
            QED

   In this example, the A's in the second column of steps 1 and 2 signal
   that those wffs are assumptions.  Line 3 begins a subproof with the
   hypothesis (H).  The content of the parentheses communicates to the
   reader that the goal of this hypothetical proof is to reach a point where
   eventually -I (Negation Introduction) can operate on the hypothesis.
   Line 4 applies → E (Conditional Elimination) to steps 1 and 3, resulting
   in 'Q'.  On line 5, ∧I operates upon steps 2 and 4 producing Q ∧ -Q.  Line
   5 ends the subproof, and line 6 returns our attention to the enclosing
   proof, the main proof.  Recall that the goal of the hypothetical subproof
   was to perform -I; which is now performed on line 6.  Notice the citation
   is a range of steps '3-5', which is the entire subproof.  This says that
   the subproof justifies applying the -I rule to obtain -P, which is the
   conclusion form of the sequent, so the proof completed successfully
   hence the 'QED'.

   Note to be able to write QED, not only must the sequent's conclusion be
   successfully derived, but also it must occur within the main proof's
   sequence, not within a subproof.  That is, all successful subproofs must
   be closed.

Regarding Notation
==================

   A capital Greek letter (Φ, Ψ, Θ, Δ, etc.) denotes any arbitrary formula.

   'Φ(Ψ)' denotes a wff Φ contains one or more occurrences of a sub-wff Ψ.

   'Φ(Θ/Ψ)' denotes the result of replacing one or more occurrences of Ψ in Φ
   with Θ.  Θ/Ψ is read, "Θ replaced one or more occurrences of Ψ".

   'Φ (Θ//Ψ)' like above but indicates replacing all occurrences of Ψ in Φ
   with Θ.  Θ//Ψ is read, "Θ replaced all occurrences of Ψ".

   '( Φ ⊢ Ψ )' denotes a subproof with hypothesis Φ concluding with Ψ.

   '[ ... ]' denotes that the enclosed must exist, be defined or proved
   elsewhere (external to the current proof).

Primitive Inference Rules
=========================

   Following are the basic inference rules.  Some of them have multiple names,
   and the abbreviation for each name is in parentheses.  Use any name
   according to preference.

   ================================  =========================================
   Name (Abbreviation)               Rule
   ================================  =========================================
   Assumption (A)                    Introduce a premise at any step.

   Hypothesis (H)                    Introduce a hypothesis at any step
                                     provided it begins a new subproof.

   Axiom (Ax)                        Introduce an axiom at any step.

   Negation Elimination (-E)         From --Φ, infer Φ.

   Negation Introduction (-I)        From a subproof with hypothesis Φ
      Reductio Ad Absurdum (RAA)     ending in (Ψ ∧ -Ψ), close the subproof,
      Proof By Contradiction (PBC)   and infer -Φ.
      Indirect Proof (IP)

   Conjunction Elimination (∧E)      From Φ ∧ Ψ, infer Φ, or infer Ψ.
      Simplification (Simp)

   Conjunction Introduction (∧I)     From Φ and Ψ, infer Φ ∧ Ψ,
      Conjunction (Conj)             or infer Ψ ∧ Φ.

   Disjunction Elimination (∨E)      From Φ ∨ Ψ, Φ → Θ and Ψ → Θ, infer Θ.
      Proof by Cases (PBC)

   Disjunction Introduction (∨I)     From Φ, infer Φ ∨ Ψ, or infer Ψ ∨ Φ.
      Addition (Add)

   Conditional Elimination (→ E)     From Φ → Ψ and Φ, infer Ψ.
      Modus Ponens (MP)

   Conditional Introduction (→ I)    From a subproof with hypothesis Φ
      Conditional Proof (CP)         and ending Ψ, close the subproof,
                                     then infer Φ → Ψ.

   Biconditional Elimination (↔ E)   From Φ ↔ Ψ, infer Φ → Ψ,
                                     or infer Ψ → Φ.

   Biconditional Introduction (↔ I)  From Φ → Ψ and Ψ → Φ, infer Φ ↔ Ψ.

   Equivalence Substitution (EQ)     From [ Φ ↔ Ψ ], and Θ(Φ), infer Θ(Ψ/Φ);
                                     or from [ Φ ↔ Ψ ] and Θ(Ψ),
                                     infer Θ(Φ/Ψ).
   ================================  =========================================

   These rules are sometimes expressed in diagrams.  Horizontal lines
   denote 'infer', vertical lines denotes subproofs.  Some rules have
   multiple forms.

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  A                            |  H                            |
      | ============================= | ============================= |
      |                               |                               |
      |  ---                          |  -------                      |
      |   Φ   (Φ is a premise)        |   |   Φ   (Φ is a hypothesis) |
      |                               |                               |
      | ============================= | ============================= |
      |  -E                           |  -I                           |
      | ============================= | ============================= |
      |   --Φ                         |   |   Φ                       |
      |  -------                      |   |   ...                     |
      |   Φ                           |   |   Ψ ∧ -Ψ                  |
      |                               |  --------------               |
      |                               |   -Φ                          |
      |                               |                               |
      | ============================= | ============================= |
      |  ∧E                           |  ∧I                           |
      | ============================= | ============================= |
      |   Φ ∧ Ψ    Φ ∧ Ψ              |   Φ        Φ                  |
      |  -------  -------             |   Ψ        Ψ                  |
      |   Φ        Ψ                  |  -------  -------             |
      |                               |   Φ ∧ Ψ    Ψ ∧ Φ              |
      |                               |                               |
      | ============================= | ============================= |
      |  ∨E                           |  ∨I                           |
      | ============================= | ============================= |
      |   Φ ∨ Ψ                       |   Φ        Φ                  |
      |   Φ → Θ                       |  -------  -------             |
      |   Ψ → Θ                       |   Φ ∨ Ψ    Ψ ∨ Φ              |
      |  --------                     |                               |
      |   Θ                           |    (Ψ is any wff whatever)    |
      |                               |                               |
      | ============================= | ============================= |
      |  → E                          |  → I                          |
      | ============================= | ============================= |
      |   Φ → Ψ                       |   |   Φ                       |
      |   Φ                           |   |   ...                     |
      |  ---------                    |   |   Ψ                       |
      |   Ψ                           |  ---------                    |
      |                               |   Φ → Ψ                       |
      |                               |                               |
      | ============================= | ============================= |
      |  ↔ E                          |  ↔ I                          |
      | ============================= | ============================= |
      |   Φ ↔ Ψ      Φ ↔ Ψ            |   Φ → Ψ      Φ → Ψ            |
      |  ---------  ---------         |   Ψ → Φ      Ψ → Φ            |
      |   Φ → Ψ      Ψ → Φ            |  ---------  ---------         |
      |                               |   Φ ↔ Ψ      Ψ ↔ Φ            |
      |                               |                               |
      | ============================= | ============================= |
      |  EQ (Equiv. Substitution)     |  Ax (Axiom)                   |
      | ============================= | ============================= |
      |   [ Φ ↔ Ψ ]    [ Φ ↔ Ψ ]      |                               |
      |   Θ(Φ)           Θ(Ψ)         |  ---                          |
      |  -------------  ------------- |   Φ   (Φ is an axiom)         |
      |   Θ(Ψ/Φ)         Θ(Φ/Ψ)       |                               |
      |                               |                               |
      +-------------------------------+-------------------------------+

Other Justifications
====================

   The following aren't inference rules but do appear in proofs as
   justification for deriving a wff.

   ================================  =========================================
   Name (Abbreviation)               Rule
   ================================  =========================================
   Definition Substitution (DEF)     From [ Φ =df Ψ ], Θ(Φ), infer Θ(Ψ/Φ);
                                     and from [ Φ =df Ψ ], Θ(Ψ), infer Θ(Φ/Ψ).
   ================================  =========================================

   Notice that in the rules the definition is in brackets '[' and ']'.
   Brackets indicate that the definition needs to exist but doesn't need
   to appear in the proof.

Derived Inference Rules
=======================

   Use any proved sequent as a new inference rule.  If a sequent is proved
   valid, then all instances of the sequent are also valid.  The following
   are important derived rules.

   ================================  =========================================
   Name (Abbreviation)               Sequent
   ================================  =========================================
   Reiterate (RE)                    P  ⊢  P
   Ex Falso Quodlibet (EFQ)          P, -P  ⊢  Q    (Q is any wff whatever)
   Modus Tollens (MT)                P → Q, -Q  ⊢  -P
   Hypothetical Syllogism (HS)       P → Q, Q → R  ⊢  P → R
   Absorption (Abs)                  P → Q  ⊢  P → (P ∧ Q)
   Constructive Dilemma (CD)         P ∨ Q, P → R, Q → S  ⊢  R ∨ S
   Destructive Dilemma (DD)          P → Q, R → S, -Q ∨ -S  ⊢  -P ∨ -Q
   Bidirectional Dilemma (BD)        P → Q, R → S, P ∨ -S  ⊢  Q ∨ -R
   Disjunctive Syllogism (DS)        P ∨ Q, -P  ⊢  Q
   Disjunctive Syllogism (DS)        P ∨ Q, -Q  ⊢  P
   Theorem (THM)                     [ ⊢ P ]  ⊢  P
   ================================  =========================================

Theorems
========

   A theorem is an unconditionally true proposition.  For a sequent
   P1,P2,... ⊢ C the conclusion is true conditionally upon the truth
   of the assumptions.  Hence, a theorem being unconditionally true, simply
   has no assumptions or undischaraged hypotheses.  Theorems are the
   tautologies of propositional logic.  A sequent for a theorem Φ has the
   form below.  Such is provable by starting its proof with a hypothesis or
   with a previously proved theorem.

         ⊢ Φ

Equivalences
============

   An equivalence is a theorem whose main operator is a biconditional.
   The following are important equivalences.

         ⊢ Φ ↔ Ψ

   ================================  =========================================
   Name (Abbreviation)               Sequent
   ================================  =========================================
   Double Negation (DN)              ⊢  P ↔ --P
   Idempotence (IDEM)                ⊢  P ↔ (P ∧ P)
   Idempotence (IDEM)                ⊢  P ↔ (P ∨ P)
   Transposition (TRANS)             ⊢  (P → Q) ↔ (-Q → -P)
   Material Implication (MI)         ⊢  (P → Q) ↔ (-P ∨ Q)
   Association (ASSOC)               ⊢  (P ∧ (Q ∧ R)) ↔ ((P ∧ Q) ∧ R)
   Association (ASSOC)               ⊢  (P ∨ (Q ∨ R)) ↔ ((P ∨ Q) ∨ R)
   Commutation (COM)                 ⊢  (P ∧ Q) ↔ (Q ∧ P)
   Commutation (COM)                 ⊢  (P ∨ Q) ↔ (Q ∨ P)
   Commutation (COM)                 ⊢  (P ↔ Q) ↔ (Q ↔ P)
   Exportation (EXP)                 ⊢  ((P ∧ Q) → R) ↔ (P → (Q → R))
   Distribution (DIST)               ⊢  (P ∧ (Q ∨ R)) ↔ ((P ∧ Q) ∨ (P ∧ R))
   Distribution (DIST)               ⊢  (P ∨ (Q ∧ R)) ↔ ((P ∨ Q) ∧ (P ∨ R))
   DeMorgan's law (DM)               ⊢  -(P ∧ Q) ↔ (-P ∨ -Q)
   DeMorgan's law (DM)               ⊢  -(P ∨ Q) ↔ (-P ∧ -Q)
   Material Equivalence (ME)         ⊢  (P ↔ Q) ↔ ((P → Q) ∧ (Q → P))
   Material Equivalence (ME)         ⊢  (P ↔ Q) ↔ ((P ∧ Q) ∨ (-P ∧ -Q))
   ================================  =========================================

   Appendix C contains the proofs of all of these derived forms, theorems and
   equivalences.

Consequence and Non-Consequence
===============================

   PROOF OF CONSEQUENCE

      Any proof that demonstrates that some wff C is derivable by applying
      a series of inference rules.  The example proofs presented so far are
      all proofs of consequence.

   PROOF OF NON-CONSEQUENCE (aka REFUTATION PROOF)

      A demonstration that some wff C is *not* derivable, by any number
      of applications of inference rules.

   Construct a proof of non-consequence by first listing the premises,
   then begin a subproof by hypothesizing the negation of the conclusion.
   Proceed by attempting to reduce everything to atomic and negated atomic
   formulas.  Proceed until no additional rules can be applied.  Since
   the conclusion is never reached the proof is uncompleted, so it's not
   terminated with QED.

         Example

            P → Q, -P  ⊢  -Q
         Proof
         01.   P → Q         A
         02.   -P            A
         03.   |   Q         H (for -I)

   Once finished, the valuations are readable directly off the proof.
   The above proof tells us that the counterexamples are where P is false
   (due to occurring negated in step 2), and Q is true (due to occurring
   unnegated in step 3).  If a proposition symbol doesn't appear negated
   or unnegated, then it is truth-value does not matter.  We can verify
   this counterexample with a truth-table. 

          P Q | P → Q , - P  ⊢  - Q
         ============================
          F F | F T F | T F  |  T F
          F T | F T T | T F  |  F T  <==
          T F | T F F | F T  |  T F
          T T | T T T | F T  |  F T
                  *     *       *

   The highlighted row is the counterexample (all true premises but
   false conclusion).  On that row P and Q have the same truth-values as
   determined by the proof of non-consequence.


Defining ⊥ Into Propositional Logic/Calculus
============================================

   Some calculus implementations use ⊥ (the CONTRADICTION SYMBOL) to cut down
   on tedium and improve the readability of proofs.  Applications of -I are
   often preceded by ∧I, but the resulting conjunction can be quite long.
   Since EFQ infers any wff from two contradictory propositions; one can
   always infer 'P ∧ -P' instead of a long conjunction.  But the following
   definition is even briefer.

         ⊥  =df  P ∧ -P

   The following new inference rules facilitate its use.
  
   ================================  =========================================
   Name (Abbreviation)               Sequent
   ================================  =========================================
   ⊥ Introduction (⊥ I)              P, -P  ⊢  ⊥
   ⊥ Elimination (⊥ E)               (P ⊢ ⊥)  ⊢  -P
   ================================  =========================================

Derivation Strategies
=====================

   There's no foolproof algorithm that can be followed which will derive
   a proof every time.  However there are some rules of thumb to assist in
   the task.

   1.  (Conclusion) If the conclusion has one of these forms,

         Φ ∧ Ψ       try to derive each conjunct, then apply ∧I;

         Φ ∨ Ψ       try to derive one disjunct, then apply ∨I;

         Φ → Ψ       hypothesize Φ, try to derive Ψ, close the subproof,
                     then apply → I;

         Φ ↔ Ψ       try to derive Φ → Ψ, and derive Ψ → Φ, then apply ↔ I;

   2.  (Premise) If a premise has the following form

         Φ ∨ Ψ       try to derive two conditionals Φ → Θ and Ψ → Θ to obtain
                     the needed conclusion Θ using ∨ E;

   3.  (Reductio) If the conclusion has one of these forms,

         - Φ         hypothesize Φ (unnegated), try to derive ⊥ or derive
                     a contradiction, lastly apply -I or ⊥ E;

         Φ           hypothesize -Φ, try to derive ⊥ or contradiction, then
                     apply -I and finally -E.


--------
Concerns
--------

Semantic Soundness & Completeness of Propositional Calculus
===========================================================

   A calculus is SEMANTICALLY SOUND if and only if for any consistent set
   of premises, there is no sequence of inference rule applications that can
   derive a wff that's not a logical consequence of those premises.

   A calculus is SEMANTICALLY COMPLETE if and only if a given conclusion Φ
   logically follows from a set of premises, then there exists at least one
   proof of Φ that has a finite number of steps.

   Propositional calculus is semantically sound and semantically complete.
   We do not prove these theorems here, but it is handy to know of them.
   The calculus derives all and only valid conclusions from any given set
   of premises.

The Unnatural Conditional
=========================

   A serious concern with the propositional logic conditional is that
   it only denotes a small part of what English if/then statements can
   express.  Hence → is quite controversial, with many doubting that the
   full power of the if/then statement can ever be captured in a formal
   logical system.  Moreover, the propositional logic conditional can
   produce some surprising results.  Let us revisit a previous example.

         K → F         if you keep up the good work then you'll go far.

   Now let's consider what happens if we take it's negation.

         -(K → F)      it's false that if you keep up the work you'll go far
         -(-K ∨ F)     Material Implication
         K ∧ -F        DeMorgan's

   The conclusion says, "you keep up the good work and you don't go far."
   Does this sound like the negation of the original unnegated conditional?
   Many say it does not.

Relevance
=========

   Some people have concerns over the inference rules and namely ∨I,
   and H because they provide a way for an arguer to introduce any statement
   whatever into the proof relevant or not.   Their particular concern
   is that this exposes a severe problem of the calculus.  Some have
   gone so far as to introduce new systems of logic in attempts to remove
   or "fix" such rules.

   The classical perspective is that these issues do not matter because the
   conclusions found by FOC= always do conform to the definition of a valid
   deductive argument.  If one asserts that Φ is true, then referring back
   to the valuation function v for disjunction shows that no matter what value
   of Ψ is introduced, Φ ∨ Ψ will still be true simply because Φ is true.
   While for H, it does not matter what is hypothesized.  If some hypothesis
   Θ is inconsistent with the premises Θ will be negated after the subproof
   is closed.  However, if Θ is not inconsistent with the premises, then by
   definition, it is consistent relevant or not, and who is to say what
   is and is not relevant.  Classical logic regards these as arguments
   adequate to justify the inclusion and current formulation of these rules.

Refuting Dilemmas
=================

   A dilemma is a disjunctive premise that states precisely two options.
   Being IN A DILEMMA or IMPALED BY THE HORNS OF A DILEMMA means that
   the person presented with the dilemma is confronted with a choice between
   two undesirable options.  GRASPING THE BULL BY THE HORNS is proving one
   of the disjuncts true.  ESCAPING BETWEEN THE HORNS is to prove the
   disjunction false by proving a third option or proving that both disjuncts
   are false.


===============
Predicate Logic
===============

Predicate logic introduces a way to analyze proposition symbols down into
more basic components.


--------
Language
--------

Lexemes
=======

   Non-Logical Symbols

      Object Symbols
         Constants:             a...t
      Predicate Symbols:        A...Z
      Association Symbols:      (, )

   Logical Symbols

      Truth-Function Symbols:   -, ∧, ∨, →, ↔

Grammar
=======

   It's conventional to use capital Greek letters to stand for arbitrary
   wffs, and lower-case Greek letters to stand for arbitrary constant
   object symbols.

   An ATOMIC FORMULA consists of a Predicate symbol followed by zero
   or more constant object Symbols.

   Formation Rules for wffs
   1.  Every atomic formula is a wff;
   2.  if Φ is a wff, then so is -Φ;
   3.  if Φ, Ψ are wffs, then so are (Φ ∧ Ψ), (Φ ∨ Ψ), (Φ → Ψ), (Φ ↔ Ψ);
   4.  Nothing else is a wff.


---------
Semantics
---------

Model
=====

   Roughly, a MODEL is a limited representation of some state of affairs
   expressed using set theory.  Since a set theory model can be a mathematical
   representation of something about the actual world, we can for our current
   purposes, informally regard the actual world as the model.
  
The Dictionary
==============

   It is helpful to create a dictionary before constructing an atomic formula.
   When investigating a new situation with logic, a dictionary clarifies
   the meanings of the predicate and constant symbols.  A dictionary lists
   the symbols and what they denote in the current universe of discourse.
   By convention, letters towards the end of the alphabet (u,v,w,x,y,z) may
   serve as placeholders, allowing us to define a predicate's meaning more
   clearly.

Properties
----------

   A property asserts that some object is a member of some particular
   set which when combined denotes a characteristic of the object.

         Dictionary
         ----------------
         Object Symbols        Predicates
         a,   Alice            Bx,   x is blond
         b,   Bob              Kx,   x is brunette
         c,   Charlie          Sx,   x is scaled

   Construct an atomic formula by substituting object symbols in place
   of place-holders in a predicate definition.

         Ba,  Alice is blond.
         Kb,  Bob is brunette.
         Sc,  Charlie is scaled.

         Sc → -(Bc ∨ Kc)
         If Charlie is scaled then Charlie is neither blond nor brunette.

   Properties always have just one place-holder in the dictionary.
   Any property Pc means, c ∊ P (i.e., c is in set P), or c has property P.

Relations
---------

   Much as it sounds, a relation denotes a relationship between two or more
   objects.  Let us expand the dictionary:

         2-Place Predicates
         Txy,  x is taller than y.

   'Tall', while a property, would not be a suitable predicate for logic
   because 'tall' is vague.  E.g., a tall building and a tall glass of water
   do not mean the same thing.  However, 'taller' is objective, making
   it ideal for logical reasoning.

         (Tab ∧ Tbc) → Tac
         If Alice is taller than Bob and Bob is taller than Charlie,
            then Alice is taller than Charlie.

   Any predicate with more than 1-place expresses a relation.

         3-Place Predicates
         Bxyz,     x is between y and z

         Bbac,     Bob is between Alice and Charlie

         Bbac → (-Babc ∧ -Bcab)
         If Bob is between Alice and Charlie then, Alice isn't between Bob
         and Charlie and Charlie isn't between Alice and Bob.

   Any arity is acceptable for a predicate including 0.  0-place predicates
   are functionally equavalent to proposition symbols.

         0-Place Predicates
         R,        it's raining
         W,        the ground is wet

         R → W
         If it's raining then the ground is wet.

Translation Hints
=================

              +-----------------------------------------------+             
              | ============================================= |
              | 0-Place Predicate (Proposition Symbols)       |
              | ============================================= |
              | S,    Zelda is at the store.                  |
              | C,    cake is delicious.                      |
              | R,    It's raining.                           |
              |                                               |
              | ============================================= |
              | 1-Place Predicates (Properties)               |
              | ============================================= |
              | Px,   x is P, x in set P                      |
              |                                               |
              | Ms,   Susy is a mammal.                       |
              | Dr,   Rex is a dog.                           |
              | Qp,   Palmer is quiet.                        |
              | En,   n is an even number.                    |
              |                                               |
              | ============================================= |
              | 2-Place Predicates (Relations)                |
              | ============================================= |
              | Pxy,  x,y are related through P               |
              |                                               |
              | Sta,  Tom sees Agatha.                        |
              | Tab,  Alice is taller than Bob.               |
              | Pac,  lines a and c are perpendicular.        |
              | Los,  one is less than six.                   |
              |                                               |
              | ============================================= |
              | 3-Place Predicates (Relations)                |
              | ============================================= |
              | Pxyz,  x,y,z are related through P            |
              |                                               |
              | Bxyz,  x is between y and z                   |
              | Pxyz,  x purchased y from z                   |
              | Stsb,  Tom saw Sally steal from Barbara.      |
              |                                               |
              +-----------------------------------------------+

Truth-Tables
============

   Technically, truth-tables can be constructed for predicate logic.
   However, the number of atomic formulas gets very large very fast
   which makes tables impractical.

Truth-Trees
===========

   Truth trees for predicate logic are constructed according to the same
   rules as trees for propositional logic.


------------------
Predicate Calculus
------------------

   The calculus for constructing proofs in predicate logic is largely
   unmodified from propositional calculus.  The primary difference
   is in the definition of an atomic formula.

         Dictionary
         ----------
         Constants            Predicates
         m,    Merlin         Axy,   x abandons y
         a,    Arthur
         g,    Guinevere

         Ama → Amg, -Amg  ⊢  -Ama

   Here 'Ama' and 'Amg' are distinct atomic formulas.


===========================
First-Order Predicate Logic
===========================

   FOL introduces new concepts which build upon predicate logic enabling
   the expression of, among other things, the Aristotelian proposition
   forms which denote relations among sets.

         All P is Q.
         No P is Q.
         Some P is Q.
         Some P is not Q.

   FOL brings in quantifiers, which denote quantities, and variable object
   symbols which denote arbitrary objects.


------------------
Regarding Notation
------------------

   The following notations are used in the formal descriptions that follow.

   A capital Greek letter (Φ, Ψ, Θ, Δ, etc.) denotes any arbitrary formula,
   and a lower case Greek letter (α, β, δ, etc.) denotes any arbitrary
   object symbol.

   Φ(Ψ) denotes a wff Φ contains one or more occurrences of a sub-wff Ψ.

   Φ(Θ/Ψ) denotes the result of replacing one or more occurrences of Ψ in Φ
   with Θ.  Θ/Ψ is read, "Θ replaced one or more occurrences of Ψ".

   Φ (Θ//Ψ) like above but indicates replacing all occurrences of Ψ in Φ with
   Θ.  Θ//Ψ is read, "Θ replaced all occurrences of Ψ"

   Φ(β),Φ(α/β),Φ(α//β), similar to the above but α and β are object symbols.

   ( Φ ⊢ Ψ ), denotes a subproof with hypothesis Φ concluding with Ψ.

   [ ... ] denotes that the enclosed must exist, be defined or proved
   elsewhere (external to the current proof).


--------
Language
--------

Lexemes
=======

   Non-Logical Symbols
      Object symbols
         constants:            a...t
         variables:            u...z
      Predicate Symbols:       A...Z
      Association Symbols:     (, )

   Logical Symbols
      Truth-Function Symbols:  -, ∧, ∨, →, ↔
      Quantifiers
         universal:            ∀
         existential:          ∃

Grammar
=======

   An ATOMIC FORMULA is a predicate symbol followed by zero or more
   constants.

   1.  Every atomic formula is a wff;
   2.  if Φ is a wff, then so is -Φ;
   3.  if Φ,Ψ are wffs, then so are (Φ ∧ Ψ), (Φ ∨ Ψ), (Φ → Ψ), (Φ ↔ Ψ);
   4.  if Φ(α) (α is a constant object in a wff Ψ) is a wff,
       then ∀xΦ(x/α) and ∃xΦ(x/α) are wffs (where x is some new
       variable not already in Φ);
   5.  Nothing else is a wff.


---------
Semantics
---------

Predicates & Constants
======================

   Truth-functions, predicates, and constants continue to work as presented.
   The one note, in consistency with predicate logic, is that use of letters
   such as x,y,z within a dictionary are not variables but placeholders.

         Dictionary (where x,y,z are placeholders)
         -----------------------------------
         Px,    x has some property P, x in set P, x is P.
         Pxy,   x has some relation P to y
         Bxyz,  x has some relation P to y and z.

         Proof (where x,y,z are variables)
         01.   ∀x(Mx → Vx)        A
         02.   Ma                 A
         03.   Ma → Va            2 ∀ E (a/x)
         04.   Va                 3,4 → E
         QED

Quantifiers & Variables
=======================

   A quantifier expression is a quantifier followed by a variable symbol
   and then a sub-wff.  The quantifier is said to BIND the variable, or the
   variable is BOUND to the quantifier.

         ∀xΦ       For every object x in the universe of discourse, Φ.

         ∃xΦ       There exists at least one object x in the universe
                   of discourse such that, Φ.

   Once the variable is bound, it can be used within the wff.  In this
   formulateion of FOL a variable in a wff is always bound provided formation
   rules are applied correctly.

         Dictionary
         ---------------------
         Predicates
         Cx,   x is a cat
         Dx,   x is a dog
         Mx,   x is a mammal
         Sx,   x likes to swim
         Lxy,  x loves y

         ∀xCx,     For each x in the universe of discourse, x is a cat.
                   = Everything is a cat.

         ∃xDx,     There exists x in the universe such that, x is a dog.
                   = Some (one or more) dogs exist.

Existential Import
------------------

   ∃xΦ has existential import.  It asserts that at least one thing exists
   in the universe of discourse.

         ∃xSx      There exists some object in the universe  of discourse that
                   likes to swim.

   ∀x lacks existential import.  It makes no claim that something actually
   exists in the universe of discourse.

         ∀xSx      Everything in the universe of discourse (if anything exists
                   at all) likes to swim.

Scope
-----

   SCOPE refers to the substring in a quantified wff over which the
   quantifier-variable binding holds.  In FOL, this substring
   is the complete wff which follows the quantifier; if the expression
   that follows is in parentheses then the scope ranges from the opening
   to the matching closing parenthesis.

         ∀x(Dx → Mx) ∧ ∃xRx

   In this expression, the x bound by ∀ is in scope between the pair
   of parentheses.  The x used with the expression Rx is a different
   x, which is bound by ∃ and whose scope is only the expression 'Rx'.

Free Variables
--------------

   A FREE VARIABLE is a variable that appears within a wff but is not
   bound by a quantifier.  This formulation of FOL does not allow
   free variables provided the formation rules are applied correctly.
   However, some implementations do allow free variables.  Be aware that
   a free variable does not denote anything.  While a variable bound
   by ∀ denotes *any* arbitrary object in the universe.  A variable
   bound by ∃ denotes at least one object in our universe though
   we may not know which.

Single Quantifiers
==================

   A universal quantifier is nearly always paired with the conditional.

         ∀x(Cx → Mx),    For each object x in the universe,
                           if x is a cat then x is a mammal.
                         = all cats are mammals.

         ∀x(Cx → -Sx),   For each object x in the universe,
                           if x is a cat then x doesn't like to swim.
                         = no cats like to swim.

   An existential quantifier is nearly always paired with conjunction.

         ∃x(Dx ∧ Mx),    There's at least one object x in the universe
                           such that, x is a dog and x is a mammal.
                         = Some dogs are mammals.

         ∃x(Dx ∧ Sx),    There's at least one object x in the universe
                           such that, x is a dog and x likes to swim.
                         = Some dogs like to swim.

   However, this notion of ∀ with →, and ∃ with ∧, isn't arbitrary.
   They are complementary forms.  Consider the following form:

         -∀x(Cx → -Sx)   It's false that no cats like to swim.

   Applying some equivalences to this wff results in a new formula
   that means the same thing.

         ∃x-(Cx → -Sx)   -∀ is equivalent to ∃- 
         ∃x-(-Cx ∨ -Sx)  By material implication
         ∃x(--Cx ∧ --Sx) DeMorgan's
         ∃x(Cx ∧ Sx)     Double Negation
                         = Some cats like to swim.

   Notice that we started with ∀ and →, and just by applying equivalences
   ended with ∃ and ∧.  So ∃ with ∧ follows naturally from the occurrence
   of ∀ with →.  The reverse is also true.  They are complementary forms.

Multiple Quantifiers
====================

   Just as with many other features of FOL, quantifiers can be nested.
   When the same quantifier is repeated, the order of the quantifiers
   doesn't change the meaning of the wff.

         ∀x∀yLxy         Everyone loves everyone (including themselves).
         ∀y∀xLxy         Everyone loves everyone (including themselves).

         ∃x∃yLxy         Someone loves someone (perhaps themselves).
         ∃y∃xLxy         Someone loves someone (perhaps themselves).

   In the first form, ∀x has scope over the following formula which
   is ∀yLxy.  It's similarly the case with the remaining forms.  However,
   if the quantifiers are mixed, the meaning changes depending upon order.

         ∃x∀yLxy         Someone loves everyone (including themselves).
         ∀x∃yLxy         Everyone loves someone (perhaps themselves).

Translation Hints
=================

The Aristotelian Forms
----------------------

   Any interpretation of the Aristotelian forms can be represented in FOL.

   The TRADITIONAL INTERPRETATION grants existential import to all forms.
   The singular forms always denote particular objects in the universe
   so always have existential import.

                                    Quality  
                     +----------------------+------------------------+
                     | Affirmatives         | Negatives              |
      Q +------------+----------------------+------------------------+
      u | Universal  | ∀x(Sx → Px) ∧ ∃xSx   | ∀x(Sx → -Px) ∧ ∃xSx    | < EI
      a |            |                      |                        |
      n | Particular | ∃x(Sx ∧ Px)          | ∃x(Sx ∧ -Px)           | < EI
      t +------------+----------------------+------------------------+
      i | Singular   | Sa                   | -Sa                    | < EI
      t |            | c=e                  | -c=e                   | < EI
      y +------------+----------------------+------------------------+

   The MODERN INTERPRETATION denies existential import to the universals,
   but grants it to particulars,

                                    Quality  
                     +----------------------+------------------------+
                     | Affirmatives         | Negatives              |
      Q +------------+----------------------+------------------------+
      u | Universal  | ∀x(Sx → Px)          | ∀x(Sx → -Px)           |
      a |            |                      |                        |
      n | Particular | ∃x(Sx ∧ Px)          | ∃x(Sx ∧ -Px)           | < EI
      t +------------+----------------------+------------------------+
      i | Singular   | Sa                   | -Sa                    | < EI
      t |            | c=e                  | -c=e                   | < EI
      y +------------+----------------------+------------------------+

   An alternative interpretation might grant EI to the affirmatives, but
   deny it to the negatives.

                                    Quality  
                     +----------------------+------------------------+
                     | Affirmatives         | Negatives              |
      Q +------------+----------------------+------------------------+
      u | Universal  | ∀x(Sx → Px) ∧ ExSx   | ∀x(Sx → -Px)           |
      a |            |                      |                        |
      n | Particular | ∃x(Sx ∧ Px)          | ∃x(Sx ∧ -Px)           |
      t |            |                      |    ∨ -∃xSx v -∃xPx     |
      i +------------+----------------------+------------------------+
      t | Singular   | Sa                   | -Sa                    | < EI
      y |            | c=e                  | -c=e                   | < EI
        +------------+----------------------+------------------------+
                       ^^^^
                        EI

   Another interpretation might grant EI only to the negatives.

                                    Quality  
                     +----------------------+------------------------+
                     | Affirmatives         | Negatives              |
      Q +------------+----------------------+------------------------+
      u | Universal  | ∀x(Sx → Px)          | ∀x(Sx → -Px) ∧ ExSx    |
      a |            |                      |                        |
      n | Particular | ∃x(Sx ∧ Px)          | ∃x(Sx ∧ -Px)           |
      t |            |    ∨ -∃x(Sx ∧ ∃xPx)  |                        |
      i +------------+----------------------+------------------------+
      t | Singular   | Sa                   | -Sa                    | < EI
      y |            | c=e                  | -c=e                   | < EI
        +------------+----------------------+------------------------+
                                              ^^^^
                                               EI

   It's even possible to assign EI to a diagonal pair and deny it to the other
   pair, or deny it to all universals and particulars.

English Quantification
----------------------

   When translating from English, it's usually best to first paraphrase
   a sentence such that it's closer in structure to a wff.

   Quantifier Placement (Default Rule)

         Write the quantifiers in the same order as they occur in English.
         Note that this rule has many exceptions.

Any/Anybody/Anyone/Anything/Anywhere
------------------------------------

   'Any' has different meanings depending upon how it's used.  It can denote
   either quantifier.  Generally, try to rephrase the proposition
   so it doesn't use 'any'.

         Not any...   ->   No...
         If any...    ->   If some...
         Any ...      ->   All...

   In the remaining cases to translate 'any', put ∀ at the beginning
   of the wff regardless of where 'any' occurs in the sentence.

Validity / Valid Formula
========================

   A VALIDITY or VALID FORMULA, like a tautology, is true in all cases,
   however the term is more broad.  Tautology only refers to something being
   true in all cases in virtue of truth-functions.  While 'validity' refers
   to all expressions of this sort.  The following is a valid wff in FOL.

         ∀x-Px  ↔  -∃xPx,    where P is an arbitrary predicate.

Truth-Trees
===========

   Construction of Truth-trees in FOL is similar to how they are constructed
   in predicate logic with the addition of a few extra rules for handling
   the quantifiers and their negated forms.

   ====  =====================================================================  
   Name  Rule
   ====  =====================================================================
   ∀     If ∀xΦ(x) appears on an open path, and α occurs in some wff on
         that path, write Φ(α//x) (the result of replacing each occurrence
         of x in Φ with α) at the bottom of the path.  If no wff containing
         α appears on the path, choose any α .

   -∀    If -∀xΦ(x) appears on an open path, star it and write ∃x-Φ(x)
         at the bottom of every open path that contains the newly
         starred wff.

   ∃     If ∃xΦ(x) appears on an open path, star it.  Choose a constant α
         that doesn't appear on that path and write Φ(α//x) (the results of
         replacing each occurrence of x by α in Φ) at the bottom of every
         open path that contains the newly starred wff.

   -∃    If -∃xΦ(x) appears on an open path, star it and write ∀x-Φ(x)
         at the bottom of every open path that contains the newly
         starred wff.
   ====  =====================================================================

   These rules are often expressed with diagrams instead of words.

            +--------------------------+--------------------------+
            | ======================== | ======================== |
            |          ∀Rule           |          -∀Rule          |
            | ======================== | ======================== |
            |          ∀xΦ(x)          |       * -∀xΦ(x)          |
            |         --------         |        ----------        |
            |          Φ(c/x)          |         ∃x-Φ(x)          |
            |                          |                          |
            | if possible c is not new |                          |
            |                          |                          |
            | ======================== | ======================== |
            |          ∃Rule           |          -∃Rule          |
            | ======================== | ======================== |
            |       * ∃xΦ(x)           |       * -∃xΦ(x)          |
            |        ---------         |        -----------       |
            |         Φ(c//x)          |         ∀x:-Φ(x)         |
            |                          |                          |
            |         c is new         |                          |
            |                          |                          |
            +--------------------------+--------------------------+

Truth-Tree Analysis
===================

   The rules for assessing completed trees are the same as those for
   propositional logic.

Truth-Tree Assessment of a Single WFF
-------------------------------------

         =============   ============================   ==========
         condition       wff                            -wff
         =============   ============================   ==========
         0               inconsistent                   validity
         1+              consistent                     contingent
         2+              validity or contingency        contingent
         =============   ============================   ==========

Truth-Tree Assessment of a set of WFFs
--------------------------------------

         =============   ============================
         condition       wff Set
         =============   ============================
         0               inconsistent
         1+              consistent
         =============   ============================

Truth-Tree Assessment of a Sequent
----------------------------------

         =============   ============================
         Condition       Premises & -Conclusion
         =============   ============================
         0  open paths   valid
         1+ open paths   Invalid w/ counterexamples
         =============   ============================

------------------------------------
First-Order Predicate Calculus (FOC)
------------------------------------

Primitive Inference Rules
=========================

   Let α represent any constant symbol, and x represent any variable.
   A boxed constant [α] introduces a *new* constant into a subproof (one
   that doesn't already appear in any open line of the proof).  A boxed
   constant subsequently goes out of scope when the subproof closes (just
   like a local variable in a computer program) meaning once the subproof
   is ended that occurrence of α is no longer accessible.

   ================================  =========================================
   Name/Alternate Names              Rule
   ================================  =========================================
   Universal Elimination (∀E)        From ∀xΦ infer Φ(α//x);
                                     where α is any constant object.

   Universal Introduction (∀I)       From a subproof with hypothesis [α] and
                                     ending Ψ(α), close the subproof and
                                     infer ∀xΨ(x//α); where α is new.
                                    
   Existential Elimination (∃E)      From ∃xΦ(x), and a subproof with
                                     hypothesis [α] Φ(α//x) and ending Ψ,
                                     close the subproof and infer Ψ;
                                     where α is new.  Ψ mustn't contain α.

   Existential Introduction (∃I)     From Φ(α), infer ∃xΦ(x/α)
   ================================  =========================================

   These rules can also be described in diagrams.

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  ∀E                           |  ∀I                           |
      | ============================= | ============================= |
      |   ∀xΦ                         |   |[α]        (α is new)      |
      |  --------                     |   |   ...                     |
      |   Φ(α/x)  (any α)             |   |   Ψ(α)                    |
      |                               |  -----------                  |
      |                               |   ∀xΨ(x//α)                   |
      |                               |                               |
      | ============================= | ============================= |
      |  ∃E                           |  ∃I                           |
      | ============================= | ============================= |
      |   ∃xΦ(x)                      |   Φ(α)                        |
      |   |[α] Φ(α//x)     (α is new) |  ----------                   |
      |   |   ...                     |   ∃xΦ(x/α)                    |
      |   |   Ψ                       |                               |
      |  --------------               |                               |
      |   Ψ                           |                               |
      |                               |                               |
      +-------------------------------+-------------------------------+

Derived Inference Rules
=======================

   Once a sequent is proved it may be used as a new inference rule.  The
   following are important derived rules in FOC:

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Dual                              ⊢  -∀xΦ ↔ ∃x-Φ
   Dual                              ⊢  -∃xΦ ↔ ∀x-Φ 
   ================================  =========================================

Proofs of Non-Consequence
=========================

   Proofs of non-consequence are relatively unchanged from those
   of propositional logic.

   Procedure

   1.   Begin the proof by listing each of the assumptions first.  Then
        open a subproof by hypothesizing the negated conclusion form.

   2.   Proceed by applying inference rules in any order attempting to
        break all formulas down into atomic and negated atomic formulas.
        Recall that an atomic formula cannot contain variables.  Continue
        in this manner until no further rules can be applied.

   3.   Read the counterexamples from the proof assigning true to atomic
        formulas and false to negated atomic formulas.

         All P is Q
         ∴ Some P is Q

         ∀x(Px → Qx)  ⊢  ∃x(Px ∧ Qx)
         Proof
         01.   ∀x(Px → Qx)              A
         02.   |   -∃x(Px ∧ Qx)         H (for →I)
         03.   |   ∀x-(Px ∧ Qx)         2 Dual
         04.   |   Pa → Qa              1 ∀E
         05.   |   -(Pa ∧ Qa)           3 ∀E
         06.   |   -Pa ∨ -Qa            5 DM
         07.   |   -Pa ∨ Qa             4 MI
         08.   |   (-Pa ∨ -Qa) ∧ (-Pa ∨ Qa) 6,7 ∧I
         09.   |   -Pa ∨ (-Qa ∧ Qa)     8 Dist
         10.   |   Pa → (-Qa ∧ Qa)      9 MI
         11.   |   Pa → ⊥               10 Def ⊥
         12.   |   |   Pa               H (for -I)
         13.   |   |   ⊥                14 → E
         15.   |   -Pa                  12-13 ⊥ E

   So, the counterexample is where Pa is false.

       A proof can't be found so the form is invalid.

                        ∀x(Px → Qx)
                     *  -∃x(Px ∧ Qx)
                        ∀x-(Px ∧ Qx)
                     *  Pa → Qa
                     *  -(Pa ∧ Qa)
                          /     \
                        /         \
                     -Pa             Qa
                    /   \          /   \
                  /       \      /       \
                -Pa      -Qa   -Pa       -Qa
                                          ⊥  

      The first open path says Pa=F, Qa=?; in the second open path
      Pa=F, Qa=F; and in the third open path Pa=F, Qa=T.  So there are two
      counterexamples: Pa=F, Qa=F; and Pa=F, Qa=T.  These results are
      consistent with the proof of non-consequence above.

------------------------------------------
Proofs of Some Aristotelian Argument Forms
------------------------------------------

   All Q is R
   All P is Q
   ∴ All P is R

   ∀x(Qx → Rx), ∀x(Px → Qx)  ⊢  ∀x(Px → Rx)
   Proof
   01.   ∀x(Qx → Rx)              A
   02.   ∀x(Px → Qx)              A
   03.   |[a]                     H (for ∀I)
   04.   |   |   Pa               H (for →I)
   05.   |   |   Qa → Ra          1 ∀E (a/x)
   06.   |   |   Pa → Qa          2 ∀E (a/x)
   06.   |   |   Qa               4,6 →E
   07.   |   |   Ra               5,7 →E
   08.   |   Pa → Ra              4-7 →I
   09.   ∀x(Px → Rx)              3-8 AI
   QED

   All P is Q
   some P exist
   ∴ Some P is Q

   ∀x(Px → Qx), ∃xPx  ⊢  ∃x(Px ∧ Qx)
   Proof
   01.   ∀x(Px → Qx)              A
   02.   ∃xPx                     A
   03.   |[a]Pa                   H (for EE)
   04.   |   Pa → Qa              1 ∀ E (a/x)
   05.   |   Qa                   3,4 →E
   06.   |   Pa ∧ Qa              3,5 ∧ I
   07.   |   ∃x(Px ∧ Qx)          6 ∃ I (x/a)
   08.   ∃x(Px ∧ Qx)              2, 3-7 ∃ E
   QED


============================
Identity Logic (IL and FOL=)
============================

   Identity Logic is the logic of the identity predicate '=', which I define
   here in the context of FOL.  The combined system is called First-Order
   Predicate Logic with Identity (FOL=).


--------
Language
--------

Lexemes
=======

   Non-Logical Symbols
      Object symbols
         constants:            a...t
         variables:            u...z
      Predicate Symbols:       A...Z, =
      Association Symbols:     (, )

   Logical Symbols
      Truth-Function Symbols:  -, ∧, ∨, →, ↔
      Quantifiers
         universal:            ∀
         existential:          ∃

Grammar
=======

   An ATOMIC FORMULA is a predicate symbol followed by zero or more
   constants; or 'α=β' (where α,β are constants, and can be the same symbol).

   1.  Every atomic formula is a wff;
   2.  if Φ is a wff, then so is -Φ;
   3.  if Φ,Ψ are wffs, then so are (Φ ∧ Ψ), (Φ ∨ Ψ), (Φ → Ψ), (Φ ↔ Ψ);
   4.  if Φ(α) (α is some constant) is a wff, then ∀xΦ(x/α) and ∃xΦ(x/α)
       are wffs (where x is new to Φ).
   5.  Nothing else is a wff.


---------
Semantics
---------

   The identity predicate does just one thing:  asserts that two object
   symbols denote the same object; that the two symbols are like synonyms.

Translation Hints
=================

   Numerical Quantification

   One of the powers of identity is that it allows us to say things
   about the number of members in a set P without using numbers.  Recall
   |P| is the cardinality of a set P, which equals the number of members
   P contains.

           ========  ===============================================
           Quantity  Proposition
           ========  ===============================================
           |P| = 0   -∃xPx
           |P| = 1   ∃x∀y(Px ↔ y=x)
           |P| = 2   ∃x∃y(-x=y ∧ ∀z(Pz ↔ (z=x ∨ z=y)))
           |P| = 3   ∃w∃x∃y(-w=x ∧ -w=y ∧ -x=y ∧
                                  ∀z(Pz ↔ (z=w ∨ z=x ∨ z=y)))
           --------  -----------------------------------------------
           |P| >= 1  ∃xPx
           |P| >= 2  ∃x∃y(-x=y ∧ Px ∧ Py)
           |P| >= 3  ∃x∃y∃z(-x=y ∧ -y=z ∧ -x=z ∧ Px ∧ Py ∧ Pz)
           --------  -----------------------------------------------
           |P| <= 1  ∃x∀y(Px → y=x)
           |P| <= 2  ∃x∃y∀z(Pz → (z=x ∨ z=y))
           |P| <= 3  ∃x∃y∃z∀w(Pw → (w=x ∨ w=y ∨ x=z))
           ========  ===============================================


Properties of Relations
=======================

   The identity predicate enables further discussion of 2-place predicates
   (sometimes called BINARY RELATIONS).  Binary relations can have
   interesting properties that can impart logical meaning upon those
   relations.  Understanding these relations can go a long way in teaching
   the student of logic how to translate sentences into FOL=.

      Let,
         R,        be any binary relation
         x,y,z,    be any variable symbols
         a,b,c,    be any constant symbols

    ================  ================================  =================
    Property          Characteristics                   Examples
    ================  ================================  =================
    Symmetric(R)      =df ∀x∀y(Rxy → Ryx)               Sibling(x,y)
                                                        x=y

    Transitive(R)     =df ∀x∀y∀z((Rxy ∧ Ryz) → Rxz)     x=y
                                                        a=b ∧ b=c → a=c
                                                        Descendant(x,y)

    Reflexive(R)      =df ∀xRxx                         x=x
                                                        SameHeight(x,y)

    Asymmetric(R)     =df ∀x∀y(Rxy → -Ryx)              x<y
                                                        Child(x,y)

    Antisymmetric(R)  =df ∀x∀y((Rxy ∧ Ryx) → x=y)       x>=y


    Nonsymmetric(R)   =df -( Symmetric(R) ∨             Brother(bob,kim)
                              Asymmetric(R) ∨
                              Antisymmetric(R) )

    Intransitive(R)   =df ∀x∀y∀z((Rxy ∧ Rxz) → -Rxz)    OppositeSide(x,y)

    Nontransitive(R)  =df -( Transitive(R) ∨            ChildOf(x,y)
                              Intransitive(R) )

    Irreflexive(R)    =df ∀x-Rxx                        x<y
                                                        Left(x,y)

    nonreflexive(R)   =df -( Reflexive(R) ∨
                              Irreflexive(R) )

    Equivalent(R)     =df Reflexive(R) ∧                Congruent(x,y)
                          Symmetric(R) ∧
                          Transitive(R)
    ================  ================================  =================

Truth Trees
===========

   Truth trees in FOL= are nearly identical to those in FOL; identity
   is just a predicate though with some special standing in FOL=.  Therefore,
   I introduce two new tree rules.

   ====  =====================================================================  
   Name  Rule
   ====  =====================================================================
   =     If α=β appears on an open path along with either Φ(α) or Φ(β)
         unstarred, write at the bottom of the path any wff not already
         on the path which is the result of replacing one of more occurrences
         of either of these name letters by the other in Φ.  Do not star
         either α=β or Φ.

   -=    Close any path on which -α=α occurs by placing ⊥ at the bottom.
   ====  =====================================================================

   These rules are often expressed with diagrams instead of words.

            +--------------------------+--------------------------+
            | ======================== | ======================== |
            |          =Rule           |          -=Rule          |
            | ======================== | ======================== |
            |       α=β       α=β      |           -α=α           |
            |       Φ(α)      Φ(β)     |          --------        |
            |      --------  --------  |           ⊥              |
            |       Φ(β/α)    Φ(α/β)   |                          |
            |                          |                          |
            +--------------------------+--------------------------+


----------------------
Identity Calculus (IC)
----------------------

   Identity Calculus combined with FOC is called FOC=.

Primitive Inference Rules
=========================

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Identity Elimination (=E)         From α=β or β=α, and P(α), infer P(β/α).

   Identity Introduction (=I)        Introduce α=α (for any constant α)
                                     at any step.
   ================================  =========================================

   These rules can also be expressed in diagrams.

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  =E                           |  =I                           |
      | ============================= | ============================= |
      |   α=β        β=α              |                               |
      |   Φ(α)       Φ(α)             |  -----                        |
      |  --------   --------          |   α=α     α is any constant   |
      |   Φ(β/α)     Φ(β/α)           |                               |
      |                               |                               |
      +-------------------------------+-------------------------------+


--------
Concerns
--------

Identity Peculiarities
======================

   We can't be certain that just because FOL= classifies a string as
   well-formed that the string is therefore sensical.  FOL= classifies
   the following expressions as wffs though they're nonsensical:

         ∀x-x=α    where α is some constant symbol
         -∀xx=x

   Their existential duals are just as problematic.

         -∃xx=α    where α is some constant symbol
         ∃x-x=x


===================
Function Logic (FL)
===================

   Function logic is constructed in FOL=.  It provides another way
   to analyze atomic formulas.  FL however, doesn't add any new power
   to the logic, it just adds new ways to say things FOL= can already say.
   It assigns valid/invalid to all the same argument forms.  For this reason
   when working with functions we're still working in FOL=.


--------
Language
--------

Lexemes
=======

   Non-Logical Symbols
      Object symbols
         constants:            a...t
         variables:            u...z
         functions:            a(x)...z(x)
      Predicate Symbols:       A...Z, =
      Association Symbols:     (, )

   Logical Symbols
      Truth-Function Symbols:  -, ∧, ∨, →, ↔
      Quantifiers
         universal:            ∀
         existential:          ∃

Grammar
=======

   An ATOMIC FORMULA is a predicate symbol followed by zero or more constants;
   or 'α=β' (where α,β are any constants; and could be the same constant).
   In addition to a constant object symbol, a function symbol with a
   constant argument is also a constant object symbol since functions are just
   objects.  Functions can also be composed (take functions as arguments).

   1.  Every atomic formula is a wff;
   2.  if Φ is a wff, then so is -Φ;
   3.  if Φ,Ψ are wffs, then so are (Φ ∧ Ψ), (Φ ∨ Ψ), (Φ → Ψ), (Φ ↔ Ψ);
   4.  if Φ(α) (α a is some constant) is a wff, then ∀xΦ(x/α) and ∃xΦ(x/α)
       are wffs (where x is new to Φ).
   5.  Nothing else is a wff.


---------
Semantics
---------

Function Symbol Denotation
==========================

   A FUNCTION maps one set of objects (called a DOMAIN SET) onto another set
   of objects (called a RANGE SET); each domain object maps to exactly one
   range set object though multiple domain objects can map to the same range
   object.  Any function expression f(x) is read as "f of x."  There
   are various ways to define function mappings, but for FOL= often,
   it is necessary to exhaustively list all the mappings along with
   the defined predicate and object symbols describing the state of affairs.

         Domain Set          Range Set
         +---------+         +---------+
         |         |    f    |         |
         |    a ---+---------+--> r    |
         |         |         |         |
         |    b ---+---------+--> s    |
         |         |         |         |
         |    c ---+---------+--> t    |
         |         |         |   /     |
         |    d ---+---------+--/      |
         |         |         |         |
         |         |         |    u    |   (u is not mapped)
         |         |         |         |
         +---------+         +---------+

   In the diagram each domain object maps to a range object.  However,
   two domain objects c and d map to the same range object.  The following
   denotes the state of affairs in the diagram.

         Dictionary
         ----------------------------------------
         Object Symbols     Function Symbols
         a,    Alice        f(x), the father of x
         b,    Bob
         c,    Charlie
         d,    Donna
         r,    Rob
         s,    Steve
         t,    Tom
         u,    Uden

         State of Affairs in Universe
         -------------------------------------------
         f(a) = r   or   f = { <a,r>,
         f(b) = s              <b,s>,
         f(c) = t              <c,t>,
         f(d) = t              <d,t> }

   Charlie and Donna have the same father; they're siblings so,
   f(d) = f(c) = r.  FOL= functions are general functions as in algebra
   and calculus.  They are not required to conform to a more limited
   definition, such as being one-to-one.

Inverse Functions
=================

   An INVERSE FUNCTION is a function that reverses the mapping of another
   function; a function must be bijective to have an inverse.  If the
   universe is the set of all integers, the successor s(x) function always
   denotes the integer *after* x and is bijective.  So, its inverse
   function is predecessor p(x), which of course denotes the integer
   *before* x.

   Our father function f(x) tempts one to define an inverse function
   child c(x).  However, this is not possible because some people like Uden
   don't have any children, while others like Tom have more than one.  It
   might also be tempting to challenge this requirement by just having c(x)
   return a set of objects containing the children of the argument x.
   However, the requirement is that a function maps an object to one object.
   So c(x) cannot be a function.  Note that is that while functions have these
   restriction, there is nothing preventing anyone from defining a relation
   like Cxy, "x is a child of y", so 'Cct' and 'Cdt' are perfectly good
   predicates.

Variable Function Arguments
===========================
   
   A function with a constant object argument always denotes the object that
   the function maps the argument to, making the string of symbols denoting
   use of a function itself a constant object symbol.  Each of the
   following is a constant object symbol.

         f(a), the father of Alice.
         f(b), the father of Bob.       
         f(c), the father of Charlie.
         f(d), the father of Donna.

   However, when a variable is the argument to a function, the function
   doesn't denote an object; not until the variable is replaced with
   a constant object symbol.  However, functions with variable arguments
   can still contribute semantically to general assertions.

         Dictionary
         -------------------------------------------------
         Predicates                Functions
         Px,    x is a person.     f(x),  the father of x.

         ∀x( Px → ∃yy=f(x) )  Everyone has a father.

Functions in WFFs
=================

   A function is just another way to denote objects, and so can occur
   anywhere object symbols can occur.  All of the following expressions
   are well-formed.

         a=c,        a and c denote the same object.
         m(s)=g,     the mother of Susan is Gloria; Susan's mother is Gloria.
         m=s(n),     m is the successor of integer n.
         a(r(i))=v,  the address of my residence is v.

         Mx,         x is a millionaire.
         Mf(k)       the father of the king is a millionaire.
         Txy,        x is taller than y.
         Tf(y)f(i),  your father is taller than my father.

         ∀x∀y( Txy       → -Tyx       )
         ∀x∀y( Tf(x)f(y) → -Tf(y)f(x) )

Translation Hints
=================

   Simple Functions

         l(x),     the length of x.
         l(p),     the length of the pool.
         h(x),     the home planet of x.
         h(e),     the home planet of E.T..

   Composed Functions

         m(x),     the mother of x.
         m(m(x)),  the mother of the mother of x.  (x's maternal grandmother)

         0,        zero
         s(0),     1 (the successor of zero).
         s(s(0)),  2
         s(s(n)),  n + 2

   Non-Functions

         None of the following is a function, because none is guaranteed to
         always map to exactly one object.

         d(m),     the daughter of Mike.
         b(x),     the brother of x.
         s(h),     the shingle of my house.

         If in the universe of discourse objects do map to unique objects
         then they may be functions within the universe even if they
         aren't functions in the actual world.


----------------------
Function Calculus (FC)
----------------------

   All the inference rules of FOC= are valid in Function Logic.  Function
   calculus doesn't add any new inference rules, since functions only add
   a new way to name existing objects.  Thus, functions do not require the
   addition of new inference rules.  However, they do allow us to analyze
   sentences in a new way.  In these ways, FL is analogous to predicate logic.

Functions in Proofs
===================

   Any constant function can be used within the body of a proof anywhere
   that constant object symbols can.  For example, such a function can
   be the replacement value for a variable x in applying ∀E.

         Dictionary
         --------------------------
         Predicates
         Mx,    x is a mammal
         Vx,    x is a vertebrate

         Functions
         f(x),  the father of x


         i.   ∀x(Mx → Vx)
              ...
         j.   Mf(e) → Vf(e)         i ∀E (f(e)/x)

   Alternatively, the function might already be in the wff with a
   variable argument.

         i.   ∀x:(Mf(x) → Vf(x))
              ...
         j.   Mf(c) → Vf(c)         i ∀E (c/x)


====================
Definite Descriptors
====================

   Bertrand Russell introduced a new notation for when there's exactly one
   object that has property P (e.g. The ball in my hand, God, the king, etc.).
   He called this notion a DEFINITE DESCRIPTOR.  A definite descriptor, is
   any noun phrase of the form "the x such that Px" which he wrote as
   as ℩xPx (℩ is an inverted Greek lower case letter iota).  Despite
   looking like a quantified wff, a definite descriptor names a particular
   object in the universe of discourse.  Like functions, descriptors don't add
   anything new to FOL=; the FOL= concepts covered so far can already express
   the same ideas.

         B(℩xPx)    =df    ∃x(∀y(Py ↔ y=x) ∧ Bx)
                    =df    ∃x(Ax ∧ ∀y(Ay → y=x) ∧ Bx)

         B(℩xKx), the king of France is bald.
                  the x such that x is the king of France is Bald
                  = ∃x(Kx ∧ ∀y(Ky → y=x) ∧ Bx)


--------
Concerns
--------

   What's the truth-value of a definite descriptor if it doesn't denote?  This
   is the question that plagues descriptors.  Russell was certain that such
   a proposition is false, but many philosophers aren't convinced.


====================================
Second-Order Quantified Logic (SOL=)
====================================

   Second-order logic adds new quantifiers and new variables that reign
   over predicates.

         ∀x∃VVx    Every object has some (1 or more) property.


--------
Language
--------

Lexemes
=======

   Non-Logical Symbols
      Object symbols
         constants:            a...t
         variables:            u...z
         functions:            a(x)...z(x)
      Predicate Symbols
         constants:            A...T, =
         variables:            U...Z
      Association Symbols:     (, )

   Logical Symbols
      Truth-Function Symbols:  -, ∧, ∨, →, ↔
      Quantifiers
         universal:            ∀
         existential:          ∃

Grammar
=======

   An ATOMIC FORMULA is a constant predicate symbol followed by zero or more
   constant object symbols; or 'α=β' (where α,β are constant object symbols;
   and could be the same symbol).  A constant object may also consist of a
   function symbol with some constant object argument since constant functions
   are just constant objects.  Functions can also be composed (take functions
   as arguments).

   1.  Every atomic formula is a wff;
   2.  if Φ is a wff, then so is -Φ;
   3.  if Φ,Ψ are wffs, then so are (Φ ∧ Ψ), (Φ ∨ Ψ), (Φ → Ψ), (Φ ↔ Ψ);
   4.  if Φ(α) (α a is some constant object symbol) is a wff,
       then ∀xΦ(x/α) and ∃xΦ(x/α) are wffs (where x is new to Φ).
   5.  if Φ(Ψ) (Φ,Ψ are constant predicates) is a wff, then ∀VΦ(V/Ψ) and
       ∃VΦ(V/Ψ) are wffs where V is a variable predicate symbol and
       V is new to Φ.
   6.  Nothing else is a wff.


---------
Semantics
---------

   The quantifiers of FOL are here OVERLOADED, redefined so that they
   accept another kind of argument.  In this case, they are overloaded
   to accept variable object symbols as their first argument and they
   accept variable predicate symbols.  They are read the same way
   and mean nearly the same as their FOL counterparts.  The variable
   predicates are capital letters at the end of the alphabet (U,V,W,X,Y,Z)
   which signals to the reader that the quantifier and variable reign over
   arbitrary predicates as opposed to objects.

         ∀VVc,     c has every property.
         ∃VVc,     c has at least one property.

         ∀x∃VVx,   Everything has at least one property.
         ∃V∀xVx,   There are some properties that everything has.
         ∀V∃xVx,   For all properties there exist some who have them.
         ∃x∀VVx,   Some have all properties


---------------------------
Second-Order Calculus (SOC)
---------------------------

   The four quantifier inference rules from FOL are expanded to these
   two new quantifiers in more-or-less the same way as they are usable
   for variable object symbols.  However, variable types must not
   be confused with one another.  If a quantifier reigns over a predicate
   variable, it must be replaced only by a predicate constant, and
   if a quantifier reigns over an object it must only be replaced
   by a constant object.


--------
Concerns
--------

   The most critical concern is that SOC is not semantically complete;
   we are not guaranteed to find a proof for a conclusion form.  A conclusion
   may *be* a consequence of some premises, and yet no proof gets us from
   the premises to the conclusion.  Nevertheless, SOC is still sound.
   There is no way to derive a proof to a formula that doesn't follow from
   the premises.  So, it can still be useful despite not being complete.


======================
Mathematical Induction
======================

   Mathematical induction is a method to prove that all members of an 
   denumerable set have some property P.  Such an argument has two parts,
   an inductive definition that enumerates all members of the set we're
   reasoning about; and an inductive inference which proves that all members
   have the property P.

Inductive Definitions
=====================

   An INDUCTIVE DEFINITION describes how to enumerate all members of a set.
   They are constructed recursively, consisting of three types of numbered
   clauses.  The first clause is the BASE CLAUSE.  It identifies the most
   basic elements of the set and is non-recursive.  The FINAL CLAUSE states
   that if something is not constructed via the prior clauses then it is not
   a member of the set and is also non-recursive.  The INDUCTIVE CLAUSES
   (intermediate clauses) tell us how to *recursively* generate all non-base
   case elements of the set.

   The formation rules for all of the classical logics are examples
   of inductive definitions.  For illustration, here again are the formation
   rules for propositional logic.

         1.   Every atomic formula is a wff;
         2.   If P is a wff, then so is -P;
         3.   If P,Q are wffs, then so are
              (P ∧ Q), (P ∨ Q), (P → Q), (P ↔ Q);
         4.   Nothing else is a wff.

   Clause 1 establishes the base case: any atomic formula is a wff.

   Clause 4, the final clause, excludes anything that cannot be constructed
   by these clauses.

   Clauses 2 & 3 tell us how to generate all the intermediate members
   of the set.

   There are a few sets for which we do not need an inductive definition.
   For example, the inductive proof alone is often all that's needed to
   reason about integers.

Zero and The Successor Function
===============================

   Mathematical induction introduces a new constant object symbol 0, which
   denotes the number zero; it also introduces the SUCCESSOR function s;
   that is the number that comes after its argument.  Because the successor
   function is often composed with itself many times it is common to omit
   the parentheses.

         s0     =  s(0)       = the successor of 0  = 1
         ss0    =  s(s(0))    = 2
         sss0   =  s(s(s(0))) = 3
         ...

Inductive Inference
===================

   Mathematical induction infers a proof that all members of the set
   enumerated by the inductive definition have some property P.  From the
   definition, an INDUCTIVE INFERENCE proceeds in two steps:  the BASE
   case and the inductive case.  The BASE CASE of the proof requires that
   we prove that the members denoted by the base clause of the inductive
   definition have property P.  The INDUCTIVE CASE is a hypothetical proof.
   The method is to prove the conditional that for any x in the universe,
   if x has the property P, then the successor of x also has property P.
   All of these pieces put together are adequate to conclude that all
   members of the set have property P.

   The inferential step of Mathematical Induction is expressible over the
   natural numbers as an axiom in second-order logic, an axiom schema in
   first-order logic, or an inference rule in first-order logic.  All of the
   following are different ways to express the same thing.

         2nd-order axiom             ∀P((P0 ∧ ∀x(Px → Psx)) → ∀xPx)

         1st-order axiom schema      (P0 ∧ ∀x(Px → Psx)) → ∀xPx

         1st-order Inference Rule    from P0 and ∀x(Px → Psx), infer ∀xPx


===============================
Axiomatic and Natural Deduction
===============================

   The calculi presented thus far are known as NATURAL DEDUCTION systems,
   which consist only of inference rules.  These natural deduction systems are
   more intuitive and more closely resemble how one reasons informally.  An
   AXIOMATIC DEDUCTION system, in contrast, consists of a minimal set of
   inference rules, often just one, and one or more axiom schemata.  All
   instances of the schemata are axioms of the logic.  Axiomatic deduction
   systems are usually simpler than Natural Deduction in that they have fewer
   parts, but they are also more complicated and cumbersome to use and
   entirely dissimilar to how one reasons informally.  Given all this, the
   one significant similarity is that both kinds of systems count the same
   forms as valid.

       +--------------------------------------------------------------+
       | ============================================================ |
       | Axiomatic Propositional Logic & Calculus                     |
       | ============================================================ |
       |                                                              |
       | Lexemes                                                      |
       |    Non-Logical Symbols                                       |
       |       Proposition Symbols:      A...Z                        |
       |       Association Symbols:      (, )                         |
       |                                                              |
       |    Logical Symbols                                           |
       |       Truth-Function Symbols:   -, →                         |
       |                                                              |
       | Grammar                                                      |
       |                                                              |
       |    An ATOMIC FORMULA is any single proposition symbol.       |
       |                                                              |
       |    1.  Every atomic formula is a wff;                        |
       |    2.  if Φ is a wff, then -Φ is a wff;                      |
       |    3.  if Φ ,Ψ is wffs, then so is (Φ → Ψ);                  |
       |    4.  nothing else is a wff.                                |
       |                                                              |
       | Definitions                                                  |
       |                                                              |
       |    (P ∧ Q)     =df  -(P → -Q)                                |
       |    (P ∨ Q)     =df  -P → Q                                   |
       |    (P ↔ Q)     =df  ((P → Q) ∧ (Q → P))                      |
       |                                                              |
       | Inference Rule                                               |
       |                                                              |
       |    Given Φ → Ψ, and Φ infer Ψ.                               |
       |                                                              |
       | Axiom Schemata                                               |
       |                                                              |
       |    AxS1.  P → (Q → P)                                        |
       |    AxS2.  (P → (Q → R)) → ((P → Q) → (P → R))                |
       |    AxS3.  (-P → -Q) → ((-P → Q) → P)                         |
       |                                                              |
       |    Every instance of these schemata is an axiom              |
       |    of the calculus.                                          |
       |                                                              |
       +--------------------------------------------------------------+


===============
Formal Theories
===============

   A SYSTEM is a set of objects, properties, and relationships, while A MODEL
   is a limited representation of a system.  A THEORY is all the true
   propositions that can be said about a model.

   Since any interesting theory has a large number (usually infinite number)
   of propositions, it would be impractical to uncover all those truths.
   We attempt to tackle this problem with a set of first principles from which
   can be reasoned the rest of the theory.  In this way the first principles
   combined with logical reasoning GENERATES theorems.  It is easy to
   construct a theory that OVER GENERATES, proves too many things, i.e.
   theorems that are not true of the model; or UNDER GENERATES, does not
   prove all of the true things that there are to say about the model.

   The FIRST PRINCIPLES of a theory are those things from which the rest
   of the theory may be derived; they include but may not be limited to
   inference rules, axioms, and definitions.

   An AXIOM is a proposition within a theory that describes the logical
   relationships between the theory's various concepts (usually predicates
   and objects).  Many axioms follow some of the schema listed under
   Properties of Relations in the chapter on Identity Logic.

   POSTULATE is a synonym for axiom; another synonym is LAW.  Some theorists
   uses these terms as categories in which to group different kinds of axioms,
   others pick just one of the terms to use.  However, from the perspective
   of logic they are all the same thing.  Postulate, law, and axiom all mean
   the same thing.

   A SCHEMA (plural is SCHEMATA) is a general statement about definitions
   or axioms which contain placeholders and whose substitution instances
   are actual definitions or axioms.

   A THEOREM is any proposition derived only from a theory's first principles
   or other theorems via reasoning.  Theorems are propositions that are true
   in all cases.  So an argument with premises is not a theorem in logic since
   it depends upon things other than the first principles for its validity.

   A THEORY is the plural of theorem; a theory consists of the combined
   set of first principles plus all the theorems (whether proved or not).

   A LEMMA is a theorem that serves as an intermediate step in the proof
   of another theorem.  The purpose of the lemma is to make the proof of
   a theorem shorter.  Proving lemmas before proving a theorem is a divide
   and conquer approach to theorem proving.

   A COROLLARY is a theorem that "follows easily" from a first principle
   or another theorem; i.e., the corollary is only a few reasoning steps away
   from what it is claimed to follow from.

   A CONJECTURE is any proposition that cannot be proved as a theorem in any
   known theory but is still taken as a true principle due to its usefulness
   or apparent wisdom.  The well known Occam's razor is sometimes called
   a conjecture.  Einstein took Galileo's equivalence principle, a conjecture,
   and promoted it to an axiom of his theory of relativity.


================
Example Theories
================


---------------------
Theory of Taller-Than
---------------------

   Predicates

         Txy,  x is taller than y.

   Axioms

         Ax1.  ∀x∀y(Txy → -Tyx)                  T is Asymmetric
         Ax2.  ∀x∀y∀z((Txy ∧ Tyz) → Txz)         T is Transitive
         Ax3.  ∀x∀y(Txy → ∃z(Txz ∧ Tzy))         T is Dense


=================
Formal Arithmetic
=================

Formal arithmetic is a theory about arithmetic of natural numbers (non-
negative integers).

   Dictionary
         0,    constant object symbol zero.
         sx,   function, the successor of x.
         +,    to signify addition
         *,    to signify multiplication.

   Axioms
         A1.   ∀x-0=sx
         A2.   ∀x∀y(sx=sy → x=y)
         A3.   ∀x(x+0)=x
         A4.   Ax∀y(x+sy)=s(x+y)
         A5.   ∀x(x*0)=0
         A6.   ∀x∀y(x*sy)=((x*y)+x)

   Mathematical Induction Axiom
      MI.   ∀P((P0 ∧ ∀x(Px → Psx)) → ∀xPx)


================================================
Appendix A: Combined Truth-Tree Rules & Analysis
================================================

   ====  =====================================================================
   Name  Rule
   ====  =====================================================================
   -     If an open path contains both a formula and its negation, close it
         by placing '⊥' at the bottom of the path.

   --    If an open path contains an unstarred instance of --Φ, star it
         and write Φ at the bottom of every open path below it.

   ∧     If an open path contains an unstarred instance of Φ ∧ Ψ, star it
         and write both Φ and Ψ at the bottom of every open path that contains
         this newly starred wff.
 
   -∧    If an open path contains an unstarred instance of -(Φ ∧ Ψ), star
         it and split the bottom of each open path containing this newly
         starred wff into two branches, at the end of the first branch write
         -Φ and at the end of the second branch write -Ψ.

   ∨     If an open path contains an unstarred instance of Φ ∨ Ψ, star it
         and split the bottom of each open path containing this newly starred
         wff into two branches, at the end of the first branch write Φ and at
         the end of the second branch write Ψ.

   -∨    If an open path contains an unstarred instance of -(Φ ∨ Ψ), star
         it and write both -Φ and -Ψ at the bottom of every open path that
         contains this newly starred wff.

   →     If an open path contains an unstarred instance of Φ → Ψ, star it
         and split the bottom of each open path containing this newly starred
         wff into two branches, at the end of the first branch write -Φ and
         at the end of the second branch write Ψ.

   -→    If an open path contains an unstarred instance of -(Φ → Ψ),
         star it and write both Φ and -Ψ at the bottom of every open path
         that contains this newly starred wff.

   ↔     If an open path contains an unstarred instance of Φ ↔ Ψ, star
         it and split the bottom of each open path containing this newly
         starred wff into two branches, at the end of the first write both
         Φ and Ψ, and at the end of the second write both -Φ and -Ψ.

   -↔    If an open path contains an unstarred instance of -(Φ ↔ Ψ), star
         it and split the bottom of each open path containing this newly
         starred wff into two branches, at the end of the first write both
         Φ and -Ψ, and at the end of the second write both -Φ and Ψ.

   ----  ---------------------------------------------------------------------

   ∀     If ∀xΦ(x) appears on an open path, and α occurs in some wff on
         that path, write Φ(α//x) (the result of replacing each occurrence
         of x in Φ with α) at the bottom of the path.  If no wff containing
         α appears on the path, choose any α .

   -∀    If -∀xΦ(x) appears on an open path, star it and write ∃x-Φ(x)
         at the bottom of every open path that contains the newly
         starred wff.

   ∃     If ∃xΦ(x) appears on an open path, star it.  Choose a constant α
         that doesn't appear on that path and write Φ(α//x) (the results of
         replacing each occurrence of x by α in Φ) at the bottom of every
         open path that contains the newly starred wff.

   -∃    If -∃xΦ(x) appears on an open path, star it and write ∀x-Φ(x)
         at the bottom of every open path that contains the newly
         starred wff.

   ----  ---------------------------------------------------------------------

   =     If α=β appears on an open path along with either Φ(α) or Φ(β)
         unstarred, write at the bottom of the path any wff not already
         on the path which is the result of replacing one of more occurrences
         of either of these name letters by the other in Φ.  Do not check
         either α=β or Φ.

   -=    Close any path on which -α=β occurs.
   ====  =====================================================================


   These rules can also be described in diagrams.

           +---------------------------+---------------------------+         
           | ========================= | ========================= |
           |           -Rule           |         --Rule            |
           | ========================= | ========================= |
           |             Φ             |          * --Φ            |
           |            -Φ             |          --------         |
           |          -------          |             Φ             |
           |             ⊥             |                           |
           |                           |                           |
           | ========================= | ========================= |           
           |           ∧Rule           |          -∧Rule           |
           | ========================= | ========================= |
           |         * Φ ∧ Ψ           |       * -(Φ ∧ Ψ)          |
           |          -------          |        -----------        |
           |             Φ             |           /     \         |
           |             Ψ             |         -Φ     -Ψ         |
           |                           |                           |
           | ========================= | ========================= |
           |           ∨Rule           |           -∨Rule          |
           | ========================= | ========================= |
           |         * Φ ∨ Ψ           |        * -(Φ ∨ Ψ)         |
           |          -------          |         -----------       |
           |           /   \           |             -Φ            |
           |          Φ     Ψ          |             -Ψ            |
           |                           |                           |
           | ========================= | ========================= |
           |           → Rule          |          -→ Rule          |
           | ========================= | ========================= |
           |         * Φ → Ψ           |       * -(Φ → Ψ)          |
           |          --------         |        ----------         |
           |           /    \          |             Φ             |
           |         -Φ      Ψ         |            -Ψ             |
           |                           |                           |
           | ========================= | ========================= |
           |          ↔ Rule           |         -↔ Rule           |
           | ========================= | ========================= |
           |        * Φ ↔ Ψ            |       * -(Φ ↔ Ψ)          |
           |         ---------         |        ------------       |
           |          /     \          |           /     \         |
           |         Φ      -Φ         |         Φ      -Φ         |
           |         Ψ      -Ψ         |        -Ψ       Ψ         |
           |                           |                           |
           | ========================= | ========================= |
           |           ∀Rule           |           -∀Rule          |
           | ========================= | ========================= |
           |           ∀xΦ(x)          |        * -∀xΦ(x)          |
           |          --------         |         ----------        |
           |           Φ(c/x)          |          ∃x-Φ(x)          |
           |                           |                           |
           | if possible c is not new  |                           |
           |                           |                           |
           | ========================= | ========================= |
           |           ∃Rule           |           -∃Rule          |
           | ========================= | ========================= |
           |        * ∃xΦ(x)           |        * -∃xΦ(x)          |
           |         ---------         |         -----------       |
           |          Φ(c//x)          |          ∀x:-Φ(x)         |
           |                           |                           |
           |          c is new         |                           |
           |                           |                           |
           | ========================= | ========================= |
           |           =Rule           |         -=Rule            |
           | ========================= | ========================= |
           |       α=β       α=β       |          -α=α             |
           |       Φ(α)      Φ(β)      |         --------          |
           |      --------  --------   |          ⊥                |
           |       Φ(β/α)    Φ(α/β)    |                           |
           |                           |                           |
           +---------------------------+---------------------------+

Truth-Tree Analysis
===================

   Truth-Tree Assessment of a Single WFF

         =============   ============================   ==========
         condition       wff                            -wff
         =============   ============================   ==========
         0               inconsistent                   validity
         1+              consistent                     contingent
         2+              validity or contingency        contingent
         =============   ============================   ==========

   Truth-Tree Assessment of a set of WFFs

         =============   ============================
         condition       wff Set
         =============   ============================
         0               inconsistent
         1+              consistent
         =============   ============================

   Truth-Tree Assessment of a Sequent

         =============   ============================
         Condition       Premises & -Conclusion
         =============   ============================
         0  open paths   valid
         1+ open paths   Invalid w/ counterexamples
         =============   ============================


==========================
Appendix B: Combined Logic
==========================


------------------
Regarding Notation
------------------

   The following notations are used in the formal descriptions that follow.

   A capital Greek letter (Φ, Ψ, Θ, Δ, etc.) denotes any arbitrary formula,
   and a lower case Greek letter (α, β, δ, etc.) denotes any arbitrary
   object symbol.

   Φ(Ψ) denotes a wff Φ contains one or more occurrences of a sub-wff Ψ.

   Φ(Θ/Ψ) denotes the result of replacing one or more occurrences of Ψ in Φ
   with Θ.  Θ/Ψ is read, "Θ replaced one or more occurrences of Ψ".

   Φ(Θ//Ψ) like above but indicates replacing all occurrences of Ψ in Φ with
   Θ.  Θ//Ψ is read, "Θ replaced all occurrences of Ψ"

   Φ(β),Φ(α/β),Φ(α//β), similar to the above but α and β are object symbols.

   ( Φ ⊢ Ψ ), denotes a subproof with hypothesis Φ concluding with Ψ.

   [ ... ] denotes that the enclosed must exist, be defined or proved
   elsewhere (external to the current proof).


Lexemes
=======

   Non-Logical Symbols
      Object symbols
         constants:            a...t
         variables:            u...z
         functions:            a(x)...z(x)
      Predicate Symbols
         constants:            A...T, =
         variables:            U...Z
      Association Symbols:     (, )


   Logical Symbols
      Truth-Function Symbols:  -, ∧, ∨, →, ↔
      Quantifiers
         universal:            ∀
         existential:          ∃

Grammar
=======

Formation Rules
---------------

   An ATOMIC FORMULA is a constant predicate symbol followed by zero or more
   constant object symbols; or 'α=β' (where α,β are constant object symbols;
   and could be the same symbol).  A constant object may also consist of a
   function symbol with some constant object argument since constant functions
   are just constant objects.  Functions can also be composed (take functions
   as arguments).

   1.  Every atomic formula is a wff;
   2.  if Φ is a wff, then so is -Φ;
   3.  if Φ,Ψ are wffs, then so are (Φ ∧ Ψ), (Φ ∨ Ψ), (Φ → Ψ), (Φ ↔ Ψ);
   4.  if Φ(α) (α a is some constant object symbol) is a wff,
       then ∀xΦ(x/α) and ∃xΦ(x/α) are wffs (where x is new to Φ).
   5.  if Φ(Ψ) (Φ,Ψ are constant predicates) is a wff, then ∀VΦ(V/Ψ) and
       ∃VΦ(V/Ψ) are wffs where V is a variable predicate symbol and
       V is new to Φ.
   6.  Nothing else is a wff.

Definitions
-----------

   Definition Schema

         ⊥  =df  (P ∧ -P)

Primitive Inference Rules & Other Justifications
================================================

   ================================  =========================================
   Name (Abbreviation)               Rule
   ================================  =========================================
   Assumption (A)                    Introduce a premise at any step.

   Hypothesis (H)                    Introduce a hypothesis at any step
                                     provided it begins a new subproof.

   Axiom (Ax)                        Introduce an axiom at any step.

   Negation Elimination (-E)         From --Φ, infer Φ.

   Negation Introduction (-I)        From a subproof with hypothesis Φ
      Reductio ad absurdum (RAA)     ending in (Ψ ∧ -Ψ), close the subproof,
      Proof by Contradiction (PBC)   and infer -Φ.
      Indirect Proof (IP)

   Conjunction Elimination (∧E)      From Φ ∧ Ψ, infer Φ, or infer Ψ.
      Simplification (Simp)

   Conjunction (∧I)                  From Φ and Ψ, infer Φ ∧ Ψ,
                                     or infer Ψ ∧ Φ.

   Disjunction Elimination (∨E)      From Φ ∨ Ψ, Φ → Θ and Ψ → Θ, infer Θ.
      Proof by Cases (PBC)

   Disjunction Introduction (∨I)     From Φ, infer Φ ∨ Ψ, or infer Ψ ∨ Φ.
      Addition (Add)

   Conditional Elimination (→ E)     From Φ → Ψ and Φ, infer Ψ.
      Modus Ponens (MP)

   Conditional Introduction (→ I)    From a subproof with hypothesis Φ
      Conditional Proof (CP)         and ending Ψ, close the subproof,
                                     and infer Ψ → Φ.

   Biconditional Elimination (↔ E)   From Φ ↔ Ψ, infer Φ → Ψ,
                                     or infer Ψ → Φ.

   Biconditional Introduction (↔ I)  From Φ → Ψ and Ψ → Φ, infer Φ ↔ Ψ

   Equivalence Substitution (EQ)     From [ Φ ↔ Ψ ], and Θ(Φ), infer Θ(Ψ/Φ);
                                     or from [ Φ ↔ Ψ ] and Θ(Ψ),
                                     infer Θ(Φ/Ψ).

   --------------------------------  -----------------------------------------

   Definition Substitution (DEF)     From [ Φ =df Ψ ], Θ(Φ), infer Θ(Ψ/Φ);
                                     and [ Φ =df Ψ ], Θ(Ψ), infer Θ(Φ/Ψ).

   --------------------------------  -----------------------------------------

   Universal Elimination (∀E)        From ∀xP infer P(α//x);
                                     where α is any constant object.

   Universal Introduction (∀I)       From a subproof with hypothesis [α] and
                                     ending Ψ(α), close the subproof and
                                     infer ∀xΨ(x//α); where α is new.
                                    
   Existential Elimination (∃E)      From ∃xΦ(x), and a subproof with
                                     hypothesis [α] Φ(α//x) and ending Ψ,
                                     close the subproof and infer Ψ;
                                     where α is new.  Ψ mustn't contain α.

   Existential Introduction (∃I)     From Φ(α), infer ∃xΦ(x/α)

   --------------------------------  -----------------------------------------

   Identity Elimination (=E)         From α=β, and Φ(α) infer Φ(β/α).

   Identity Introduction (=I)        Introduce α=α (for any constant α)
                                     at any step.

   --------------------------------  -----------------------------------------

   Mathematical Induction (MInd)     from P0 and ∀x(Px → Psx), infer ∀xPx
   ================================  =========================================

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  Assumption (A)               |  Hypothesis (H)               |
      | ============================= | ============================= |
      |                               |                               |
      |  ---                          |  -------                      |
      |   Φ   (Φ is a premise)        |   |   Φ   (Φ is a hypothesis) |
      |                               |                               |
      | ============================= | ============================= |
      |  Negation Elim (-E)           |  Negation Intro (-I)          |
      | ============================= | ============================= |
      |   --Φ                         |   |   Φ                       |
      |  -------                      |   |   ...                     |
      |   Φ                           |   |   Ψ ∧ -Ψ                  |
      |                               |  --------------               |
      |                               |   -Φ                          |
      |                               |                               |
      | ============================= | ============================= |
      |  Conjunction Elim (∧E)        |  Conjunction Intro (∧I)       |
      | ============================= | ============================= |
      |   Φ ∧ Ψ    Φ ∧ Ψ              |   Φ        Φ                  |
      |  -------  -------             |   Ψ        Ψ                  |
      |   Φ        Ψ                  |  -------  -------             |
      |                               |   Φ ∧ Ψ    Ψ ∧ Φ              |
      |                               |                               |
      | ============================= | ============================= |
      |  Disjunction Elim (∨E)        |  Disjunction Intro (∨I)       |
      | ============================= | ============================= |
      |   Φ ∨ Ψ                       |   Φ        Φ                  |
      |   Φ → Θ                       |  -------  -------             |
      |   Ψ → Θ                       |   Φ ∨ Ψ    Ψ ∨ Φ              |
      |  --------                     |                               |
      |   Θ                           |    (Ψ is any wff whatever)    |
      |                               |                               |
      | ============================= | ============================= |
      |  Conditional Elim (→ E)       |  Conditional Intro (→ I)      |
      | ============================= | ============================= |
      |   Φ → Ψ                       |   |   Φ                       |
      |   Φ                           |   |   ...                     |
      |  ---------                    |   |   Ψ                       |
      |   Ψ                           |  ---------                    |
      |                               |   Φ → Ψ                       |
      |                               |                               |
      | ============================= | ============================= |
      |  Biconditional Elim (↔ E)     |  Biconditional Intro (↔ I)    |
      | ============================= | ============================= |
      |   Φ ↔ Ψ      Φ ↔ Ψ            |   Φ → Ψ      Φ → Ψ            |
      |  -------    ---------         |   Ψ → Φ      Ψ → Φ            |
      |   Φ → Ψ      Ψ → Φ            |  ---------  ---------         |
      |                               |   Φ ↔ Ψ      Ψ ↔ Φ            |
      |                               |                               |
      | ============================= | ============================= |
      |  Equivalence Subst (EQ)       |  Definition (DEF)             |
      | ============================= | ============================= |
      |   [ Φ ↔ Ψ ]      [ Φ ↔ Ψ ]    |  [ Φ =df Ψ ]    [ Φ =df Ψ ]   |
      |   Θ(Φ)           Θ(Ψ)         |  Θ(Φ)           Θ(Ψ)          |
      |  -------------  ------------- | -------------  -------------  |
      |   Θ(Ψ/Φ)         Θ(Φ/Ψ)       |  Θ(Ψ/Φ)         Θ(Φ/Ψ)        |
      |                               |                               |
      |                               |                               |
      | ============================= | ============================= |
      |  Universal Elim (∀E)          |  Universal Intro (∀I)         |
      | ============================= | ============================= |
      |   ∀x:Φ                        |   |[α]     (new α)            |
      |  --------                     |   |   ...                     |
      |   Φ(α/x)  (any α)             |   |   Ψ(α)                    |
      |                               |  ------------                 |
      |                               |   ∀x:Ψ(x//α)                  |
      |                               |                               |
      | ============================= | ============================= |
      |  Existential Elim (∃E)        |  Existential Intro (∃I)       |
      | ============================= | ============================= |
      |   ∃xΦ(x)                      |   Φ(α)                        |
      |   |[α] Φ(α//x)  (new α)       |  -----------                  |
      |   |   ...                     |   ∃xΦ(x/α)                    |
      |   |   Ψ                       |                               |
      |  ---------------              |                               |
      |   Ψ                           |                               |
      |                               |                               |
      | ============================= | ============================= |
      |  Identity Elim (=E)           |  Identity Intro (=I)          |
      | ============================= | ============================= |
      |   α=β        β=α              |                               |
      |   Φ(α)       Φ(α)             |  -----                        |
      |  --------   --------          |   α=α     α is any constant   |
      |   Φ(β/α)     Φ(β/α)           |                               |
      |                               |                               |
      | ============================= | ============================= |
      |  Mathematical Induct (MInd)   |  Axiom (Ax)                   |
      | ============================= | ============================= |
      |   P0                          |                               |
      |   ∀x(Px → Psx)                |  ---                          |
      |  ---------------              |   Φ       (Φ is an axiom)     |
      |   ∀xPx                        |                               |
      |                               |                               |
      +-------------------------------+-------------------------------+

Derived Inference Rules
=======================

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Reiterate (RE)                    P  ⊢  P
   Falso Quodlibet (EFQ)             P, -P  ⊢  Q    (Q is any wff whatever)
   Modus Tollens (MT)                P → Q, -Q  ⊢  -P
   Hypothetical Syllogism (HS)       P → Q, Q → R  ⊢  P → R
   Absorption (Abs)                  P → Q  ⊢  P → (P ∧ Q)
   Constructive Dilemma (CD)         P ∨ Q, P → R, Q → S  ⊢  R ∨ S
   Destructive Dilemma (DD)          P → Q, R → S, -Q ∨ -S ⊢ -P ∨ -Q
   Bidirectional Dilemma (BD)        P → Q, R → S, P ∨ -S  ⊢  Q ∨ -R
   Disjunctive Syllogism (DS)        P ∨ Q, -P  ⊢  Q
   Disjunctive Syllogism (DS)        P ∨ Q, -Q  ⊢  P
   Theorem (THM)                     [ ⊢ P ]  ⊢  P
   --------------------------------  -----------------------------------------
   ⊥ Introduction (⊥ I)              P, -P  ⊢  ⊥
   ⊥ Elimination (⊥ E)               (P ⊢ ⊥)  ⊢  -P
   ================================  =========================================

Derived Equivalences
====================

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Double Negation (DN)              ⊢  P ↔ --P
   Idempotence (IDEM)                ⊢  P ↔ (P ∧ P)
   Idempotence (IDEM)                ⊢  P ↔ (P ∨ P)
   Transposition (TRANS)             ⊢  (P → Q) ↔ (-Q → -P)
   Material Implication (MI)         ⊢  (P → Q) ↔ (-P ∨ Q)
   Association (ASSOC)               ⊢  (P ∧ (Q ∧ R)) ↔ ((P ∧ Q) ∧ R)
   Association (ASSOC)               ⊢  (P ∨ (Q ∨ R)) ↔ ((P ∨ Q) ∨ R)
   Commutation (COM)                 ⊢  (P ∧ Q) ↔ (Q ∧ P)
   Commutation (COM)                 ⊢  (P ∨ Q) ↔ (Q ∨ P)
   Commutation (COM)                 ⊢  (P ↔ Q) ↔ (Q ↔ P)
   Exportation (EXP)                 ⊢  ((P ∧ Q) → R) ↔ (P → (Q → R))
   Distribution (DIST)               ⊢  (P ∧ (Q ∨ R)) ↔ ((P ∧ Q) ∨ (P ∧ R))
   Distribution (DIST)               ⊢  (P ∨ (Q ∧ R)) ↔ ((P ∨ Q) ∧ (P ∨ R))
   DeMorgan's law (DM)               ⊢  -(P ∧ Q) ↔ (-P ∨ -Q)
   DeMorgan's law (DM)               ⊢  -(P ∨ Q) ↔ (-P ∧ -Q)
   Material Equivalence (ME)         ⊢  (P ↔ Q) ↔ ((P → Q) ∧ (Q → P))
   Material Equivalence (ME)         ⊢  (P ↔ Q) ↔ ((P ∧ Q) ∨ (-P ∧ -Q))
   Dual                              ⊢  -∀x-Φ ↔ ∃xΦ
   Dual                              ⊢  -∀xΦ ↔ ∃x-Φ
   Dual                              ⊢  ∀x-Φ ↔ -∃xΦ
   Dual                              ⊢  ∀xΦ ↔ -∃x-Φ
   ================================  =========================================


==================================
Appendix C: Proof of Derived Forms
==================================

Important Derived Rules
=======================

⊥ Inference Rules
-----------------

   ⊥ Introduction (⊥ I):   P, -P  ⊢  ⊥
   Proof
   01.   P                        A
   02.   -P                       A
   03.   P ∧ -P                   1,2 ∧I
   04.   ⊥                        3 DEF ⊥
   QED

   ⊥ Elimination (⊥ E):   (P ⊢ ⊥)  ⊢  -P
   Schematic Proof
    i.   |   P                    H (for → I)
    ...  |   ...                  ...
    j.   |   ⊥
    k.   P → ⊥                    i - j → I
    k+1. |   P                    H (for -I)
    k+2. |   ⊥                    k,k+1 → E
    k+3. |   P ∧ -P               k+2 DEF ⊥
    k+4. -P                       k+1 - k+3 -I
    QED

The Remaining Basic Derived Rules
---------------------------------

   Reiterate (RE):   P   ⊢   P
   Proof
   01.   P                        A
   02.   P ∧ P                    1,1 ∧I
   03.   P                        2 ∧E
   QED

   Ex Falso Quodlibet (EFQ):   P, -P  ⊢  Q
   Proof
   01.   P                        A
   02.   -P                       A
   03.   |   -Q                   H (for -I)
   04.   |   P ∧ -P               1,2 ∧I
   05.   --Q                      3-4 -I
   06.   Q                        5 -E
   QED

   Modus Tollens (MT):   P → Q, -Q  ⊢  -P
   Proof
   01.   P → Q                    A
   02.   -Q                       A
   03.   |   P                    H (for -I)
   04.   |   Q                    1,3 → E
   05.   |   ⊥                    2,4 ⊥ I
   06.   -P                       3-5 ⊥ E
   QED

   Hypothetical Syllogism (HS):   P → Q, Q → R  ⊢  P → R
   Proof
   01.   P → Q                    A
   02.   Q → R                    A
   03.   |   P                    H (for R)
   04.   |   Q                    1,3 → E
   05.   |   R                    2,4 → E
   06.   P → R                    3-5 → I
   QED

   Absorption (ABS):  P → Q  ⊢  P → (P ∧ Q)
   Proof
   01.   P → Q                    A
   02.   |   P                    H (for P ∧ Q)
   03.   |   Q                    1,2 → E
   04.   |   P ∧ Q                2,3 ∧I
   05.   P → (P ∧ Q)              2-4 → I
   QED

   Constructive Dilemma (CD):   P ∨ Q, P → R, Q → S  ⊢  R ∨ S
   Proof
   01.   P ∨ Q                    A
   02.   P → R                    A
   03.   Q → S                    A
   04.   |   P                    H (for → I)
   05.   |   R                    2,4 → E
   06.   |   R ∨ S                5 ∨I
   07.   P → (R ∨ S)              4-6 → I
   08.   |   Q                    H (for → I)
   09.   |   S                    3,8 → E
   10.   |   R ∨ S                9 ∨I
   11.   Q → (R ∨ S)              9-12 → I
   12.   R ∨ S                    1,7,11 ∨E
   QED

   Destructive Dilemma (DD):    P → Q, R → S, -Q ∨ -S  ⊢  -P ∨ -R
   Proof
   01.   P → Q                    A
   02.   R → S                    A
   03.   -Q ∨ -S                  A
   04.   |   -Q                   H (for → I)
   05.   |   -P                   1,4 MT
   06.   |   -P ∨ -R              5 ∨I
   07.   -Q → (-P ∨ -R)           4-6 → I
   08.   |   -S                   H (for → I)
   09.   |   -R                   2,8 MT
   10.   |   -P ∨ -R              9 ∨I
   11.   -S → (-P ∨ -R)           8-10 → I
   12.   -P ∨ -R                  3,7,11 ∨E
   QED

   Bidirectional Dilemma (BD)        P → Q, R → S, P ∨ -S  ⊢  Q ∨ -R
   Proof
   01.   P → Q                    A
   02.   R → S                    A
   03.   P ∨ -S                   A
   04.   |   P                    H (for → I)
   05.   |   Q                    1,4 → E
   06.   |   Q ∨ -R               5 ∨ I
   07.   P → (Q ∨ -R)             4-6 → I
   08.   |   -S                   H (for → I)
   09.   |   -R                   2,8 MT
   10.   |   Q ∨ -R               9 ∨I
   11.   -S → (Q ∨ -R)            8-10 → I
   12.   Q ∨ -R                   3,7,11 ∨E
   QED

   Disjunctive Syllogism (DS):  P ∨ Q, -P  ⊢  Q
   Proof
   01.   P ∨ Q                    A
   02.   -P                       A
   03.   |   P                    H (for → I)
   04.   |   Q                    2,3 EFQ
   05.   P → Q                    3-4 → I
   06.   |   Q                    H (for → I)
   07.   |   Q                    6 RE
   08.   Q → Q                    6-7 → I
   09.   Q                        1,5,8 ∨E
   QED

   Disjunctive Syllogism (DS):   P ∨ Q, -Q  ⊢  P
   Proof
   01.   P ∨ Q                    A
   02.   -Q                       A
   03.   |   P                    H (for → I)
   04.   |   P                    3 RE
   05.   P → P                    3-4 → I
   06.   |   Q                    H (for → I)
   07.   |   P                    2,6 EFQ
   08.   Q → P                    6-7 → I
   09.   P                        1,5,8 ∨E
   QED

Important Derived Equivalences
------------------------------

   Double Negation (DN):   ⊢  P ↔ --P
   Proof
   01.   |   P                    H (for → I)
   02.   |   |   -P               H (for -I)
   03.   |   |   ⊥                1,2 ⊥ I
   04.   |   --P                  2-3 -I
   05.   P → --P                  1-4 → I
   06.   |   --P                  H (for → I)
   07.   |   P                    6 -E
   08.   --P → P                  6,7 → I
   09.   P ↔ --P                  5,8 ↔ I
   QED

   Idempotence (IDEM):   ⊢  P ↔ (P ∧ P)
   Poof
   01.   |   P                    H (for → I)
   02.   |   P ∧ P                1,1 ∧I
   03.   P → (P ∧ P)              2-3 → I
   04.   |   P ∧ P                H (for → I)
   05.   |   P                    4 ∧E
   06.   (P ∧ P) → P              4-5 → I
   07.   P ↔ (P ∧ P)              3,6 ↔ I
   QED

   Idempotence (IDEM):   ⊢  P ↔ (P ∨ P)
   Proof
   01.   |   P                    H (for → I)
   02.   |   P ∨ P                1 ∨I
   03.   P → (P ∨ P)              1-2 → I
   04.   |   P ∨ P                H (for → I)
   05.   |   |   P                H (for → I)
   06.   |   |   P                5 RE
   07.   |   P → P                5-6 → I
   08.   |   P → P                7 RE
   09.   |   P                    4,7,8 ∨E
   10.   (P ∨ P) → P              4-9 → I
   11.   P ↔ (P ∨ P)              3,10 ↔ I
   QED

   Transposition (TRANS):  ⊢  (P → Q) ↔ (-Q → -P)
   Proof
   01.   |   P → Q                H (for → I)
   02.   |   |   -Q               H (for → I)
   03.   |   |   -P               1,2 MT
   04.   |   -Q → -P              2-3 → I
   05.   (P → Q) → (-Q → -P) 1-4 →I
   06.   |   -Q → -P              H (for → I)
   07.   |   |   P                H (for → I)
   08.   |   |   --P              7 DN
   09.   |   |   --Q              6,8 MT
   10.   |   |   Q                9 -E
   11.   |   P → Q                7-10 → I
   12.   (-Q → -P) → (P → Q)      6-11 → I
   13.   (P → Q) ↔ (-Q → -P)      5,12 ↔ I
   QED

   Material Implication (MI):   ⊢  (P → Q) ↔ (-P ∨ Q)
   Proof
   01.   |   P → Q                H (for → I)
   02.   |   |   -(-P ∨ Q)        H (for -I)
   03.   |   |   |   P            H (for -I)
   04.   |   |   |   Q            1,3 → E
   05.   |   |   |   -P ∨ Q       4 ∨I
   06.   |   |   |   ⊥            2,5 ⊥ I
   07.   |   |   -P               3-6 ⊥ E
   08.   |   |   -P ∨ Q           7 ∨I
   09.   |   |   ⊥                2,8 ⊥ I
   10.   |   --(-P ∨ Q)           2-9 ⊥ E
   11.   |   -P ∨ Q               10 -E
   12.   (P → Q) → (-P ∨ Q)       1-11 → I
   13.   |   -P ∨ Q               H (for → I)
   14.   |   |   P                H (for -I)
   15.   |   |   --P              14 DN
   16.   |   |   Q                13,15 DS
   17.   |   P → Q                14-16 → I
   18.   (-P ∨ Q) → (P → Q)       13-17 → I
   19.   (P → Q) ↔ (-P ∨ Q)       12,18 ↔ I
   QED

   Association (ASSOC):   ⊢  (P ∧ (Q ∧ R)) ↔ ((P ∧ Q) ∧ R)
   Proof
   01.   |   P ∧ (Q ∧ R)                         H (for →I)
   02.   |   P                                   1 ∧E
   03.   |   Q ∧ R                               1 ∧E
   04.   |   Q                                   3 ∧E
   05.   |   R                                   3 ∧E
   06.   |   P ∧ Q                               2,4 ∧I
   07.   |   (P ∧ Q) ∧ R                         5,6 ∧I
   08.   (P ∧ (Q ∧ R)) → ((P ∧ Q) ∧ R)           1-7 →I
   09.   |   (P ∧ Q) ∧ R                         H (for → I)
   10.   |   P ∧ Q                               9 ∧E
   11.   |   R                                   9 ∧E
   12.   |   P                                   10 ∧E
   13.   |   Q                                   10 ∧E
   14.   |   Q ∧ R                               11,13 ∧I
   15.   |   P ∧ (Q ∧ R)                         12,14 ∧I
   16.   ((P ∧ Q) ∧ R) → (P ∧ (Q ∧ R))           9-15 → I
   17.   (P ∧ (Q ∧ R)) ↔ ((P ∧ Q) ∧ R)           8,16 ↔ I
   QED

   Association (ASSOC):   ⊢  (P ∨ (Q ∨ R)) ↔ ((P ∨ Q) ∨ R)
   Proof
   01.   |   P ∨ (Q ∨ R)                         H (for → I)
   02.   |   |   P                               H (for → I)
   03.   |   |   P ∨ Q                           2 ∨I
   04.   |   |   (P ∨ Q) ∨ R                     3 ∨I
   05.   |   P → ((P ∨ Q) ∨ R)                   2-4 → I
   06.   |   |   Q ∨ R                           H (for → I)
   07.   |   |   |   Q                           H (for → I)
   08.   |   |   |   P ∨ Q                       7 ∨I
   09.   |   |   |   (P ∨ Q) ∨ R                 8 ∨I
   10.   |   |   Q → ((P ∨ Q) ∨ R)               7-9 → I
   11.   |   |   |   R                           H (for → I)
   12.   |   |   |   (P ∨ Q) ∨ R                 11 ∨I
   13.   |   |   R → ((P ∨ Q) ∨ R)               11-12 → I
   14.   |   |   (P ∨ Q) ∨ R                     6,10,13 ∨E
   15.   |   (Q ∨ R) → ((P ∨ Q) ∨ R)             6-14 → I
   16.   |   (P ∨ Q) ∨ R                         1,5,15 ∨E
   17.   (P ∨ (Q ∨ R)) → ((P ∨ Q) ∨ R)           1-16 → I
   18.   |   (P ∨ Q) ∨ R                         H (for → I)
   19.   |   |   P ∨ Q                           H (for → I)
   20.   |   |   |   P                           H (for → I)
   21.   |   |   |   P ∨ (Q ∨ R)                 20 ∨I
   22.   |   |   P → (P ∨ (Q ∨ R))               20-21 → I
   23.   |   |   |   Q                           H (for → I)
   24.   |   |   |   Q ∨ R                       23 ∨I
   25.   |   |   |   P ∨ (Q ∨ R)                 14 ∨I
   26.   |   |   Q → (P ∨ (Q ∨ R))               23-25 → I
   27.   |   |   P ∨ (Q ∨ R)                     19,22,26 ∨E
   28.   |   (P ∨ Q) → (P ∨ (Q ∨ R))             19-27 → I
   29.   |   |   R                               H (for → I)
   30.   |   |   Q ∨ R                           29 ∨I
   31.   |   |   P ∨ (Q ∨ R)                     30 ∨I
   32.   |   R → (P ∨ (Q ∨ R))                   29-31
   33.   |   P ∨ (Q ∨ R)                         13,28,32 ∨E
   34.   ((P ∨ Q) ∨ R) → (P ∨ (Q ∨ R))           18-33 → I
   35.   (P ∨ (Q ∨ R)) ↔ ((P ∨ Q) ∨ R)           17,34 ↔ I
   QED

   Commutation (COM):   ⊢  (P ∧ Q) ↔ (Q ∧ P)
   Proof
   01.   |   P ∧ Q                               H (for → I)
   02.   |   P                                   1 ∧E
   03.   |   Q                                   1 ∧E
   04.   |   Q ∧ P                               2,3 ∧I
   05.   (P ∧ Q) → (Q ∧ P)                       1-4 → I
   06.   |   Q ∧ P                               H (for → I)
   07.   |   Q                                   ∧E
   08.   |   P                                   ∧E
   09.   |   P ∧ Q                               ∧I
   10.   (Q ∧ P) → (P ∧ Q)                       6-9 → I
   11.   (P ∧ Q) ↔ (Q ∧ P)                       5,10 ↔ I
   QED

   Commutation (COM):   ⊢  (P ∨ Q) ↔ (Q ∨ P)
   Proof
   01.   |   P ∨ Q                               H (for → I)
   02.   |   |   P                               H (for → I)
   03.   |   |   Q ∨ P                           2 ∨I
   04.   |   P → (Q ∨ P)                         2-4 → I
   05.   |   |   Q                               H (for → I)
   06.   |   |   Q ∨ P                           5 ∨I
   07.   |   Q → (Q ∨ P)                         5-6 → I
   08.   |   Q ∨ P                               1,4,7 ∨E
   09.   (P ∨ Q) → (Q ∨ P)                       1-8 → I
   10.   |   Q ∨ P                               H (for → I)
   11.   |   |   Q                               H (for → I)
   12.   |   |   P ∨ Q                           11 ∨I
   13.   |   Q → (P ∨ Q)                         11-12 → I
   14.   |   |   P                               H (for → I)
   15.   |   |   P ∨ Q                           14 ∨I
   16.   |   P → (P ∨ Q)                         14-15 → I
   17.   |   P ∨ Q                               10,13,16 ∨E
   18.   (Q ∨ P) → (P ∨ Q)                       10-17 → I
   19.   (P ∨ Q) ↔ (Q ∨ P)                       9,18 ↔ I
   QED

   Commutation (COM):   ⊢  (P ↔ Q) ↔ (Q ↔ P)
   Proof
   01.   |   P ↔ Q                               H (for → I)
   02.   |   P → Q                               1 ↔ E
   03.   |   Q → P                               1 ↔ E
   04.   |   Q ↔ P                               2,3 ↔ I
   05.   (P ↔ Q) → (Q ↔ P)                       1-10 → I
   06.   |   Q ↔ P                               H (for → I)
   07.   |   Q → P                               6 ↔ E
   08.   |   P → Q                               6 ↔ E
   09.   |   P ↔ Q                               7,8 ↔ I
   10.   (Q ↔ P) → (P ↔ Q)                       6-9 → I
   11.   (P ↔ Q) ↔ (Q ↔ P)                       5,10 ↔ I
   QED

   Exportation (EXP):   ⊢  ((P ∧ Q) → R) ↔ (P → (Q → R))
   Proof
   01.   |   (P ∧ Q) → R                         H (for → I)
   02.   |   |   P                               H (for → I)
   03.   |   |   |   Q                           H (for → I)
   04.   |   |   |   P ∧ Q                       2,3 ∧I
   05.   |   |   |   R                           1,4 → E
   06.   |   |   Q → R                           3-5 → I
   07.   |   P → (Q → R)                         2-6 → I
   08.   ((P ∧ Q) → R) → (P → (Q → R))           1-7 → I
   09.   |   P → (Q → R)                         H (for → I)
   10.   |   |   P ∧ Q                           H (for → I)
   11.   |   |   P                               13 ∧E
   12.   |   |   Q → R                           9,11 → E
   13.   |   |   Q                               10 ∧E
   14.   |   |   R                               12,13 → E
   15.   |   (P ∧ Q) → R                         10-14 → I
   16.   (P → (Q → R)) → ((P ∧ Q) → R)           9-15 → I
   17.   ((P ∧ Q) → R) ↔ (P → (Q → R))           8,16 ↔ I
   QED

   Distribution (DIST):   ⊢  (P ∧ (Q ∨ R)) ↔ ((P ∧ Q) ∨ (P ∧ R))
   Proof
   01.   |   P ∧ (Q ∨ R)                         H (for → I)
   02.   |   P                                   1 ∧E
   03.   |   Q ∨ R                               1 ∧E
   04.   |   |   Q                               H (for → I)
   05.   |   |   P ∧ Q                           2,4 ∧I
   06.   |   |   (P ∧ Q) ∨ (P ∧ R)               5 ∨I
   07.   |   Q → ((P ∧ Q) ∨ (P ∧ R))             4-6 → I
   08.   |   |   R                               H (for → I)
   09.   |   |   P ∧ R                           2,8 ∧I
   10.   |   |   (P ∧ Q) ∨ (P ∧ R)               9 ∨I
   11.   |   R → ((P ∧ Q) ∨ (P ∧ R))             8-10 → I
   12.   |   (P ∧ Q) ∨ (P ∧ R)                   3,7,11 ∨E
   13.   (P ∧ (Q ∨ R)) → ((P ∧ Q) ∨ (P ∧ R))     1-12 → I
   14.   |   (P ∧ Q) ∨ (P ∧ R)                   H (for → I)
   15.   |   |   P ∧ Q                           H (for → I)
   16.   |   |   P                               15 ∧E
   17.   |   |   Q                               15 ∧E
   18.   |   |   Q ∨ R                           17 ∨I
   19.   |   |   P ∧ (Q ∨ R)                     17,18 ∧I
   20.   |   (P ∧ Q) → (P ∧ (Q ∨ R))             15-18 → I
   21.   |   |   P ∧ R                           H (for → I)
   22.   |   |   P                               21 ∧E
   23.   |   |   R                               21 ∧E
   24.   |   |   Q ∨ R                           23 ∨I
   25.   |   |   P ∧ (Q ∨ R)                     24 ∧I
   26.   |   (P ∧ R) → (P ∧ (Q ∨ R))             21-25 → I
   27.   |   P ∧ (Q ∨ R)                         14,20,26 ∨E
   28.   ((P ∧ Q) ∨ (P ∧ R)) → (P ∧ (Q ∨ R))     14-27 → I
   29.   (P ∧ (Q ∨ R)) ↔ ((P ∧ Q) ∨ (P ∧ R))     13,28 ↔ I
   QED

   Distribution (DIST):   ⊢  (P ∨ (Q ∧ R)) ↔ ((P ∨ Q) ∧ (P ∨ R))
   Proof
   01.   |   P ∨ (Q ∧ R)                         H (for → I)
   02.   |   |   P                               H (for → I)
   03.   |   |   P ∨ Q                           2 ∨I
   04.   |   |   P ∨ R                           2 ∨I
   05.   |   |   (P ∨ Q) ∧ (P ∨ R)               3,4 ∧I
   06.   |   P → ((P ∨ Q) ∧ (P ∨ R))             2-5 → I
   07.   |   |   Q ∧ R                           H (for → I)
   08.   |   |   Q                               7 ∧E
   09.   |   |   R                               7 ∧E
   10.   |   |   P ∨ Q                           8 ∨I
   11.   |   |   P ∨ R                           9 ∨I
   12.   |   |   (P ∨ Q) ∧ (P ∨ R)               10,11 ∧I
   13.   |   (Q ∧ R) → ((P ∨ Q) ∧ (P ∨ R))       7-12 → I
   14.   |   (P ∨ Q) ∧ (P ∨ R)                   1,6,13 ∨E
   15.   (P ∨ (Q ∧ R)) → ((P ∨ Q) ∧ (P ∨ R))     1-14 → I
   16.   |   (P ∨ Q) ∧ (P ∨ R)                   H (for → I)
   17.   |   P ∨ Q                               18 ∧E
   18.   |   P ∨ R                               16 ∧E
   19.   |   |   P                               H (for → I)
   20.   |   |   P ∨ (Q ∧ R)                     19 ∨I
   21.   |   P → (P ∨ (Q ∧ R))                   19-20 → I
   22.   |   |   Q                               H (for → I)
   23.   |   |   |   R                           H (for → I)
   24.   |   |   |   Q ∧ R                       22,23 ∧I
   25.   |   |   |   P ∨ (Q ∧ R)                 24 ∨I
   26.   |   |   R → (P ∨ (Q ∧ R))               23-25 → I
   27.   |   |   P ∨ (Q ∧ R)                     28,21,26 ∨E
   28.   |   Q → (P ∨ (Q ∧ R))                   22-26 → I
   29.   |   P ∨ (Q ∧ R)                         17,21,28 ∨E
   30.   ((P ∨ Q) ∧ (P ∨ R)) → (P ∨ (Q ∧ R))     16-29 → I
   31.   (P ∨ (Q ∧ R)) ↔ ((P ∨ Q) ∧ (P ∨ R))     15,30 ↔ I
   QED

   DeMorgan's law (DM): ⊢  -(P ∧ Q) ↔ (-P ∨ -Q)
   Proof
   01.   |   -(P ∧ Q)                            H (for → I)
   02.   |   |   -(-P ∨ -Q)                      H (for -I)
   03.   |   |   |   -P                          H (for -I)
   04.   |   |   |   -P ∨ -Q                     3 ∨I
   05.   |   |   |   ⊥                           2,4 ⊥ I
   06.   |   |   --P                             3-5 ⊥ E
   07.   |   |   P                               6 -E
   08.   |   |   |   -Q                          H (for -I)
   09.   |   |   |   -P ∨ -Q                     8 ∨I
   10.   |   |   |   ⊥                           2,9 ⊥ I
   11.   |   |   --Q                             9-10 ⊥ E
   12.   |   |   Q                               11 -E
   13.   |   |   P ∧ Q                           7,12 ∧I
   14.   |   |   ⊥                               1,13 ⊥ I
   15.   |   --(-P ∨ -Q)                         2-14 ⊥ E
   16.   |   -P ∨ -Q                             15 -E
   17.   -(P ∧ Q) → (-P ∨ -Q)                    1-16 → I
   18.   |   -P ∨ -Q                             H (for → I)
   19.   |   |   P ∧ Q                           H (for -I)
   20.   |   |   P                               19 ∧E
   21.   |   |   Q                               19 ∧E
   22.   |   |   --P                             20 DN
   23.   |   |   -Q                              18,22 DS
   24.   |   |   ⊥                               21,23 ⊥ I
   25.   |   -(P ∧ Q)                            19-24 ⊥ E
   26.   (-P ∨ -Q) → -(P ∧ Q)                    18-25 → I
   27.   -(P ∧ Q) ↔ (-P ∨ -Q)                    17,26 ↔ I
   QED

   DeMorgan's law (DM)  ⊢  -(P ∨ Q) ↔ (-P ∧ -Q)
   Proof
   01.   |   -(P ∨ Q)                            H (for → I)
   02.   |   |   -(-P ∧ -Q)                      H (for -I)
   03.   |   |   |   P                           H (for -I)
   04.   |   |   |   P ∨ Q                       3 ∨I
   05.   |   |   |   ⊥                           1,4 ⊥ I
   06.   |   |   -P                              3-5 ⊥ E
   07.   |   |   |   Q                           H (for -I)
   08.   |   |   |   P ∨ Q                       7 ∨I
   09.   |   |   |   ⊥                           1,8 ⊥ I
   10.   |   |   -Q                              7-9 ⊥ E
   11.   |   |   -P ∧ -Q                         6,10 ∧I
   12.   |   |   ⊥                               2,11 ⊥ I
   13.   |   -P ∧ -Q                             2-12 ⊥ E
   14.   -(P ∨ Q) → (-P ∧ -Q)                    1-13 → I
   15.   |   -P ∧ -Q                             H (for → I)
   16.   |   |   P ∨ Q                           H (for -I)
   17.   |   |   -P                              15 ∧E
   18.   |   |   -Q                              15 ∧E
   19.   |   |   Q                               16,18 DS
   20.   |   |   ⊥                               18,19 ⊥ I
   21.   |   -(P ∨ Q)                            16-20 ⊥ E
   22.   (-P ∧ -Q) → -(P ∨ Q)                    15-21 → I
   23.   -(P ∨ Q) ↔ (-P ∧ -Q)                    14,22 ↔ I
   QED

   Material Equivalence (ME):  ⊢  (P ↔ Q) ↔ ((P → Q) ∧ (Q → P))
   Proof
   01.   |   P ↔ Q                              H (for → I)
   02.   |   P → Q                              1 ↔E
   03.   |   Q → P                              1 ↔E
   04.   |   (P → Q) ∧ (Q → P)                  2,3 ∧I
   05.   (P ↔ Q) → ((P → Q) ∧ (Q → P))          1-4 → I
   06.   |   (P → Q) ∧ (Q → P)                  H (for → I)
   07.   |   P → Q                              6 ∧E
   08.   |   Q → P                              6 ∧E
   09.   |   P ↔ Q                              7,8 ↔ I
   10.   ((P → Q) ∧ (Q → P)) → (P ↔ Q)          6-9 → I
   11.   (P ↔ Q) ↔ ((P → Q) ∧ (Q → P))          5,10 ↔ I
   QED

   Material Equivalence (ME):  ⊢  (P ↔ Q) ↔ ((P ∧ Q) ∨ (-P ∧ -Q))
   Proof
   01.   |   P ↔ Q                               H (for → I)
   02.   |   P → Q                               1 ↔ E
   03.   |   Q → P                               1 ↔ E
   04.   |   |   -((P ∧ Q) ∨ (-P ∧ -Q))          H (for -I)
   05.   |   |   -(P ∧ Q) ∧ -(-P ∧ -Q)           4 DM
   06.   |   |   -(P ∧ Q)                        5 ∧E
   07.   |   |   -(-P ∧ -Q)                      5 ∧E
   08.   |   |   -P ∨ -Q                         6 DM
   09.   |   |   P ∨ Q                           7 DM
   10.   |   |   |   -P                          H (for → I)
   11.   |   |   |   -Q                          2,10 MT
   12.   |   |   |   P                           9,10 DS
   13.   |   |   |   ⊥                           10,11 ⊥ I
   14.   |   |   -P → ⊥                          10-13 → I
   15.   |   |   |   -Q                          H (for → I)
   16.   |   |   |   -P                          2,15 MT
   17.   |   |   |   P                           9,15 DS
   18.   |   |   |   ⊥                           16,17 ⊥ I
   19.   |   |   -Q → ⊥                          15-18 → I
   20.   |   |   ⊥                               8,14,19 ∨E
   21.   |   (P ∧ Q) ∨ (-P ∧ -Q)                 4-20 ⊥ E
   22.   (P ↔ Q) → ((P ∧ Q) ∨ (-P ∧ -Q))         1-21 → I
   23.   |   (P ∧ Q) ∨ (-P ∧ -Q)                 H (for → I)
   24.   |   |   P ∧ Q                           H (for → I)
   25.   |   |   |   P                           H (for → I)
   26.   |   |   |   Q                           24 ∧E
   27.   |   |   P → Q                           25-26 → I
   28.   |   |   |   Q                           H (for → I)
   29.   |   |   |   P                           24 ∧E
   30.   |   |   Q → P                           28-29 → I
   31.   |   |   P ↔ Q                           27,30 ↔ I
   32.   |   (P ∧ Q) → (P ↔ Q)                   24-31 → I
   33.   |   |   -P ∧ -Q                         H (for → I)
   34.   |   |   |   -P                          H (for → I)
   35.   |   |   |   -Q                          33 ∧E
   36.   |   |   -P → -Q                         34-35 → I
   37.   |   |   Q → P                           36 TRANS
   38.   |   |   |   -Q                          H (for → I)
   39.   |   |   |   -P                          33 ∧E
   40.   |   |   -Q → -P                         37-38 → I
   41.   |   |   P → Q                           40 TRANS
   42.   |   |   P ↔ Q                           37,41 ↔ I
   43.   |   (-P ∧ -Q) → (P ↔ Q)                 33-42 → I
   44.   ((P ∧ Q) ∨ (-P ∧ -Q)) → (P ↔ Q)         23-44 → I
   45.   (P ↔ Q) ↔ ((P ∧ Q) ∨ (-P ∧ -Q))         22,44 ↔ I
   QED


=================================
Appendix D: UTF-8 Character Codes
=================================

   Symbol                                              code point
   ==================================================  ==========
   Logical Symbols

   ∴            therefore                              2234
   ∵            because                                2235
   ￢           negation                               FFE2
   ∧            conjunction                            2227
   ∨            disjunction                            2228
   →            conditional                            2192
   ↔            biconditional                          2194
   ←            reverse conditional, only if           2190
   ∀            universal quantifier                   2200
   ∃            existential quantifier                 2203
   ℩            definite descriptor (inverted iota)    2129
   □            box                                    25A1
   ◇            diamond                                25C7
   ■            solid box                              25A0
   ◆            solid diamond                          25C6
   T            tautology, valid wff                   22A4
   ⊥            contradiction (inverted T)             22A5
   ⊢            entails (turnstile)                    22A2
   ⊬            doesn't entail                         22AC
   ⊨            satisfies                              22A8
   ⊭            doesn't satisfy                        22AD
   𝕸            model function                         0001D578

   Set Theory Symbols

   ∅  or  null  empty set                              2205
   ∊            membership                             220A
   ⊂            proper subset                          2282
   ⊆            subset                                 2286
   ⊃            proper superset                        2283
   ⊇            superset                               2287
   ∪            union                                  222A
   ∩            intersection                           2229
   
   Mathematical Symbols

   ≠            is not equal to                        2260
   ≤            is less than or equal to               2264
   ≥            is greater than or equal to            2265

   Box Drawing Symbols

   ┌            top left                               250C
   ┐            top right                              2510
   ─            horizontal                             2500
   │            vertical                               2502
   ┬            horizontal down                        252C
   ┴            horizontal up                          2534
   ┼            plus                                   253C
   ├            vertical right                         251C
   ┤            vertical left                          2524
   └            bottom left                            2514
   ┘            bottom right                           2518

   ═            double horizontal                      2550
   ║            double vertical                        2551

   *vim trick:  command :as or ga displays the code point for the character
                under the cursor


==============================
Appendix E: The Greek Alphabet
==============================

   The Greek Alphabet

      Upper              Lower

   Sym   Name         Sym   Name
   -------------     ------------------
   Α     ALPHA        α     alpha
   Β     BETA         β     beta
   Γ     GAMMA        γ     gamma
   Δ     DELTA        δ     delta
   Ε     EPSILON      ε     epsilon
   Ζ     ZETA         ζ     zeta
   Η     ETA          η     eta
   Θ     THETA        θ     theta
   Ι     IOTA         ι     iota
   Κ     KAPPA        κ     kappa
   Λ     LAMBDA       λ     lambda
   Μ     MU           μ     mu
   Ν     NU           ν     nu
   Ξ     XI           χ     xi
   Ο     OMICRON      ο     omicron
   Π     PI           π     pi
   Ρ     RHO          ρ     rho
   Σ     SIGMA        σ     sigma
   Τ     TAU          τ     tau
   Υ     UPSILON      υ     upsilon
   Φ     PHI          φ     phi
   Χ     CHI          χ     chi
   Ψ     PSI          ψ     psi
   Ω     OMEGA        ω     omega


