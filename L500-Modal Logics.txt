##############################################################################
##############################################################################
##############################################################################
##############################################################################
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######          ##############################################          ######
######          ##############################################          ######
######          ###                                        ###          ######
######          ###              Retro Notes               ###          ######
######          ###                                        ###          ######
######          ###              Modal Logics              ###          ######
######          ###                                        ###          ######
######          ##############################################          ######
######          ##############################################          ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
######                     AtomicRetro@outlook.com                      ######
######                                                                  ######
######                     Revision:  20.10.05                          ######
######                                                                  ######
######                                                                  ######
######                                                                  ######
##############################################################################
##############################################################################
##############################################################################
##############################################################################

....|....1....|....2....|....3....|....4....|....5....|....6....|....7....|...


==============================
To View This Document Properly
==============================
* Best if viewed in VIM using with settings
     :set columns=80
     :set encoding=utf-8

* This document must be viewed with a mono-spaced font to enjoy the layout,
  tables and diagrams.

* This document must be viewed in an editor that can display unicode utf-8.


======================
Truth-Functional Logic
======================

Here we'll introduce an austere Logic and Fitch-Style Calculus introduced
by Garson and which we'll call Garson-Fitch.  The system has just two
operators, but a more robust system can be developed from it.


Formal Language (TFL)
---------------------

Lexemes

   Non-Logical Symbols
      Proposition Symbols:      A...Z

   Logical Symbols
      Truth-Function Symbols:   ->, ⊥
      Association Symbols:      (, )

Grammar (Formation Rules for Well-Formed Formulas)

   An ATOMIC FORMULA is either ⊥ or any proposition symbol.

   1.  every atomic formula is a wff;
   2.  if P,Q  are wffs, then (P -> Q) is a wff;
   3.  nothing else is a wff.

   Notes

   - To aid readability of a wffs we adopt the convention that if a wff
     that begins with '(', we will drop the outer-most pair of parenthesis.

   - In practice it's common to use tick marks or numerical subscripts
     (we use postscripts) after the proposition symbol to increase to
     infinity the number of available symbols.

Definitions

   We define the remaining truth-functions as follows:

      Def -:    ¬P         =df  (P -> ⊥)
      Def ∧:    (P ∧ Q)    =df  ¬(P -> ¬Q)
      Def ∨:    (P ∨ Q)    =df  (¬P -> Q)
      Def <->:  (P <-> Q)  =df  ((P -> Q) ∧ (Q -> P))


Semantics
---------

Valuation Function

   The valuation function v for our minimal TFL is defined as follows:

      v(⊥)      = false
      v(P -> Q) = true  if P is false or Q is true;
                  false if P is true and Q is false


Truth-Functional Calculus (TFC - Garson-Fitch System)
-----------------------------------------------------

Regarding The Inference Rules

   P(Q) indicates that a wff P contains one or more occurrences of
   sub-expression Q.

   P(R/Q) indicates the result of replacing one or more occurrences
   of Q in P with R.  R/Q is read, "R replaced one or more occurrences of Q".

   P(R//Q) like above but indicates replacing all occurrences of Q in P with
   R.  R//Q is read, "R replaced all occurrences of Q"

   [ ... ] indicate that the enclosed must already exist, be defined or
   proven elsewhere (outside of the proof).

Primitive Inference Rules
 
   ================================  =========================================
   Name/Alternate Names              Rule
   ================================  =========================================
   Assumption (A)                    Introduce a premise at any step.

   Hypothesis (H)                    Introduce a hypothesis at any step
                                     provided it begins a new subproof.

   Axiom (Ax)                        Introduce an axiom at any step.

   Conditional Elimination (->E)     From P -> Q and P, infer Q; all within
      Modus Ponens (MP)              the same subproof.

   Conditional Introduction (->I)    From a subproof with hypothesis P
      Conditional Proof (CP)         and ending Q, close the subproof,
                                     and infer Q -> P.

   Negation Elimination (¬E)         From ¬¬p, infer p; all with the
                                     same subproof.

   Reiterate (RE)                    From P, infer P into the same subproof,
                                     or into an immediately nested subproof.

   Equivalence Substitution (EQ)     From P <-> Q, and R(P), infer R(Q/P),
                                     or from P <-> Q and R(Q), infer R(P/Q).
   ================================  =========================================

   Note: Apart from RE we can only appeal to lines in the current subproof.

   These rules are sometimes represented more visually.  The horizontal bar
   denotes 'infer', vertical lines denote subproofs, other symbology comes
   directly from my modified sequent notation.

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  A                            |  H                            |
      | ============================= | ============================= |
      |                               |                               |
      |  ---                          |  -------                      |
      |   P   (P is a premise)        |   |   P   (P is a hypothesis) |
      |                               |                               |
      | ============================= | ============================= |
      |  ->E                          |  ->I                          |
      | ============================= | ============================= |
      |   P -> Q                      |   |   P                       |
      |   P                           |   |   ...                     |
      |  ---------                    |   |   Q                       |
      |   Q   (all in one subproof)   |  ---------                    |
      |                               |   P -> Q                      |
      |                               |                               |
      | ============================= | ============================= |
      |  ¬E                           |  EQ (Equiv. Substitution)     |
      | ============================= | ============================= |
      |   ¬¬P                         |   [ P <-> Q ]    [ P <-> Q ]  |
      |  -----                        |   R(P)           R(Q)         |
      |   P                           |  -------------  ------------- |
      |                               |   R(Q/P)         R(P/Q)       |
      |                               |                               |
      |                               |                               |
      | ============================= | ============================= |
      |  RE                           |  Ax                           |
      | ============================= | ============================= |
      |   P      P                    |                               |
      |  ---    ---------             |  ---                          |
      |   P      |   ...              |   P   (P is an axiom)         |
      |          |   P    (immediate  |                               |
      |                    subproof)  |                               |
      +-------------------------------+-------------------------------+

Pseudo Inference Rules

   Applying definitions to pack or unpack abbreviations isn't actually an
   inference rule.  One doesn't really require justification to rewrite
   a string with a definition packed or unpacked; given that all
   a definition does is abbreviate more complex expressions.

   ================================  =========================================
   Name/Alternate Names              Rule
   ================================  =========================================
   Definition Substitution (DEF)     From [P =df Q], R(P), infer R(Q/P);
                                     and [P =df Q], R(Q), infer R(P/Q).
   ================================  =========================================

Derived Rules

   Once proven a sequent may be used as a new inference rule.  The following
   are important derived rules.

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Falso Quodlibet (EFQ)             P, ¬P  |-  Q
   Modus Tollens (MT)                P -> Q, ¬Q  |-  ¬P
   Hypothetical Syllogism (HS)       P -> Q, Q -> R  |-  P -> R
   Absorption (Abs)                  P -> Q  |-  P -> (P ∧ Q)
   Constructive Dilemma (CD)         P ∨ Q, P -> R, Q -> S  |-  R ∨ S
   Destructive Dilemma (DD)          (P -> Q), R -> S, ¬Q ∨ ¬S |- ¬P ∨ ¬Q
   Disjunctive Syllogism (DS)        P ∨ Q, ¬P  |-  Q
   Disjunctive Syllogism (DS)        P ∨ Q, ¬Q  |-  P
   Theorem (THM)                     [ |- P ]  |-  P
   ================================  =========================================

Theorems

   A theorem is a derived rule which has no premises or undischarged
   hypotheses.  Theorems are all tautologies.  A sequent for a theorem
   P looks like this

      |- P

Equivalences

   An equivalence is a theorem in the form of a biconditional.  Below are
   important equivalence theorems.

      |- P <-> Q

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Double Negation (DN)              |-  P <-> ¬¬P
   Idempotence (IDEM)                |-  P <-> (P ∧ P)
   Idempotence (IDEM)                |-  P <-> (P ∨ P)
   Transposition (TRANS)             |-  (P -> Q) <-> (¬Q -> ¬P)
   Material Implication (MI)         |-  (P -> Q) <-> (¬P ∨ Q)
   Association (ASSOC)               |-  (P ∧ (Q ∧ R)) <-> ((P ∧ Q) ∧ R)
   Association (ASSOC)               |-  (P ∨ (Q ∨ R)) <-> ((P ∨ Q) ∨ R)
   Commutation (COM)                 |-  (P ∧ Q) <-> (Q ∧ P)
   Commutation (COM)                 |-  (P ∨ Q) <-> (Q ∨ P)
   Exportation (EXP)                 |-  ((P ∧ Q) -> R) <-> (P -> (Q -> R))
   Distribution (DIST)               |-  (P ∧ (Q ∨ R)) <-> ((P ∧ Q) ∨ (P ∧ R))
   Distribution (DIST)               |-  (P ∨ (Q ∧ R)) <-> ((P ∨ Q) ∧ (P ∨ R))
   DeMorgan's law (DM)               |-  ¬(P ∧ Q) <-> (¬P ∨ ¬Q)
   DeMorgan's law (DM)               |-  ¬(P ∨ Q) <-> (¬P ∧ ¬Q)
   Material Equivalence (ME)         |-  (P <-> Q) <-> ((P -> Q) ∧ (Q -> P))
   Material Equivalence (ME)         |-  (P <-> Q) <-> ((P ∧ Q) ∨ (¬P ∧ ¬Q))
   ================================  =========================================

   Equivalence Theorem Substitution

   This handy device is a problem for modal logic.
   Equivalences can be used to swap instances of one side of the equivalence
   in wffs, with the corresponding instances of the other side.  This handy
   inference rule isn't going to be valid once we add Modal Logic.  So we're
   not not permitting it at all.

   @@@ It may be possible to still use these provided the thing being
   rewritten is not the main operator under □ or ◇.  Must test this
   more to be sure.  The course forbids it altogether.

Deriving Fitch

   Additional Fitch style inference rules are listed here and proven below.
   The order of these rules is important since later rules depend upon
   earlier rules having been proven.  While EFQ and MT aren't really
   Fitch rules, defining them early means we can take advantage of them
   when proving the below rules.  All of the derived rules, theorems and
   equivalences are easier to prove if we first prove these.

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Negation Rules
      ¬I                             ( P   |-  ⊥ )  |-  ¬P
      ¬I                             ( ¬P  |-  ⊥ )  |-  P
      EFQ (Ex Falso Quodlibet)       P, ¬P  |-  Q

   Conditional Rules
      MT (Modus Tollens)             P -> Q, ¬Q  |-  ¬P

   Conjunction Rules
      ∧E                             P ∧ Q  |-  Q
      ∧E                             P ∧ Q  |-  P
      ∧I                             P, Q  |-  P ∧ Q

   Disjunction Rules
      VE                             P ∨ Q, P -> R, Q -> R  |-  R
      VI                             P  |-  P ∨ Q
      VI                             P  |-  Q ∨ P

   Biconditional Rules
      <->E                           P <-> Q  |-  P -> Q
      <->E                           P <-> Q  |-  Q -> P
      <->I                           P -> Q, Q -> P  |-  P <-> Q
      <->I                           P -> Q, Q -> P  |-  Q <-> P
   ================================  =========================================


======
Proofs
======


Negation Derivations
--------------------

These rules must be proven schematically because they describe
new kinds of reasoning with subproofs.

¬I:   ( P  |-  ⊥ )  |-  ¬P
Proof
 i.    |   P         H (for ¬I)
       |   ...
 j.    |   ⊥
 j+1.  P -> ⊥        i-j ->I
 j+2.  ¬P            j+1 Def ¬
QED

¬I:   ( ¬P  |-  ⊥ )  |-  P
Proof
 i.    |   ¬P        H (for ¬I)
       |   ...
 j.    |   ⊥
 j+1.  ¬P -> ⊥       i-j ->I
 j+2.  ¬¬P           j+1 Def ¬
 j+3.  P             j+2 ¬E
QED

Ex Falso Quodlibet (EFQ):   P, ¬P  |-  Q
Proof
01.   P                      A
02.   ¬P                     A
03.   |   ¬Q                 H (for ⊥)
04.   |   P                  1 RE
05.   |   ¬P                 2 RE
06.   |   P -> ⊥             5 Def ¬
07.   |   ⊥                  4,6 ->E
08.   Q                      3-7 ¬I
QED


Conditional Derivations
-----------------------

Modus Tollens (MT):   P -> Q, ¬Q  |-  ¬P
Proof
01.   P -> Q                 A
02.   ¬Q                     A
03.   |   P                  H (for ¬I)
04.   |   P -> Q             1 RE
05.   |   ¬Q                 2 RE
06.   |   Q                  3,4 ->E
07.   |   ⊥                  5,6 EFQ
08.   ¬P                     3-7 ¬I
QED


Conjunction Derivations
-----------------------

∧E:   P ∧ Q  |-  Q
Proof
01.   P ∧ Q                  A
02.   ¬(P -> ¬Q)             1 def ∧
03.   |   ¬Q                 H (for ¬I)
04.   |   |   P              H (for ->I)
05.   |   |   ¬Q             3 RE
06.   |   P -> ¬Q            4-5 ->I
07.   |   ¬(P -> ¬Q)         2 RE
08.   |   ⊥                  6,7 EFQ
09.   Q                      3-8 ¬I
QED

∧E:   P ∧ Q  |-  P
Proof
01.   P ∧ Q                  A
02.   Q ∧ P                  1 Com
03.   P                      2 ∧E
QED

∧I:   P, Q  |-  P ∧ Q
Proof
01.   P                      A
02.   Q                      A
03.   |   P -> ¬Q            H (for ¬I)
04.   |   P                  1 RE
05.   |   Q                  2 RE
06.   |   ¬Q                 3,4 ->E
07.   |   ⊥                  5,6 EFQ
08.   ¬(P -> ¬Q)             3-7 ¬I
09.   P ∧ Q                  8 Def ∧
QED


Disjunction Derivations
-----------------------

VE/Poof by Cases (PBC):   P ∨ Q, P -> R, Q -> R  |-  R
Proof
01.   P ∨ Q                  A
02.   P -> R                 A
03.   Q -> R                 A
04.   ¬P -> Q                1 def ∨
05.   |   ¬R                 H (for ¬I)
06.   |   P -> R             2 RE
07.   |   Q -> R             3 RE
08.   |   ¬P -> Q            4 RE
09.   |   ¬P                 5,6 MT
10.   |   ¬Q                 5,7 MT
11.   |   Q                  8,9 ->E
12.   |   ⊥                  10,11 EFQ
13.   R                      5-12 ¬I
QED

VI:   P  |-  P ∨ Q
Proof
01.   P                      A
02.   |   ¬(P ∨ Q)           H (for ¬I)
03.   |   ¬(¬P -> Q)         2 Def ∨
04.   |   (¬P -> Q) -> ⊥     3 Def ¬
05.   |   P                  1 RE
06.   |   |   ¬P             H (for Q)
07.   |   |   P              5 RE
08.   |   |   Q              6,7 EFQ
09.   |   ¬P -> Q            6-8 ->I
10.   |   ⊥                  4,9 ->E
11.   P ∨ Q                  2-10 ¬I
QED

VI:   P  |-  Q ∨ P
Proof
01.   P                      A
02.   P ∨ Q                  1 VI
03.   |   ¬(Q ∨ P)           H (for ¬I)
04.   |   ¬(¬Q -> P)         3 Def ∨
05.   |   (¬Q -> P) -> ⊥     4 Def ¬
06.   |   P                  1 RE
07.   |   |   ¬Q             H (for ->I)
08.   |   |   P              6 RE
09.   |   ¬Q -> P            7-8 ->I
10.   |   ⊥                  5,9 ->E
11.   Q ∨ P                  3-10 ¬I
QED


Biconditional Derivations
-------------------------

<->E:   P <-> Q  |-  P -> Q
Proof
01.   P <-> Q                A
02.   (P -> Q) ∧ (Q -> P)    1 Def <->
03.   P -> Q                 2 ∧E
QED

<->E:   P <-> Q  |-  Q -> P
Proof
01.   P <-> Q                A
02.   (P -> Q) ∧ (Q -> P)    1 Def <->
03.   Q -> P                 2 ∧E
QED

<->I:   P -> Q, Q -> P  |-  P <-> Q
Proof
01.   P -> Q                             A
02.   Q -> P                             A
04.   |   ¬(P <-> Q)                     H (for ¬I)
05.   |   ¬((P -> Q) ∧ (Q -> P))         4 Def <->
06.   |   ((P -> Q) ∧ (Q -> P)) -> ⊥     5 Def ¬
07.   |   P -> Q                         1 RE
08.   |   Q -> P                         2 RE
09.   |   (P -> Q) ∧ (Q -> P)            7,8 ∧I
10.   |   ⊥                              6,9 ->E
11.   P <-> Q                            4-10 ¬I
QED

<->I:   P -> Q, Q -> P  |-  Q <-> P
Proof
01.   P -> Q                             A
02.   Q -> P                             A
03.   |   ¬(Q <-> P)                     H (for ¬I)
04.   |   (Q <-> P) -> ⊥                 3 Def ¬
05.   |   ((Q -> P) ∧ (P -> Q)) -> ⊥     4 Def <->
06.   |   Q -> P                         2 RE
07.   |   P -> Q                         1 RE
08.   |   (Q -> P) ∧ (P -> Q)            6,7 ∧I
09.   |   ⊥                              5,8 ->I
10.   Q <-> P                            3-9 <->I
QED


=========================
Modal Logic Preliminaries
=========================

Alethic modal logic studies the concepts of 'it's necessary that, P'
symbolized □P, and 'it's possible that, P' symbolized ◇P.  Here are some
examples of necessary.

   Kinds of Necesssity

   1. logical necessity: true in virtue of logic alone.

   2. metaphysical necessity: true in virtue of the structure of reality.
      Eg. Contradictions are necessarily false.

   3. lawful/nomological/causal/scientific/physical necessity:
      true in virtue of the laws of nature.  (eg. the speed of light).
         nomological =df  relating to or denoting certain principles, such as
                          laws of nature, that are neither logically
                          necessary nor theoretically explicable, but are
                          simply taken as true.

Semantics

   modal square of opposition

      □P-----------□¬P
       | \       / |
       |   \   /   |
       |     X     |
       |   /   \   |
       | /       \ |
      ◇P-----------◇¬P

   extension   the extension of a sentence is its truth value; the extension
               of a predicate is the class of things to which it applies;
               and the extension of an object symbol is its bearer.

   intension   the intension of a sentence is the abstract thought or
               proposition it expresses; the intension of a predicate is
               the property, concept or idea it represents, and the
               intension of a object symbol is its 'meaning', 'sense' or the
               'individual concept' it uses to pick out its bearer.

   Extensional Contexts

   The EXTENSION of a sentence is its truth-value, the extension of a
   predicate is the class of things to which it applies, and the
   extension of a constant object symbol is what the symbol denotes.

   In Frege-Russellean logics, starting from a given statement, it is
   always possible to infer what results from replacing a subexpression
   in that statement with one with the same extension.  So,

      TFL   From '...P...' (wff containing P), and P <-> Q, one can
            always infer '...Q...'

      FOL=  From '...F...' (wff containing F), and Ax:(Fx <-> Gx) one can
            always infer '...G...'

      Ident From '...a...' (wff containing a), and a=b one can
            always infer '...b...'


      TFL   From R(P) and P <-> Q, infer R(Q/P)

      FOL=  From R(F) and Ax:(Fx <-> Gx), infer R(G/F)

      Ident From R(a) and a=b, infer R(b/a)

   Intensional Contexts

   However the INTENSION of a sentence is the thought or proposition it
   expresses, the intension of a predicate is the property, concept or
   idea it represents, and the intension of a constant is its meaning,
   sense or the individual concept it used to pick out its bearer.

   When it comes to an operator like □, replacing an expression with
   another having the same extension can result in different truth values.
   These are called intensional contexts, since in these contexts, intension
   matters, not just extension.  So,

      □(2+2=4)                        is true but,
      □(Mercury is the first planet)  is false

      □(8>7)                          is true but,
      □(number of planets>7)          is false

   Operators that generate such contexts are called intensional contexts.
   Both □ and ◇ are examples of intensional operators.

   @@@It seems that we may be able to permit extension substitutions as
   described above provided they aren't performed on the top-level wff
   that is the argument of a modal operator.  It may be still be ok to do
   internally.


Formal Language (TFL)
---------------------

Lexemes

   Non¬Logical Symbols
      Proposition Symbols:      A...Z

   Logical Symbols
      Truth-Function Symbols:   ->, ⊥
      Association Symbols:      (, )
      Modal Symbols:            □

Grammar (Formation Rules for Well-Formed Formulas)

   An ATOMIC FORMULA is either ⊥ or any proposition symbol.

   1.  every atomic formula is a wff;
   2.  if P,Q  are wffs, then (P -> Q) is a wff;
   3.  if P is a wff, then □P is also a wff;
   4.  nothing else is a wff.

   Notes

   - To aid readability of a wffs we adopt the convention that if a wff
     that begins with '(', we will drop the outer-most pair of parenthesis.

   - In practice it's common to use tick marks or numerical subscripts
     (we use postscripts) after the proposition symbol to increase to
     infinity the number of available symbols.

Definitions

   ◇P         =df  ¬□¬P
   (P -< Q)   =df  □(P -> Q)
   (P >-< Q)  =df  (P -< Q) ∧ (Q -< P)

==============
Modal System K
==============
   
Alethic Modal Calculus K
------------------------

   This modal calculus is constructed upon TFC above.  We will modify two
   inference rules and add two new ones.

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Hypothesis (H for □I)             Introduce a hypothesis at any step
                                     provided it beings a new subproof.  The
                                     hypothesis can be '□' alone which is
                                     called a BOXED SUBPROOF.

   Reiterate (RE)                    From P, infer P into the same subproof,
                                     or into an immediately nested subproof
                                     provided the nested subproof is not a
                                     boxed subproof.

   Necessitation Elimination (□E)    From □P, infer P into any immediately
                                     nested boxed subproof.

   Necessitation Introduction (□I)   From a boxed subproof ending in P,
                                     infer □P.
   ================================  =========================================

   These rules are sometimes represented more visually.  The horizontal bar
   denotes 'infer', vertical lines denote subproofs, other symbology comes
   directly from my modified sequent notation.

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  H                            |  RE                           |
      | ============================= | ============================= |
      |                               |   P      P                    |
      |  -------    -------           |  ---    ---------             |
      |   |   P      |□               |   P      |   ...   Subproof   |
      |                               |          |   P     not boxed  |
      |                               |                               |
      | ============================= | ============================= |
      |  □E                           |  □I                           |
      | ============================= | ============================= |
      |   □P                          |   |□                          |
      |  ---------                    |   |   ...                     |
      |   |□                          |   |   P                       |
      |   |   ...                     |  ---------                    |
      |   |   P                       |   □P                          |
      |                               |                               |
      +-------------------------------+-------------------------------+

MDist  |¬K  □(P -> Q) -> (□P -> □Q)
Proof
01.   |   □(P -> Q)               A
02.   |   |   □P                  H (for ->I)
03.   |   |   □(P -> Q)           1 RE
04.   |   |   |□                  H (for □I
05.   |   |   |   P               2 □E
06.   |   |   |   P -> Q          3 □E
07.   |   |   |   Q               5,6 ->E
08.   |   |   □Q                  4-7 □I
09.   |   □P -> □Q                2-8 ->I
10.   □(P -> Q) -> (□P -> □Q)     1-9 ->I
QED

   |¬K  □(P -> (Q -> P))
Proof
01.   |□                          H (for □I)
02.   |   |   P                   H (for ->I)
03.   |   |   |   Q               H (for ->I)
04.   |   |   |   P               2 RE
05.   |   |   Q -> P              3-4 ->I
06.   |   P -> (Q -> P)           2-5 ->I
07.   □(P -> (Q -> P))            1-6 □I
QED

   Rule of Necessitation (NEC)   if |-K P then |-K □P
   Modal Distribution (MDist)    |-K □(P -> Q) -> (□P -> □Q)

These two rules are equivalent to: □I and □E.

Some derived rules

¬◇   ¬◇P  |-K  □¬P
Proof
01.   ¬◇P                         A
02.   ¬¬□¬P                       1 DEF◇
03.   □¬P                         2 ¬E
QED

¬□   ¬□P  |-K  ◇¬P
Proof
01.   ¬□P                         A
02.   |   □¬¬P                    H (¬E)
03.   |   |□                      H (for □I)
04.   |   |   ¬¬P                 2 □E
05.   |   |   P                   4 ¬E
06.   |   □P                      3-5 □I
07.   |   ¬□P                     1 RE
08.   |   ⊥                       6,7 EFQ
09.   ¬¬◇¬P                       2-8 ¬I
10.   ◇¬P                         9 ¬E
QED

◇DIST   |-K  □(P -> Q) -> (◇P -> ◇Q)
Proof
01.   |   □(P -> Q)               A
02.   |   |   □¬Q                 H (for ->I)
03.   |   |   □(P -> Q)           1 RE
04.   |   |   |□                  H (for □I)
05.   |   |   |   ¬Q              2 □E
06.   |   |   |   P -> Q          3 □E
07.   |   |   |   ¬P              5,6 MT
08.   |   |   □¬P                 4-7 □I
09.   |   □¬Q -> □¬P              2-8 ->I
10.   |   ¬□¬P -> ¬□¬Q            9 TRANS
11.   |   ◇P -> ◇Q                10 DEF◇
12.   □(P -> Q) -> (◇P -> ◇Q)     1-11 ->I
QED

◇E   |-K   ◇P, (□ (P |- Q))  |-  ◇Q
Schematic Proof
i.   ◇P
j.   |□                           H (for □I)
k.   |   |   P                    H (for ->I)
...
l.   |   |   Q
l+1. |   P -> Q                   k-l ->I
l+2. □(P -> Q)                    j-l+1 □I
l+3. □(P -> Q) -> (◇P -> ◇Q)      ◇DIST
l+4. ◇P -> ◇Q                     l+2,l+3 ->E
l+5. ◇Q                           i,l+4 ->E
QED

This proof form is very common, so it's worth while to introduce further
abbreviation, with a WORLD-SUBPROOF.  In such a case we introduce a boxed
subproof and a wff in one step.

   (□,P |-K ... )
Schematic Proof
i.   |□,P
...
j.   |
QED

We shall generalize further.

   (A,B,C |-K D) |-K A -> (B -> (C -> D))
Schematic Proof
i.   |   A,B,C
...
j.   |   D
j+1. A -> (B -> (C -> D))         i-j ->I
QED

Schematic Proof
i.   |   P
j.   |   |   Q
k.   |   |   |   R
...
l.   |   |   |   S
l+1. |   |   R -> S               k-l ->I
l+2. |   Q -> (R -> S)            j-l+1 ->I
l+3  P -> (Q -> (R -> S))         i-l+2 ->I
QED

Alternatively, the hypotheses can be placed on separate lines so they can be
easily cited in later steps.

Sehcmatic Proof
i.   |   P
i+1. |   Q
i+2. |   R
...
j.   |   S
j+1. P -> (Q -> (R -> S))         i-j+1 ->I
QED

◇&Dist  |-K  ◇(P ∧ Q) -> (◇P ∧ ◇Q)
Proof
01.   |   ◇(P ∧ Q)                H (for ◇E)
02.   |   |□,P ∧ Q                H (for □I)
03.   |   |   P                   2 ∧E
04.   |   ◇P                      1,2-3 ◇I
05.   |   |□,P ∧ Q                H (for □I)
06.   |   |   Q                   5 ∧E
07.   |   ◇Q                      5-6 ◇I
08.   |   ◇P ∧ ◇Q                 4,7 ∧I
09.   ◇(P ∧ Q) -> (◇P ∧ ◇Q)       1-8 ->I
QED

   |-K   (□P ∧ ◇Q) -> ◇(P ∧ Q)
Proof
01.   |   □P ∧ ◇Q                 H (for ->I)
02.   |   □P                      1 ∧E
03.   |   ◇Q                      1 ∧E
04.   |   |□,Q                    H (for ◇E)
05.   |   |   P                   2 □E
06.   |   |   P ∧ Q               4,5 ∧I
07.   |   ◇(P ∧ Q)                3,4-6 ◇E
08.   (□P ∧ ◇Q) -> ◇(P ∧ Q)       1-7 ->I
QED


Alethic Modal Calculus T, B, S4, S5
-----------------------------------

Axiom Schimata
   M (Modality):        □P -> P
   B (L.E.J.Brouwer):   P -> □◇P
   4 (C.I.Lewis Ax 4):  □P -> □□P
   5 (C.I.Lewis Ax 5):  ◇P -> □◇P

System M/System T
   System K + allowing every instance of M as an axiom.

System B
   System T + allowing every instance of B as an axiom.

System S4
   System T + allowing every instance of 4 as an axiom.

System S5
   System T + allowing every instance of 5 as an axiom.

   |-K   ◇(P ∧ Q) -> (◇P ∧ ◇Q)
Proof
01.   |   ◇(P ∧ Q)                H (for ->I)
02.   |   |□,P ∧ Q                H (for ◇E)
03.   |   |   P                   2 ∧E
04.   |   ◇P                      1,2-3 ◇E
05.   |   |□,P ∧ Q                H (for ◇E)
06.   |   |   Q                   5 ∧E
07.   |   ◇Q                      1,5-6 ◇E
08.   |   ◇P ∧ ◇Q                 4,7 ∧I
09.   ◇(P ∧ Q) -> (◇P ∧ ◇Q)       1-8 ->I
QED

◇I (Dual of M):   |-T   P -> ◇P
Proof
01.   |   P                       H (for ->I)
02.   |   □¬P -> ¬P               Ax M
03.   |   ¬¬P                     1 DN
04.   |   ¬□¬P                    2,3 MT
05.   |   ◇P                      4 DEF◇
06.   P -> ◇P                     1-5 ->I
QED

¬◇I:   □¬P  |-  ¬◇P
Proof
01.   □¬P                         A
02.   |   ◇P                      H (for ¬I)
03.   |   ¬□¬P                    2 DEF◇
04.   |   □¬P                     1 RE
05.   |   ⊥                       3,4 EFQ
06.   ¬◇P                         2-5 ¬I
QED

¬□I:   ◇¬P  |-  ¬□P
Proof
01.   ◇¬A                         A
02.   |   □A                      H (for ¬I)
03.   |   |□                      H (for □I)
04.   |   |   A                   2 □E
05.   |   |   ¬¬A                 4 DN
06.   |   □¬¬A                    3-5 □I
07.   |   ◇¬A                     1 RE
08.   |   ¬□¬¬A                   7 DEF◇
09.   |   ⊥                       6,8 EFQ
10.   ¬□A                         2-9 ¬I
QED

B' (Dual of B):  |-B  ◇□P -> P
Proof
01.   |   ◇□P,¬P                  H
02.   |   ¬P -> □◇¬P              Ax B
03.   |   □◇¬P                    1,2 ->E
04.   |   |□                      H (for □I)
05.   |   |   ◇¬P                 3 □E
06.   |   |   ¬□P                 5 DUAL
07.   |   □¬□P                    4-6 □I
08.   |   ¬◇□P                    7 DUAL
09.   |   ⊥                       1a,8 EFQ
10.   ◇□P -> P                    1-9 ->I, ¬I
QED

4' (Dual of 4):  |-S4  ◇◇P -> ◇P
Proof
01.   |   ◇◇P, ¬◇P                H (for ->I,¬I)
02.   |   □¬P                     1b DUAL
03.   |   □¬P -> □□¬P             Ax 4
04.   |   □□¬P                    2,3 ->E
05.   |   |□                      H (for □I)
06.   |   |   □¬P                 4 □E
07.   |   |   ¬¬□¬P               6 DN
08.   |   □¬¬□¬P                  5-7 □I
09.   |   □¬◇A                    8 DEF◇
10.   |   ¬□¬◇P                   1a DEF◇
11.   |   ⊥                       9,10 EFQ
12.   ◇◇P -> ◇P                   1-11 ->I,¬I
QED

Steps 2-6 demonstrate that from □P one can infer □P into a subproof
without losing the □.

S4 = System T + 4' as an axiom schema.

5' (Dual of 5):  |-S5  ◇□P -> □P
Proof
01.   |   ◇□P, ¬□P               H (for ->I,¬I)
02.   |   ◇¬P                    1 DUAL
03.   |   ◇¬P -> □◇¬P            Ax 5
04.   |   □◇¬A                   2,3 ->E
05.   |   |□                     H (for □I)
06.   |   |   ◇¬P                4 □E
07.   |   |   ¬□P                6 ¬□I
08.   |   □¬□P                   5-7 □I
09.   |   ¬□¬□P                  1a DEF◇
10.   |   ⊥                      8,9 EFQ
11.   ◇□P -> □P                  1-10 ->I,¬I
QED

Steps 2-6 demonstrate that from ◇P one can infer ◇P into a subproof
without losing the ◇.

   |-S5  P -> □◇P
Proof
01.   P -> ◇P                    ◇I
02.   ◇P -> □◇P                  Ax 5
03.   P -> □◇P                   1,2 HS
QED

   |-S5  □P -> □□P
Proof
01.   □P -> □◇□P                 Ax B
02.   |□                         H (for □I)
03.   |   ◇□P -> □P              5'
04.   □(◇□P -> □P)               2-3 □I
05.   □(◇□P -> □P) -> (□◇□P -> □□P)  MDist
06.   □◇□P -> □□P                4,5 ->E
07.   □P -> □□P                  1,6 HS
QED

   |-S4  □P <-> □□P
   |-S4  ◇P <-> ◇◇P

But also,

   |-S4  □P <-> □□□P
Proof
01.   □P -> □□P                   Ax 4
02.   □□P -> □□□P                 Ax 4
03.   □P -> □□□P                  1,2 HS
04.   □□□P -> □□P                 Ax M
05.   □□P -> □P                   Ax M
06.   □□□P -> □P                  4,5 HS
07.   □P <-> □□□P                 3,6 <->I
QED

   |-S4  ◇P <-> ◇◇◇P

   |-S4  □(P -> □□Q) <-> □(P -> □Q)`
01.   |   □(P -> □□Q)
02.   |   |□                      H (for □I)
03.   |   |   P -> □□Q            1 □E
04.   |   |   □□Q -> □Q           Ax M
05.   |   |   P -> □Q             3,4 HS
06.   |   □(P -> □Q)              2-5 □I
07.   □(P -> □□Q) -> □(P -> □Q)   1-6 ->I
08.   |   □(P -> □Q)              H (for ->I)
09.   |   |□                      H (for □I)
10.   |   |   P -> □Q             8 □E
11.   |   |   □Q -> □□Q           Ax 4
12.   |   |   P -> □□Q            10,11 HS
13.   |   □(P -> □□P)             9-12 □I
14.   □(P -> □Q) -> □(P -> □□Q)   8-13 ->I
15.   □(P -> □□Q) <-> □(P -> □Q)  1-6 ->I
QED

   |-S5  □◇◇□P <-> □P
Proof
01.   |   □◇◇□P                   H (for ->I)
02.   |   ◇◇□P                    1 Ax M
03.   |   ◇□P                     2 Ax 4'
04.   |   □P                      3 Ax 5'
05.   □◇◇□P -> □P                 1-4 ->I
06.   |   □P                      H (for ->I)
07.   |   ◇□P                     6 ◇I
08.   |   ◇◇□A                    7 ◇I
09.   |   □◇◇□P                   8 Ax 5
10.   □P -> □◇◇□P                 6-9 ->I
11.   □◇◇□P <-> □P                5,10 <->I
QED

   |-S5 ◇(□◇P ∧ ◇□Q) <-> ◇(◇A ∧ □B)
Proof
01.   |   ◇(□◇P ∧ ◇□Q)            H (for ->I)
02.   |   |□,□◇P ∧ ◇□Q            H (for ◇E)
03.   |   |   □◇P                 2 ∧E
04.   |   |   ◇□B                 2 ∧E
05.   |   |   ◇P                  3 Ax M
06.   |   |   □B                  4 Ax 5'
07.   |   |   ◇P ∧ □Q             5,6 ∧I
08.   |   ◇(◇P ∧ □Q)              1,2-7 ◇E
09.   ◇(□◇P ∧ ◇□Q) -> ◇(◇P ∧ □Q)  1-8 ->I
10.   |   ◇(◇P ∧ □Q)              H (for ->I)
11.   |   |□,◇A ∧ □B              H (for ◇E)
12.   |   |   ◇P                  11 ∧E
13.   |   |   □B                  11 ∧E
14.   |   |   □◇P                 12 Ax 5
15.   |   |   ◇□Q                 13 ◇E
16.   |   |   □◇P ∧ ◇□Q           14,15 ∧I
17.   |   ◇(□◇P ∧ ◇□Q)            10,11-16 ◇E
18.   ◇(◇P ∧ □Q) -> ◇(□◇P ∧ ◇□Q)  10-17 ->I
19.   ◇(□◇P ∧ ◇□Q) <-> ◇(◇P ∧ □Q) 9,18 <->I
QED


================================================
Intensional Operators - Deontic Logic:  System D
================================================

Very controversial.  All formulations seem to have issues.

Notions

   O:P,     It's obligatory that P
   P:P,     It's permissible that P

Definitions

   (Def P)   P:P  =df  ¬O:¬P         (It's permissible that P)
   (Def F)   F:P  =df  O:¬P          (It's forbidden that P)


System D
--------

   Inference Rules

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  O:E                          |  O:I                          |
      | ============================= | ============================= |
      |   OR                          |   |□                         |
      |  ---------                    |   |   ...                     |
      |   |□                          |   |   R                       |
      |   |   ...                     |  ---------                    |
      |   |   R                       |   OR                          |
      |                               |                               |
      +-------------------------------+-------------------------------+

   Axioms

      D.   O:R -> P:R

   Other Possible Axioms

      OO.  O:R <-> OO:R         (biconditional version of axiom 4)
      OP.  P:R <-> OP:R         (biconditional version of axiom 5)
      OM.  O:(O:R -> R)

   Since S4 and S5 include axiom M, which is stronger than
   (axiom OM) + (axiom D).


   Issues

      All theorems (tautologies) are obligatory and their negations
      are forbidden.

         |-D  F⊥                 (contradiction is forbidden)
         |-D  O:(R -> R)

      But these seem odd.

         |-D  P:R -> P:(R ∨ S)     (provable with K alone)

         Example

         H,   you hug
         S,   you spit

         P:H  |-  P:(H ∨ S)

      Which seems to produce, It's permissible that you either hug or spit.
      But this seems to imply

         P:H ∧ P:S

      Similarly,

         |-D  OR -> O:(R ∨ S)

      Suppose, I ought to hug.  Does this imply I ought to hug or spit?

         NonCon  |-D  ¬(O:R ∧ O:¬R)

      Chisholm's Paradox

      D cannot adequately capture conditional obligations.

         1. O:G           Obligatorily Sadie goes.
         2. O:(G -> T)    Obligatorily if Sadie goes, she talks.
         3. ¬G -> O:¬T    If Sadie doesn't go, she ought not talks.
         4. ¬G            Sadie doesn't go.

      Which derives a contradiction.   

      Another odd thoerem in D

         |-D  OR -> O:(¬R -> S)


===============================================
Intensional Operators - Tense Logic:  System Kt
===============================================


Notions
-------

      G:S,   It's going to always be that P.
      H:S,   It has always been the case that P.


Definition
----------

      DEF F.   F:S  =df  ¬G:¬S    (It will at some time be the case that S)
      DEF P.   P:S  =df  ¬H:¬S    (It was at some time the case that S)


Inference
---------

      G:I, H:I,   correspond to □I
      G:E, H:E,   correspond to □E

   These insure that all tautologies, axioms and theorems of the system
   have always been and always will be the case.

      GP.   S -> GP:S
      HF.   S -> HF:S

   Duals

      |-Kt  PG:S -> S
      |-Kt  FH:S -> S
      |-Kt  G:S -> GG:S
      |-Kt  H:S -> HH:S
      |-Kt  FF:S -> F:S
      |-Kt  PP:S -> P:S


================================================================
Intensional Operators - Doxastic and Epistemic Logic:  System Kt
================================================================


Notions
-------

   Ba:P, a believes P
   Ka:P, a knows P


Definitions
-----------

   DEF C.   C:S  =df  ¬B:¬S    (Maybe 'conceive'?)
   DEF P.   P:S  =df  ¬K:¬S    (Maybe 'ponders'?)


Derived Rules

   DIST-K.  K:(R -> S) -> (K:R -> K:S)
   M-K.     K:R -> R
   KK.      K:R -> KK:R

   Which is S4

Problem with Kx:

   The epistemic necessitation rule entails that all tautologies are known.

         if  |-E P  then  K:P

   @@@ Seems equivalent to Fitch's knowability paradox.

Problem with Kx:

   MDist entails that knowledge is closed under implication, ie. that whenever
   we know a conditional and know it's antecedent, we know its consequent.

         K:(P -> Q)   then   K:P -> K:Q

      1.  I know that, I'm seeing a book.
      2.  I know that, if I'm seeing a book then I'm not a brain in a vat.
      3.  I don't know that I'm not a brain in a vat.

      Ki:S
      Ki:(S -> ¬V)
      ¬Ki:¬V

   Which can't all be true in epistemic S4.

Problem with Kx:

   Claims that whatever we know is something we know that we know.

         K:P -> KK:P

   KK seems most suitable for a very strong idealized notion of knowledge.

   Ordinarily it seems odd that if one knows something, they have knowledge
   that they know it.

Reinterpreation of Kx:

   One could take Kx:P to mean, x is in a position to know P.
   (Not quite the same as saying ◇K:P)

   This seems to fix the above problems.

Problem with Bx:

   Similar notions about Bx: such as, all tautologies are believed, and belief
   is closed under implication, are even more worrisome.

   One natural formulaxion of doxastic logic would be KD4.

         D-B.       B:P -> C:P
         BB.        B:P -> BB:P

   Which leads to this result.

         NonCon-B.  ¬(B:P ∧ B:¬P)

Reinterpretation of Bx:

   These issues seem less of a problem if we take Bx:P to mean,
   x ought to beieve p, or x is committed to the truth of P.

Other Accepted but Disputed Principles

         BB:P -> B:P
         K:P -> B:P
         B:P -> K:B:P
         ¬K:P -> K:¬K:P
         P:K:P -> K:P:P
         B:K:P -> B:P
         ¬B:⊥


Semantics
---------

K-Model

   A K-model is a triple <W,R,a>, where

   - W is a set of different contexts of evaluations, w,v,u,w',... These
     might be different possible worlds, or moments of time, or states
     of belief (depending upon the modality).

   - R is a relation (the accessibility relation) defined over the members
     of W.  We write wRv to mean that this relation holds between w and v
     (or that v is accessible from w).

   - a is a function, definable in terms of W and R that assigns exactly
     one member of the set {T,F} to each wff of modal truth-functional logic
     for each member of W.  Subject to further restrictions.

K-Model Truth Assignment

   aw(A) is the name of the truth-value that a assigns to A for world w.

   To count as a K-model, the a of a given model must obey the following
   restrictions for each world w in W:

      For any atomic formula P, aw(P)=T or F depending on the nature of w.

         aw(⊥) = F


                        | T   if aw(P)=F or aw(Q)=T
         aw(P -> Q)  = -+
                        | F   otherwise


      Combined with our definitions for the remaining TF operators yields,


                        | T   if aw(P) = F
         aw(¬P)      = -+
                        | F   if aw(P) = T


                        | T   if aw(P) = T and aw(B) = T
         aw(P ∧ Q)   = -+
                        | F   otherwise


                        | T   if aw(P) = T or aw(B) = T
         aw(P ∨ Q)   = -+
                        | F   otherwise


                        | T   if aw(P) = aw(Q)
         aw(P <-> Q) = -+
                        | F   otherwise


      Lastly the modal operators


                        | T   if av(P) = T for every v in W such that wRv
         aw(□P)     = -+
                        | F   otherwise


                        | T   if av(P) = T for some v in W such that wRv
         aw(◇P)     = -+
                        | F   otherwise


K-Model Definitions

   An argument P1, P2, ..., Pn |- C is K-VALID iff there is no K-model,
   <W,R,a>, and world w in W, for which aw(P1)=T and aw(P2)=T and ... and
   aw(Pn)=T, but aw(C)=T.

   An argument P1, P2, ..., Pn |- C is said to have a K-COUNTEREXAMPLE
   iff there exists a K-model <W,R,a> and world w in W, for which
   aw(P1)=T and aw(P2)=T and ... and aw(Pn)=T, but as aw(C)=F.

   A statement P is K-VALID iff for every K-model <W,R,a> and world
   w in W, for which aw(P)=T.

   K-SATISFIABILITY, K-EQUIVALENCE, etc. can be defined similarly.

   We write P1, P2, ..., Pn |=K C to mean that the argument
   P1, P2, ..., Pn |- C is K-valid.

   We write |=K P to assert that the wff P is K-VALID (K-logically true).

Modal Truth-Trees

   With trees in modal logic we enclose parts of trees within boxes
   to represent different possible worlds.  We add arrows between
   boxes to represent the accessibility relation. Next we add tree
   formation rules for the two modal operators.

   Tree Formation Rules

   ====  =====================================================================
   Name  Rule
   ====  =====================================================================
   □    If an open path in some world w contain an unstarred wff □P, place
         P at the bottom of every open path in every world v accessible
         from w.

   ¬□   If an open path in some world w contains an unstarred wff ¬□P,
         star it, write ¬P at the top of a new world v, and draw an arrow
         from each open path in w to v.

   ◇    If an open path in some world w contains an unstarred wff ◇P,
         star it, write P at the top of a new world v, and draw an arrow
         from each open path in w to v.

   ¬◇   If an open path in some world w contain an unstarred wff ¬◇P, place
         ¬P at the bottom of every open path in every world v accessible
         from w.
   ====  =====================================================================

   Tree Formation Rules Diagrams

           +---------------------------+---------------------------+         
           | ========================= | ========================= |
           |           □Rule           |          ¬□Rule           |
           | ========================= | ========================= |
           |         +-------+w        |         +-------+w        |
           |         |  □P  |          |         | *¬□P  |         |
           |         +-------+         |         +-------+         |
           |             |             |             |             |
           |             V             |             V             |
           |         +-------+v  every |         +-------+v  v is  |
           |         |  ...  |   v     |         |  ¬P   |   new   |
           |         |   P   |         |         |  ...  |         |
           |         +-------+         |         +-------+         |
           |                           |                           |
           | ========================= | ========================= |           
           |          ◇Rule            |         ¬◇Rule            |
           | ========================= | ========================= |
           |         +-------+w        |         +-------+w        |
           |         | *◇P  |          |         |  ¬◇P  |         |
           |         +-------+         |         +-------+         |
           |             |             |             |             |
           |             V             |             V             |
           |         +-------+v  v is  |         +-------+v  every |
           |         |   P   |   new   |         |  ...  |   v     |
           |         |  ...  |         |         |  ¬P   |         |
           |         +-------+         |         +-------+         |
           |                           |                           |
           |                           |                           |
           +---------------------------+---------------------------+

      Notice ¬□ converts to ◇¬, and that ¬◇ is defined to convert to □¬.
      Thus, it's possible to regard there as being only two rules, and it's
      the ◇ which creates new world boxes while □ just drops into
      existing worlds.

      However, ◇ is defined in terms of □, so the two rules to be taken
      as fundamental are □ and ¬□, while the ◇ rules ought to be
      regarded as derived.

   Tree Construction

   Trees are constructed similarly to how they are constructed for TFL,
   but add the notion of world boxes which are introduced according
   to the above rules.  However, there are just a few notes,

   - To close a branch we need P and ¬P in the same world box.

   - Branching rules from TFL mean that a world can exist on a certain branch.

   - The arrows between world boxes signify the accessibility relation.

   - Rules for TF operators should always be applied before rules for
     modal operators.

   - Modal rules that create new world boxes ¬□ and ◇ should be
     applied before modal rules that don't

   - Rules applied to □P and ¬◇P do not star the original wff because
     for each new world the rules must be reapplied.
     

Truth-Tree Analysis

   The rules for analyzing completed trees are the same as those for TFL.

   Truth-Tree Assessment of a Single WFF

          =============   ============================   ==========
          condition       wff                            -wff
          =============   ============================   ==========
          0               inconsistent                   tautology
          1+              consistent                     contingent
          2+              validity or contingency        contingent
          =============   ============================   ==========

   Truth-Tree Assessment of a set of WFFs

          =============   ============================
          condition       wff Set
          =============   ============================
          0               inconsistent
          1+              consistent
          =============   ============================

   Truth-Tree Assessment of a Sequent

          =============   ============================
          Condition       Premises & ¬Conclusion
          =============   ============================
          0  open paths   valid
          1+ open paths   Invalid w/ counterexamples
          =============   ============================

K-Model Truth-Trees

   □(P ∧ Q) |- □P ∧ □Q

            
            +---------------------+w0       All paths close
            |  *  □(P ∧ Q)        |         so the argument
            |  * ¬(□P ∧ □Q)       |         is K-valid.
            |      /       \      |
            |    /           \    |
            |* ¬□P        * ¬□Q   |
            +---------------------+
               |               |
               V               V
         +---------+w1     +---------+w2
         |    ¬P   |       |   ¬Q    |
         |* P ∧ Q  |       |* P ∧ Q  |
         |    P    |       |    P    |
         |    Q    |       |    Q    |
         |    X    |       |    X    |
         +---------+       +---------+

   ◇(P -> Q), ◇P |- ◇Q

               +--------------+w0           Not all paths close
               |* ◇(P -> Q)   |             so the argument
               |*     ◇P      |             is K-invalid.
               |*    ¬◇Q      |
               +--------------+
                |            |
                |            V
                |   +-----------------+w2
                |   |      P -> Q     |
                |   |        ¬Q       |
                |   |      /    \     |
                |   |    /        \   |
                |   |  ¬P          Q  |
                |   |              X  |
                |   +-----------------+
                |      |
                V      V
                +------+w1                  w1 is on the left branch but
                |   P  |                    accessible from w0 because it's
                |  ¬Q  |                    original wff ◇P is in w0.
                +------+

      As for our argument listed out in world box w0, ◇(P -> Q) is true
      in w0, since P -> Q is true in at least one world w2.  ◇P is true
      in w0, since P is true in w1.  But ◇Q is false in w0, since there
      is not world accessible from w0 where Q is true.  Since the premises
      are all true but the conclusion is false, the form is invalid.

M-Model/T-Model Definitions

   An M-MODEL is a K-model <W,R,a> in which the accessibility relation
   R is reflexive (K-models are not M-models).

   An argument P1, P2, ..., Pn |- C is M-VALID, or P1, P2, ..., Pn |=M B,
   iff there is no M-model <W,R,a> and world w in W for which aw(P1) = T
   and aw(P2) = T and ... and aw(Pn) = T but aw(C) = F

   M-counterexamples, M-satisfiability, M-equivalence, etc are defined
   similarly.

M-Model Truth-Trees

   To construct a truth-tree for M-validity always place an arrow from
   a world w to itself as soon as a world is introduced.  This means
   that the non-world-creating modal rules □ and ¬◇ are applied within
   the same world

Definitions of Other Models

   A K4-MODEL is a K-model <W,R,a> in which the accessibility relation
   is transitive.  So □ and ¬◇ rules can hop any number of arrows.
   So, if we have arrows for wRv, vRu then we can draw an arrow for vRu.

   A KB-MODEL is a K-model <W,R,a> in which the accessibility relation
   is symmetric.  All lines connecting world boxes are double-ended.

   A K5-MODEL is a K-model <W,R,a> in which the accessibility relation
   is euclidian; ie for all worlds w,v,u in W, if wRv and wRu the vRu.

   A B-MODEL is a KB-model that is also an M-model (revlexive).

   An S4-MODEL (or M4-model) is a K4-model that's also an M-model
   (reflexive).

   An S5-MODEL (or M5-model) is a K4-model that's also an M-model
   (reflexive).

   ====  ==================  ===============  ================================
   Name  Axiom               R-Condition      Description
   ====  ==================  ===============  ================================
   D     □P -> ◇P            Serial           wRv for some v
   CD    ◇P -> □P            Unique           if wRv and wRu then v=u
   □M   □(□P -> P)           Shift Reflexive  if wRv then vRv
   L     □(□P -> P) ∨        connected        if wRv and wRu then
           ((Q ∧ □Q) -> P)                       vRu or uRv or v=u
   C4    □□P -> □P           Dense            if wRv then vRu or uRv
                                                 for some u
   C     ◇□P -> □◇P          Convergent       if wRv and wRu then
                                                 vRt or uRt for some t
   ====  ==================  ===============  ================================

   In philosophical discussions S5 is the most widely accepted logic for
   absolute conceptions of modality like logical or metaphysical necessity.

Subjunctive Conditional

   A subjunctive conditional is an if a proposition could/migh be (but isnt
   yet).  eg.  If I were you, I would run.

         P □¬> Q


                         |T   If in any world v av(Q)=T such that av(P)=T
         ax(P □¬> Q) = -+       and v is at least as close to w as any
                         |       other world u such that au(P)=T.
                         |F   Otherise

   Unfortunately P □¬> B cannot be defined in terms of □ and ->.  Were
   we to add the sign □¬> to the language of our propositional modal logic,
   in order to do its formal semantics, we sould need our models to take the
   form <W,R,C,a> where C would be a 3-place relation between worlds
   (meaning, v is at least as close to w as u).

=========
Metalogic
=========

Metalogic is the logical system used to talk and prove things about logic.

Language Types

   An OBJECT LANGUAGE is the language we are talking about, investigating
   or studying.

   A METALANGUAGE is the language we use to talk about the object language.

   A METAPROOF is a proof written in out metalanguage about our object
   language and inderence rules.

   A METATHEOREM is anything provable within the metalanguage about our
   object language and inference rules.

   Taken together, the examination of what can be proven about a given
   logical system is called its METATHEORY.

Soundness & Completeness

   Given a set of premises our system can prove all and only logical
   consequences of our premises.  The 'all' part is COMPLETENESS, while
   the only part is SOUNDNESS.  Completeness guarantees us that if
   a certain conclusion follows from some premises then there is a finite
   length a proof in our system from the premises to the conclusion -
   guaranteed.  That is, the inference rules can derive anything they should
   be able to derive.  Soundness guarantees us that given a set of premies
   there is no sequence of applications of rules that can lead us to a false
   conclusion.  That is, the inference rules can't derive anything they
   shouldn't be able to derive.


===================================
First-Order Quantified Logic (FOL=)
===================================

Language
--------

Lexemes

   Non-Logical Symbols
      Object symbols (Terms)
         constants:            a...t
         variables:            u...z
      Predicates:              A...Z,=

   Logical Symbols
      Truth-Function Symbols:  ->, ⊥
      Association Symbols:     (, )
      Quantifiers
         universal:            Ax: (A is inverted)

Grammar (Rules for wffs)

   An ATOMIC FORMULA is either ⊥, or a predicate symbol followed
   by zero or more constants, or x=y (where, x,y are const and could
   be the same symbol).

   1.  Every atomic formula is a wff.
   2.  If P,Q are wffs, then (P -> Q) is a wff.
   3.  if P(c) is a wff, then so is Ax:P(x/c)
   4.  If P is a wff, then □P is a wff.
   5.  Nothing else is a wff.

   Notes

   - To aid readability of a wffs we adopt the convention that if a wff
     that begins with '(', we will drop the outter-most pair of parenthesis.

   - We'll often use letters from the end of the alphabet (x, y and z), like
     pseudo variables to serve as place-holders for arbitrary object symbols.

   - In practice it's common to use tick marks or numerical subscripts
     (we use postscripts) after the proposition symbol to increase to
     infinity the number of available symbols.

   - Identical permutations of symbols that form atomic single formulas should
     be treated as if they were the same proposition symbol, while different
     permutations ought be regarded as different proposition symbols.

Definitions
   
      Def -:    ¬P         =df  (P -> ⊥)
      Def ∧:    (P ∧ Q)    =df  ¬(P -> ¬Q)
      Def ∨:    (P ∨ Q)    =df  (¬P -> Q)
      Def <->:  (P <-> Q)  =df  ((P -> Q) ∧ (Q -> P))
      Def ◇:   ◇P          =df  ¬□¬P
      Def E:    Ex:P       =df  ¬Ax:¬P

Definite Descriptors

   A DEFINITE DESCRIPTOR is a lot like a singula term is Aristotelian Logic.
   We can define the concept upon thing we already have.

      ix:Px,   the x such that Px.

      ix:Kx    The king of france

   A definite descriptor expression denotes an object symbol.  So it's not
   a wff or an atomic formula.  We need to make it an argument of a predicat
   (as with any other object symbol) to have a wff.

      Qix:Kx   The kind of france is married to the queen.

   We can define this general statement in terms of Ex: and A:.

      Qix:Px  =df  Ex:(Ax:(Py <-> x=y) ∧ Qx)

First-Order Quantification Calculus (FOC - Fitch Style)
-------------------------------------------------------

Regarding Inference Rules

   P(Q) indicates that a wff P contains one or more occurrences of
   sub-expression Q.

   P(R/Q) indicates the result of replacing one or more occurrences
   of Q in P with R.  R/Q is read, "R replaced one or more occurrences of Q".

   P(R//Q) like above but indicates replacing all occurrences of Q in P with
   R.  R//Q is read, "R replaced all occurrences of Q"

   P(c),P(a/c),P(a//c), similar to the above but a and c are object symbols.

   [ ... ] indicates that the enclosed must exist, be defined or proven
   elsewhere.

Inference Rules (TFC)

   All the primitive inference rules from system TFL (->E, ¬I, RE, ¬E, ...)
   are carried over to FOL.  All derived rules carry over as well.

Inference Rules for Quantifiers

   let c represent some constant symbol, and x represent some variable.

   ================================  =========================================
   Name/Alternate Names              Rule
   ================================  =========================================
   Universal Elimination (A:E)       From Ax:P infer P(c//x);
                                     where c is any const.

   Universal Introduction (A:I)      From a subproof with hypothesis [c] and
                                     ending Q(c), close the subproof and
                                     infer Ax:Q(x//c); where c is new.
                                    
   Identity Elimination (=E)         From a=b, and P(a) infer P(b/a).

   Identity Introduction (=I)        Introduce a=a (for any a) as a new line
                                     in the proof.
   ================================  =========================================

   These rules are sometimes represented more visually.  The horizontal bar
   denotes 'infer', vertical lines denote subproofs, other symbology comes
   directly from my modified sequent notation.

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  A:E                          |  A:I                          |
      | ============================= | ============================= |
      |   Ax:P                        |   |   [c]  (new c)            |
      |  --------                     |   |   ...                     |
      |   P(c/x)  (any c)             |   |   Q(c)                    |
      |                               |  ------------                 |
      |                               |   Ax:Q(c//c)                  |
      |                               |                               |
      | ============================= | ============================= |
      |  =E                           |  =I                           |
      | ============================= | ============================= |
      |   a=b                         |                               |
      |   P(a)                        |  -----                        |
      |  --------                     |   a=a        a is any const   |
      |   P(b/a)                      |                               |
      |                               |                               |
      +-------------------------------+-------------------------------+

Deriving a Rhobust Fitch

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Existential Elimination (E:E)     From Ex:P(x), and a subproof with
                                     hypothesis [C] P(c//x) and ending Q,
                                     close the subproof and infer Q all within
                                     the same subproof; where c is new.

   Existential Introduction (E:I)    From P(c), infer Ex:P(x/c); all within
                                     the same subproof.
   ================================  =========================================

      +-------------------------------+-------------------------------+
      | ============================= | ============================= |
      |  E:E                          |  E:I                          |
      | ============================= | ============================= |
      |   Ex:P(x)                     |   P(c)                        |
      |   |   [c] P(c//x)  (new c)    |  -----------                  |
      |   |   ...                     |   Ex:P(x/c)                   |
      |   |   Q                       |                               |
      |  ---------------              |                               |
      |   Q                           |                               |
      |                               |                               |
      +-------------------------------+-------------------------------+

Derived Inference Rules

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
   Dual                              |-  ¬Ax:¬P <-> Ex:P
                                     |-  ¬Ax:P <-> Ex:¬P
                                     |-  Ax:¬P <-> ¬Ex:P
                                     |-  Ax:P <-> ¬Ex:¬P
   =Symmetry (=Sym)                  a=c  |-  c=a
   =Transitivity (=Trans)            a=c, c=e  |-  a=e
   ================================  =========================================


Proof
-----

E:Lemma (E:Lemma):  Ex:Px, Ax:(Px -> Q) |-QL Q
proof
01.   Ex:Px                  A
02.   Ax:(Px -> Q)           A
03.   ¬Ax:¬Px                1 DEF E:
04.   |   ¬Q                 H (for ¬I)
05.   |   Ax:(Px -> Q)       2 RE
06.   |   Pc -> Q            5 A:E (c/x)
07.   |   ¬Pc                4,6 MT
08.   |   Ax:¬Px             7 A:I (x/c)
09.   |   ¬Ax:¬Px            3 RE
10.   |   ⊥                  8,9 EFQ
11.   ¬¬Q                    4-10 ¬I
12.   Q                      11 ¬E
QED

Existential Introduction (E:I)  Ex:P(x), ( [c] P(c//x) |- Q ) |- Q
Proof
 i.   Ex:P(x)                A
 j.   |[c]P(c)               H (for ->I)
      |   ...
 k.   |   Q
 k+1. P(c) -> Q
 k+2. Ax:(Px -> Q)           k+1 A:I
 k+3. Q                      j,k+2 E:Lemma
QED


Existential Elimination (E:I)  P(c) |-  Ex:P(x/c)
Proof
01.   P(c)                   A
02.   |   ¬Ex:P(x)           H (for ¬I)
03.   |   Ax:¬P(x)           2 Def E:
04.   |   ¬P(c)              3 A:E (c/x)
05.   |   P(c)               1 RE
06.   |   ⊥                  4,5 ⊥
07.   ¬¬Ex:P(x)              1-6 ¬I
08.   Ex:P(x)                7 ¬E
QED

=Symmetry (=Sym):   a=c  |-  c=a
=Commutation (=COM)
   let Ixy, be a dummy identity predcate
Proof
01.   a=c                    A
02.   a=a                    =I
03.   Iaa                    2 DEF=
04.   Ica                    1,4 =E
05.   c=a                    
QED

=Transitivity (=Trans):  a=c, c=e  |-  a=e
   let Ixy, be a dummy identity predcate
Proof
01.   a=c                    A
02.   c=e                    A
03.   Ice                    DEF=
04.   c=a                    1 =Sym
05.   Iae                    =E
06.   a=e                    DEF=
QED


==========================================
Modal First-Order Quantified Logic (MFOL=)
==========================================


Language
--------

   Among the lexemes we add the two modal operators □ and ◇.

   For the Grammar the formation rules are extended to add two new cases
   to rule 2.  Notice we don't include ◇ since the definition takes care
   of that case.

   2.  if P is a wff, then so are ¬P, □P.


Semantics
---------

   The semantics are the same as for Modal Truth-Functional Logic.


Calculus
--------

   We will prepend 'q' to the name of a modal system to indicate that it's
   the MFOL= version.

   System qK:  The system obtained from FOL= by adding '□' to the syntax
   and □I and □E as additional inference rules.

   System qT (qM):  The system is obtained from qK by adding every instance
   of schema M as an axiom.

   System qB:  The system obtained for qT by adding every instance of
   schema B as an axiom.

   System qS4:  The system obtained from qT by adding every instance of
   schema 4 as an axiom.

   System qS5:  The system obtained from qT by adding every instance of
   schema 5 as an axiom.

   ================================  =========================================
   Name/Alternate Names              Sequent
   ================================  =========================================
                                     |-qK  Ax:(□Fx <-> □Ay:(x=y -> Fy))
   BF                                |-qK  Ax:□Px <-> □Ax:Px
   ================================  =========================================

Proofs

   |- qK  Ax:(□Fx <-> □Ay:(x=y -> Fy))
Proof
01.   |   □Fc                     H (for ->I)
02.   |   |□                      H (for □I)
03.   |   |   Fc                  1 □E
04.   |   |   |   c=d             H (for ->I)
05.   |   |   |   Fc              3 RE
06.   |   |   |   Fd              4,5 =E
07.   |   |   c=d -> Fd           4-6 ->I
08.   |   |   Ay:(c=y -> Fy)      7 A:I
09.   |   □Ay:(c=y -> Fy)         2-8 □I
10.   □Fc -> □Ay:(c=y -> Fy)      1-9 ->I
11.   |   □Ay:(c=y -> Fy)         H (for ->I)
12.   |   |□                      H (for □I)
13.   |   |   Ay:(c=y -> Fy)      11 □E
14.   |   |   c=c -> Fc           13 A:E (c/y)
15.   |   |   c=c                 =I
16.   |   |   Fc                  14,15 ->E
17.   |   □Fc                     11-16 □I
18.   □Ay:(c=y -> Fy) -> □Fc      11-17 ->I
19.   □Fc <-> □Ay:(c=y -> Fy)     10,18 <->I
20.   Ax:(□Fx <-> □Ay:(x=y -> Fy))  19 AI (x/c)
QED


BF   |-qK  Ax:□Px <-> □Ax:Px
Proof
01.   |   Ax:□Px                       H (for ->I)
02.   |   □Pc                          1 A:E (c/x)
03.   |   |□                           H (for □I)
04.   |   |   Pc                       2 A:E
05.   |   |   Ax:Px                    4 A:I (x/c)
06.   |   □Ax:Px                       3-5 □I
07.   Ax:□Px -> □Ax:Px                 1-6 ->I
08.   |   □Ax:Px                       H (for ->I)
09.   |   |[c]                         H (for A:I)
10.   |   |   □Ax:Px                   8 RE
11.   |   |   |□                       H (for □I)
12.   |   |   |   Ax:Px                10 □E
13.   |   |   |   Pc                   12 A:E (c/x)
14.   |   |   □Pc                      11-13 □I
15.   |   Ax:□Px                       10-14 A:I (x/c)
16.   □Ax:Px -> Ax:□Px                 8-15 ->I
17.   Ax:□Px <-> □Ax:Px                1-6 ->I
QED


================
Free Logic (FL=)
================

FREE LOGICS are logics in which not all const object symbols denote objects.
Therefore it's necessary to introduce notation for existence.

         E!c  =df  Ex:x=c    (where c is any const object symbol)

Primitive Inference Rules

   ================================  =========================================
   Name/Alternate Names              Rule
   ================================  =========================================
   Universal Elimination (A:E)       from Ax:Px infer E!c -> Pc.

   Universal Introduction (A:I)      from E!c -> Pc infer Ax:Px, provided
                                     c is not active in P or in the proof.
   ================================  =========================================

Identity

   The =E and =I rules come into free logic unchanged.

Derived Rules

   ================================  =========================================
   Name/Alternate Names              Rule
   ================================  =========================================
   Existential Elimination (E:E)     From E!c -> Pc infer Ax:Px, provided
                                     c is not active in P, or in the proof.
                                     Ex:Px, ( E!c ∧ Pc |- B ) |- B

   Existential Introduction (E:I)    From E!c ∧ Pc infer Ex:Px.
   ================================  =========================================
   

Modal Extensions of FL=
-----------------------

As with FOL= the modal extensions are arrived at by adding the definitions,
rules and axioms of one of our modal truth-functional logics to FL=.  We'll
use a 'f' prefix to names to indicate that we intend the free logic
equivalent.

   System fK:  The system obtained from FL by adding □ to the syntax of the
   language, and the inference rules □I and □O.

   System fT/fM:  The system obtained from fK by adding every instance of
   axiom schema M as an axiom.

   System fS4:  The system obtained for fT by adding every instance of
   axiom schema 4 as an axiom.

   System fS5:  The system obtained for fT by adding every instance of
   axiom schema 5 as an axiom.

Rigid Constants
---------------

Saul Kripke argued in *Naming and Necessity* that the objects that constant
object symbols denote exist in all possible worlds, and hence both identity
and negated identity atomic formulas are all necessary.

         a=a -> □a=a

         c=i -> □c=i

         -x=y -> □¬x=y

         etc.

This avoids the pitfall of not being able to bring an identity into a boxed
proof.  However, it also means that the universes for possible worlds are
supersets of the universes for the actual world.  Ao, a possible world either
has exactly the same members as the actual world, or has at least one more.


===================================
Leibnizian Semantics (World Theory)
===================================

Notation
   Necessary
   □P    =df  it's necessary that, P.
   World Index Notation
   [P/i]  =df  P (is true) at/in world i. (where i is any positive integer)

Leibniz Proposed,
   to be necessary is to be true in/at every possible world
Which we might write semi-formally as,
   Principle L:  □P  <->  Ai:(World(i) -> [P/i])
   or,           □P  <->  Ai:[P/i]

Multiple □
   for A string of boxes    □...□P <-> □P

   □□P <-> □P   is a theorem in Leibniz' system

Axioms of Leibnizian Semantics/World Theory
   wt(0)     P              <->  P/0
   wt(-)     [¬P/i]         <->  ¬[P/i]
   wt(->)    [(P -> Q)/i]   <->  ([P/i] -> [Q/i])
   wt(^)     [(P ∧ Q)/i]    <->  ([P/i] ^ [Q/i])
   wt(V)     [(P ∨ Q)/i]    <->  ([P/i] V [Q/i])
   wt(<->)   [(P <-> Q)/i]  <->  ([P/i] <-> [Q/i])
   wt(□)    [□P/i]        <->  Aj:[P/j]
   Wt(◇)    [◇P/i]        <->  Ej:[P/j]
   wt(A:)    [Ax:P/i]       <->  Ax:[P/i]
   wt(E:)    [Ex:P/i]       <->  Ex:[P/i]
   wt(/)     [[P/i]/j]      <->  [P/i]

Theorems
   t1:     □P -> P
   t2:     □(P -> Q) -> (□P -> □Q)
   t3:     ¬◇P <-> □¬P
   t4:     ¬□P <-> ◇¬P
   t5:     □P <-> □□P
   t6:     Ai:Aj:([□P/i] -> [□P/j])
   t7:     Ai:Aj:([◇P/i] -> [◇P/j])


==============================
System L (Purely Modal System)
==============================

In modal logic every line of a proof is true in some world.   This will be
indicated by adding a new column to the proof to track world indices.  World
indeces will be written as '/i', where i is some whole number.  0 is
customarily reserved to indicate the actual world.  Sometimes /* is used in
cases where something is true universally (in any world).

For all current logic rules, all propositions are within the same world.

Inference Rules

⊥I:     P     /i      ⊥E:        ⊥          /*        ⊥R:     ⊥   /*
        ¬P    /i              -------                        -------
       ----                      P          /j                ⊥   /*
        ⊥     /*


□E:     □P    /i      □D:     SHOW: □P      /i
       -----                  |  SHOW:  P   /k (new)
        P     /j              |  |
                        An old index is one that's
                        already active (not closed)
                        on the current line.

◇I:     P     /i      ◇E:      ◇P           /i
       -----                  ------
        ◇P    /j               P            /j (new)

MDual:  ¬□P                   ¬◇A
       ======                 ======    <-- the double line reps '<->'
        ◇¬P                   □¬P

¬□E:    ¬□P    /i              ¬◇P          /i
       ------                 ------
        ¬P     /k (new)        ¬P           /j

Definitions

'(P -< Q)'   =df  '□(P -> Q)'     (called 'strict conditional')

'(P >-< Q)'  =df  '□(P <-> Q)'    (called 'strict biconditional')


Examples
   □(P -> Q), □P  |-  □Q
Proof
01.   □(P -> Q)            /0     A
02.   □P                   /0     A
03.   SHOW: □Q             /0     □D
04.   |  SHOW: Q           /1     DD
05.   |  |  (P -> Q)       /1     1 □E
06.   |  |  P              /1     2 □E
07.   |  |  Q              /1     5,6 ->E
QED

   □(P -> Q), ◇P  |-  ◇Q
Proof
01.   □(P -> Q)            /0     A
02.   ◇P                   /0     A
03.   SHOW: ◇Q             /0     DD
04.   |  P                 /1     2 ◇E
05.   |  (P -> Q)          /1     1 □E
06.   |  Q                 /1     4,5 ->E
07.   |  ◇Q                /0     6 ◇I
QED

Counter-Models in System L
--------------------------
Here we develop a system to prove a sequent invalid.

General Ideas about Invalidity (definitions)
   d1.   Let L be a formal language.
         'a *valuation* on L'
            =df  a function assigns truth-value to every formula in L

   d2.   Let L be a formal language.
         'a *truth-value* semantics of L'
            =df  a set ∨ of valuations on L.  The set ∨ is the set of
                 admissible valuations for that semantics.

   d3.   Let L and ∨ be as before.  Let P1,...,Pn |- C be an argument
         in L.  Then P1,...,Pn |- C is '*valid* relative to ∨'
            iff there is no v in ∨ such that
                v(p1)=v(P2)=...=v(Pn)=T and v(C) = F.

   d4.   Let L,V and P1,...,Pn |- C be as before.  Let v be a valuation
         in V. Then v is
         'v is a *counter-model* to P1,...,Pn |- C'
            <->  v(P1)=v(P2)=...v(pn)=T and v(C)=F

Valuations in TFL

   d5.   Let L be TFL.  Let v be a valuation on L.  
         'v is admissible'
            =df  v satisfies the following conditions

         1. v(¬P)      = T   iff   v(P) = F
         2. v(P ∧ Q)   = T   iff   v(P) = T and v(Q) = T
         3. v(P ∨ Q)   = T   iff   v(P) = T and/or v(Q) = T
         4. v(P -> Q)  = T   iff   v(P) = F or v(Q) = T
         5. v(P <-> Q) = T   iff   v(P) = v(Q)

Valuations in Indexed TF Logic

   d6.   Let L be TFL, S the set of wffs in L,
             I be a non-empty set of indices,
             v be a function from (S X I = (TFL + Indices)) into {F,T}.
         'v is an *admissible I-valuation* on L'
            =df  it satisfies the following conditions for every
                 element i of I (where we write v(P/i))

         1. v(¬P/i)    = T   iff   v(P/i) = F
         2. v(P∧Q/i)   = T   iff   v(P/i) = T and v(Q/i) = T
         3. v(PVQ/i)   = T   iff   v(P/i) = T and/or v(Q/i) = T
         4. v(P->Q/i)  = T   iff   v(P/i) = F or v(Q/i) = F
         5. v(P<->Q/i) = T   iff   v(P/i) = v(Q/i)

   d7.   Let L,S,and I be as in d6; let v be a valuation on S.
         'v is an *admissible valuation* on L'
            =df  There is an admissible I-indexed valuation w, and index i,
                 such that for any P in S, v(P)=w(P/i).

   These conditions can be made somewhat more intuitive by rewritting them
   in accordance with the following definitions.

   d8.   'P is true at i according to v'   =df  'v(P/i)=T'

   d9.   'P is false at i according to v'  =df  'v(P/i)=F'

   If the valuation is understood, then we drop the expression
   'according to v'.  This allows us to employ the following abbrevs.

      T/i  =df  true at i according to v
      F/i  =df  false at i according to v

   Rewrite the semantic conditions (d6) as follows.  Note also that we
   abbrev, since we don't refer to truth-valuse, we use 'T' instead of
   'True', and 'F' instead of 'False'

         1. ¬P is T/i    = T   iff   P is F/i
         2. P∧Q is T/i   = T   iff   P is T/i and Q is T/i
         3. PVQ is T/i   = T   iff   P is T/i and/or Q is T/i
         4. P->Q is T/i  = T   iff   P is F/i or Q is F/i)
         5. P<->Q is T/i = T   iff   A,B are T/i or A,B are F/i

   Notice that these closely parallel the axioms of World Theory that
   pertain to the TF operators.  To show the parallel, one first notes
   that 'P is F/i' is equivalent to 'it is not the case that A is T/i'.

Valuations in System L

   This system builds on top of TFL.  Here we redefin the valuation function
   to accomodate System L, starting with d6 and adding four more rules
   as below

   d10.  Let L be System L (Modal TFL), S the set of wffs in L,
             I be a non-empty set of indices,
             v be, an I-indexed valutaion on L is by definition a function
             from (S X I = (Modal TFL + Indices)) into {F,T} subject to the
             following conditions on every element i of I.

         1. v(¬P/i)    = T   iff   v(P/i) = F
         2. v(P∧Q/i)   = T   iff   v(P/i) = T and v(Q/i) = T
         3. v(PVQ/i)   = T   iff   v(P/i) = T and/or v(Q/i) = T
         4. v(P->Q/i)  = T   iff   v(P/i) = F or v(Q/i) = F
         5. v(P<->Q/i) = T   iff   v(P/i) = v(Q/i)
         6. v(□P/i)   = T   iff   v(P/j) = T, for every j in I
         7. v(◇P/i)   = T   iff   v(P/j) = T, for at least one j in I
         8. v(P-<Q/i)  = T   iff   v(P/j) = F or v(Q/i) = F, for every j in I
         9. v(P>-<Q/i) = T   iff   v(P/j) = v(Q/j), for every j in I

   d11.  Let L,S be as before, P1,...,Pn |- C can be an argument in L.  Then
         a counter-model to P1,...,Pn |- C is any indexed valuation v on L
         and index i such that
            v(P1/i)=v(P2/i)=...=v(Pn/i)=T, and v(C/i)=F

Counter Models in System L

   We do this using the reverse truth-table method.  If we use suspect P is
   an invalid argument form, so we want to construct a counter-model to it,
   which means that we need to find an indexed-valuation that makes the
   premises true and the conclusion false.

   1.  Start by writing the sequent, in a column to the left write 0 for
       indexical world 0 (the actual world).  We can add indices for worlds
       by adding rows with the index under the first column.
       Hint: spacing things out a little can decrease confunsion & errors

   2.  Under the conclusion's primary operator write F (for false), and
       under each premise's primary operator write T (for true).

   So now you can start to see what we're doing:  setting each premise to
   true, and the conclusion to false; which is the definition of an invalid
   argument.

   3.  Work the connectives backwards to how you normall work truth-tables.
       Some values will have to be ? (unknown).

   Example
      Let's evaluate □(P ∨ Q) |- (□P ∨ □Q)

      1. Write it out.

            □ ( P ∨ Q ) |- ( □ P ∨ □ Q )
         0 

      2. Write F under conclusion & 3 write T under each premise.

            □ ( P ∨ Q ) |- ( □ P ∨ □ Q )
         0  T                    F

      3. Next we apply the truth conditions to index 0 wherever we can.
         First, since □(P ∨ Q) is T/0, (P ∨ Q) is T/0.  Since (□P ∨ □Q)
         is F/0, □P is F/0, and □Q is F/0.

            □ ( P ∨ Q ) |- ( □ P ∨ □ Q )
         0  T     T          F   F F

      4. Next since □P is F/p, P must be F at *some* index.  So we 'create'
         a new index, labeled '1', at which P is F.  Similarly, □Q is F/0,
         so Q must be F at some index.  We create a new index '2', at which
         Q is F.  Notice if a wff occurs twice on a line, its truth-value is
         written twice.

            □ ( P ∨ Q ) |- ( □ P ∨ □ Q )
         0  T     T          F   F F
         1      F              F
         2          F                F

      5. But since □(P ∨ Q) is T/0, (P ∨ Q) must be T/1 and T/2. The former
         is necessary so T in all world indices.

            □ ( P ∨ Q ) |- ( □ P ∨ □ Q )
         0  T     T          F   F F
         1      F T            F
         2        T F                F

      6. Applying the truth-function for ∨.

            □ ( P ∨ Q ) |- ( □ P ∨ □ Q )
         0  T     T          F   F F
         1      F T T          F     T
         2      T T F          T     F

      7. That the table can be completed in a manner that is consistent with
         the semantic rules.   Here's one way to do this.
   
            □ ( P ∨ Q ) |- ( □ P ∨ □ Q )
         0  T   T T F        F T F F F
         1  T   F T T        F F F T T
         2  T   T T F        F T F F F

      8. By way of concluding this section, we observe that the above table
         can be replaced by a smaller one that consolidates indices 0 and 2.

            □ ( P ∨ Q ) |- ( □ P ∨ □ Q )
         0  T   T T F        F T F F F
         1  T   F T T        F F F T T

         From the first paragraph of this section: "...we need to find an
         indexed-valuation that makes the premises true and the conclusion
         false.  We've succeeded in doing this and we actually found two
         valuations on which the sequent is invalid.

Rules for Constructing Counter-Models in L

   Reminder:  The TF rules of indexed TFL
   (presented shorly after d9 - definition 9 - above)

         1. ¬P is T/i    = T   iff   P is F/i
         2. P∧Q is T/i   = T   iff   P is T/i and Q is T/i
         3. PVQ is T/i   = T   iff   P is T/i and/or Q is T/i
         4. P->Q is T/i  = T   iff   P is F/i or Q is F/i)
         5. P<->Q is T/i = T   iff   A,B are T/i or A,B are F/i

   Modal Rules

      ◇E:  If ◇P is T/i, then P is T/j (new index).

            See this?         Do this:

                 ◇P               ◇P
            i    T            i    T
                              j      T    <- create new world index j

      □E:  If □P is T/i, then P is T/j (j is any index accessible to i).
            This discharges a rule at ever existing accessible world.

            See this?         Do this:

                 □P               □P
            i    T            i    T
                              j      T    <- any existing world j
                                             accessible to i

      ¬□E: If □P is F/i, then P is F/j (new index).

            See this?         Do this:

                 □P               □ P
            i    F            i   F
                              j     F    <- create new world index j

       ¬◇E: If ◇P is F/i, then P is F/j (j is any index accessible to i).
            This discharges a rule at ever existing accessible world.

            See this?         Do this:

                 ◇P               ◇ P
            i    F            i   F
                              j   F F    <- any existing world j
                                             accessible to i

Strict Operator Rules

From the following definitions for the strict operators, we can expand any
strict operator to a modal-conditional wff.  Then continue analyzing
accordingly.

   (P -< Q)   =df  □(P -> Q)     (called 'strict conditional')
   (P >-< Q)  =df  □(P <-> Q)    (called 'strict biconditional')

Relation Between Derivations & Counter-Models in System L

   Notice that the rules in the last section for constructing counter-models
   are identical to the rules for constructing derivations.  Consider our
   earlier example.

      □(P ∨ Q) |- (□P ∨ □Q)

   Let's construct a partial derivation.  Notice we go immediately into an
   indirection derivation.   This corresponds to the first step in
   construcing a counter-model.

      01.   □(P ∨ Q)              /0    Pr
      02.   ~: (□P ∨ □Q)          /0    ID
      03.      ~(□P ∨ □Q)         /0    As
      04.      ~: ⊥               /*
      05.         ¬□P             /0    3 SL
      06.         ¬□Q             /0    3 SL
      07.         (P ∨ Q)         /0    1 □E
      08.         ¬P              /1    5 ¬□E
      09.         ¬Q              /2    6 ¬□E
      10.         (P ∨ Q)         /1    1 □E
      11.         (P ∨ Q)         /2    1 □E
      12.         P               /1    8,10 DS
      13.         Q               /2    9,11 DS

   We've discharged all the rules.  Since we haven't reached a contradiction
   the argument is invalid.

   The partial derivation above provides a blueprint fro constructing a
   counter-model to the argument.  According to the blueprint, there are
   three indices: 0,1,2; furthermore,

      (P ∨ Q) is T/0       line 7
      P is T/1             line 12
      Q is F/1             line 9
      P is F/2             line 8
      Q is T/2             line 13

   Any truth assignment to P and Q at 0 consistent with this completes
   the counter-model.


===================
Alethic Modal Logic
===================


Grammar
-------

Lexemes
   Operators
      Basic:    □A, it's necessary that, A.  For all possible worlds, A.
      Derived:  ◇A, it's possible that, A.   For some possible world, A

   Syntax
      In addition to all the rules of FOL=:
      2.  if A is a proposition so is □A.

   Definitions
      Def◇    ◇P        =df  ¬□¬P
      Def-<    (P -< Q)   =df  □(P -> Q)
      Def>-<   (P >-< Q)  =df  (P -< Q) ∧ (Q -< P)

Semantics
   modal square of opposition

      □P-----------□¬P
       | \       / |
       |   \   /   |
       |     X     |
       |   /   \   |
       | /       \ |
      ◇P-----------◇¬P

Translation Hints

   Form          Translations
   ------------  ------------------------------------------------------
   P             it's true that P
                 P is true in the actual world
   ◇P            it's possible that P
                 P is logically possible (not self-contradictory)
                 P is true in some possible world
                 P is consistent
                 P could be true
   □P            it's necessary that P
                 P is logically necessary (self-contradictory to deny)
                 P is true in all possible worlds
                 P must be true
                 P has to be true
   ¬◇P           P is not possible
   □¬P           P has to be false
   □(P -> Q)     P entails Q
                 P strictly implies Q
   ◇(P ∧ Q)      P is logically consistent with Q
                 P is logically compatible with Q
                 It's possible that, P and Q
   ¬◇(P ∧ Q)     P is logically inconsistent with Q
   (◇P ∧ ◇¬P)    P is a contingent statement
   (P ∧ ◇¬P)     P is a contingent truth

   If P then necessary (must be) that Q  (ambiguous)
      translations   (P -> □Q)    
                     □(P -> Q)
   If P then it's impossible (couldn't be) that Q (ambiguous)
                     (P -> □¬Q) or □(P -> ¬Q)
   If P then Q (by itself) is necessary (unambiguous)
                     (P -> □Q)

   ◇Ax:Ax       Everyone could be above average
   Ax:◇Ax       Anyone could be above average

   □Px          P is a necessary (essential) property of x
   (Px ∧ ◇¬Px)  P is a contingent (accidental) property of x

   Simple Necessity
   Ax:(Px -> □Qx)   All bachelors are inherently unmarriable.

   Condityional Necessity
   □Ax:(Px -> Qx)   It's necessarily true that all bachelores are unmarried.

   But translate something like, "All P's are necessarily Q's" into both forms
      Ax:(Px -> □Qx)
      □Ax:(Px -> Qx)

System K (Kripke) - Minimal and Uncontrovesial
   Not able to perform many operations
   Necessitation Rule (NR)
      If A is an axiom or theorem of K then □A is as well
      if |- A then □A
   Distribution Axiom (MDist)
      □(A -> B) -> (□A -> □B)
   Definition of Possibility (Def◇)
      ◇A =df ¬□¬A

   System K can alternatively be defined in Fitch thus:

      Boxed subproof, a subproof with no hypothesis but rather simply the
      operator □.  Informally, the □ header indicates that every line in
      the subproof is shown to be necessarily true.

      We can't bring statements into boxed subproofs using Reit.

      □E:  If a line of the form □P is not closed in the enclosing subproof
            one may infer P within the boxed subproof.

      □I:  If P is derived within a boxed subproof, the boxed subproof may
            be closed and one may infer □P outside of the subproof.

      The Distribution axiom above is a theorem in this system.

      Using boxed subproofs it's possible to derive □P for any tautology P.

System D (System K + Axiom D)
      Weakest System Considered
      Most often used with Deontic over Alethic.
   Axiom D (D)
      □A -> ◇A

System T (AKA System M)
      System K + Axiom M (or T)
      Stronger version of D
      D is contained (derivable from) in M
      More commonly used in modal logic
   Axiom M (Axiom T)
      □A -> A   Corollary  A -> ◇A

System S4 (System T/M + Axiom 4)
      System K + Axiom T/M + Axiom 4
   Axiom 4
      □A -> □□A   Corollary ◇◇A -> ◇A

System S5 (System T/M + Axiom 5)
      Axiom 5 is a stronger version of Axiom 4
      4 is derivable from 5
   Axiom 5
      ◇A -> □◇A    corollary ◇□A -> □A (corollary where most contention)

System B (System T + Axiom B)
      (S5 can be formulated either by adding 5 or (B and 4) to T)
      A consequence of M + K is □(A -> ◇A)
   Axiom B
      A -> □◇A     corollary ◇□A -> A (corollary is contentious)

Controversey over S4 and S5
   S5 is used for the modal ontological arguments which don't work in any
      other modal system.  Yet people feel that s5 says and infers things
      that people don't usually want as part of their alethic system.
   S4 is much less controversial.
   Perhaps instead of Ax 5, (◇A -> □◇A), we want □(◇A -> ◇A)
      Remember these are ambiguous: □(P -> Q), (P -> □Q)

Other Axioms That Have Been Used
   Axiom g    ◇□P -> □◇P
   Axiom L    □(□A -> B) ∨ □(□B -> A)    (L - linear)
   
Misc
   Axiom 5 = Axiom 4 + Axiom B
   S4   = K + M + 4
   S5   = K + M + 5
        = K + M + 4 + B
   Ax 5 = 4 + B

        Rules          Axioms          Modal Logics
        -------------  --------------  -----------------
System  NR Dist Def◇   D  T/M s4 s5 B  Al De Tem Epi Dox
------  -------------  --------------  -----------------
K       *   *    *

D       *   *    *     *               1  9
T/M     *   *    *     .   *

S4      *   *    *         *  *
S5      *   *    *         *  .  *

B       *   *    *         *        *

. means it's entailed in the axiom to the right.

Ax T entails Ax D ("T is stronger than D")
Ax s5 entails Ax s4 ("S5 is stronger than S4")
S5 can be formulated either by adding 5 or B and 4 to T     ?????
S5 is used for the modal ontological arguments which don't work in any
   other modal system.  Yet people feel that s5 says and infers things
   that people don't usually want as part of their alethic system.

Non-Historical Modal Systems

   Neo-Systems

   KB     k,b rules
   K4     k,4 rules
   K5     k,5 rules
   KDB    k,d,b rules
   KD4    k,d,4 rules
   KD5    k,d,5 rules
   K45    k,4,5 rules
   KD45   k,d,4,5 rules
   KB4    k,b,4 rules

   G-Systems

   A G-System axiom is any axiom achieved by exponentiating the modal
   operators in the formual g as follows

                      j  k       m  n
      G(j,k,m,n)      ◇  □  P -> □  ◇ P

   The exponents work as expected in that they simply name the number of
   occurrences of the base symbol.

   A G-system is a modal logic that contains the K-thesis as well as
   finitely many theses of the form G(j,k,m,n).  Nearly every thesis we
   have considered can be written using G-notation

      axiom    G-notation     Dual
      -----    ----------     ----
       g       G(1,1,1,1)
       d       G(0,1,0,1)
       t       G(0,1,0,0)     G(0,0,1,0)
       b       G(1,1,0,0)     G(0,0,1,1)
       4       G(0,1,2,0)     G(2,0,0,1)
       4.2     G(0,2,3,0)     G(3,0,0,2)
       4.3     G(0,3,4,0)     G(4,0,0,3)
       ...
       5       G(1,1,1,0)     G(1,0,1,1)

   System X1
       K           □(A -> B) -> (□A -> □B)
       G(0,1,1,1)  □A -> □◇A

   System X2
       K           □(P -> Q) -> (□P -> □Q)
       G(2,1,2,1)  ◇◇□P -> □□◇P


Kripke Semantics
----------------

Kripke defined modal semantics starting with the position of possible worlds,
which was already being done, but Kripke defined a new semantic concept of an
accessability relation between two worlds.

   The accessability relation
     wxRwy             means world wx can access world wy, 
                       where x,y are possible world numbers

You can think of it as an arrow pointing from wx to xy; indicating
accessibility and its direction.
  Gensler compared it to a one way
intergalactic travel ticket.  The ticket is 'defined' every time a ◇
operator causes us to open a new world (Explicitly done in modal truth
trees and Fitch proofs).

Handling the ◇ operator is uncontroversial.  It's to always split off into
a new world.  However, the □ operator is another story.  Every time we split
a new world off as a consequence of ◇, we create an accessibility relation
from the origin world to the new world.  The controversey is in how □P
propositions should be granted access.  There are all different ideas such as
granting P in any child world (where you can follow the accessibility relation
arrow).  Some people say the arrow should be two-way granting access to □P
from the origin world to the new world.  The controversey is in how □P
propositions should be granted access.  There are all different ideas such as
granting P in any child world (where you can follow the accessibility relation
arrow).  Some people say the arrow should be two-way granting access to □P
propositions from either of the two worlds to P in the other.  There are
versions that allow transitivity; traversing along multiple arrows.

All of these different versions of the modal accessibility relation for □
propositions.  To understand the variations lets first look at different
properties the relation operator might have.

   Reflexivity
      If exists wx then wxRwx.   (Allows □P to assert P in the current world)

   Symmetry
      If wxRwy then wyRwx.       (Every accessability arrow is double ended)

   Transitivity
      If wxRwy and wyRwz then wxRwz.   (□P can traverse multiple worlds)

System M/T = K + refl                     □A -> A (axiom M/T) = K + T
System B   = K + refl + symmetry          A -> □◇A (axiom B)
System S4  = K + refl + trans             □A -> □□A (axiom 4)
System S5  = K + refl + symmetry + trans  ◇A -> □◇A (axiom 5)

In S5 every world has access to every other world.

Genzler Semantics & Fitch Inference Rules
-----------------------------------------
Galactic Travel (a rewording of the accessibility relation)

   World Prefixes (Indexes)
      Gensler uses the concept of World Prefixes. These are strings of the
      form 'Wn', where n is some integer and the entire string is the name of
      some possible world.

      Use 'W0' for the actual world.

   Travel Tickets
      Travel Tickets are just a more intuitive notion to grasp than the
      accessiblity relation.  However, the concepts are actually identical
      and therefore interchangeable.  Gensler uses the concept of a travel
      ticket written, 'Wn=>Wm' to indicate that we have a ticket to travel
      from one world 'Wn' to another world 'Wm'.

   The ◇E inference rule
      According to Gensler the inference rule for ◇Elim is simple and
      uncontroversial.  From ◇P at i, we use ◇Elim to enter any new
      (previously unvisited) world, and so we obtain P at j.  In other words
      we can "drop diamond" into a new world index.  So, if we start with ◇P
      at 0, we can ◇E producing P at 1.

      ◇E also gives us a travel ticket W0=>W1.

      Travel tickets are then by □E to drop into worlds.  The particular
      system determines how we are allowed to use travel tickets to perform
      □E

   Systems

   System T/M - We need a ticket w1 => w2 first,
                for a □Elim to go from w1 to w2.

   System B   - Like System T, but tickets work in both directions
                (symmetry)

   System S4  - Like System T, but we can jump a series of connecting tickets
                (transitive)

   System s5  - □Elim into any world
                (symmetry + transitive)

□Elim   □P/n,Wn=>Wm     |-  P/m    (use travel ticket according to system)
□Intro  ( P/n |- Q/n)    |-  □Q    (this rule is not needed)
◇Elim   ◇P/n            |-  P/m & Travel Ticket Wn=>Wm (m is a new world)
◇Intro  P/n              |-  ◇P/n  (this rule is not needed)

Kinds of Accessibility Relations

serial              Ser(R)    =df  Ax:Ey:(xRy)
Reflexive           Ref(R)    =df  Ax:(Ey:(xRy ∨ yRx) -> xRx)
Completely Reflex   C-Ref(R)  =df  Ax:(xRx)
Irreflexive         Irref(R)  =df  ¬Ex(xRx)
Transitive          Trans(R)  =df  Axyz:((xRy ∧ yRz) -> xRz)
Symmetric           Sym(R)    =df  Axy:(xRy -> yRx)
Euclidean           Euc(R)    =df  Axyz:((xRy ∧ xR) -> yRz)
Incestual           Incest(R) =df  Axyz:((xRy ∧ xRz) -> Ew:(yRw ∧ zRw))
Asymmetric          Asym(R)   =df  Axy:(xRy -> ¬(yRx))
Anti-Symmetric      Anti(R)   =df  Axy:((xRy ∧ yRx) -> x=y)
Universal           Univ(R)   =df  Axy:(xRy)
Identity            Iden(R)   =df  Axy:(xRy -> x=y)
Functional          Fun(R)    =df  Axyz:((xRy ∧ xRz) -> y=z)
Inverse-Funcational I-Fun(R)  =df  Axyz:((xRz ∧ yRz) -> x=y)
Strongly Connected  SCon(R)   =df  Axy:(xRy ∨ yRx)
Weakly Connected    WCon(R)   =df  Axy:(-x=y -> (xRy ∨ yRx))
Non-Convergent      N-Con(R)  =df  Axyz:(((xRz ∧ yRz) ∧ -x=y) -> xRy ∨ yRx)
Non-Divergent       N-Div(R)  =df  Axyz:((xRy ∧ xRz ∧ -y=z) -> (yRz ∨ zRy))
Equiv Relation      Equ(R)    =df  CRef(R) ∧ Tran(R) ∧ Sym(R)
Quasi-Ordering      QO(R)     =df  CRef(R) ∧ Tran(R)
Partial Ordering    PO(R)     =df  QO(R) ∧ Anti(R)
Refl Linear Order   RLO(R)    =df  PO(R) ∧ SCon(R)
Irrefl Linear Ord   ILO(R)    =df  Asym(R) ∧ Trans(R) ∧ W-Con(R)
Tree-Ordering       Tree(R)   =df  PO(R) ∧ N-Conv(R)
Root-Ordering       Root(R)   =df  PO(R) ∧ N-Div(R)
Upper-Bounded       U-Bound(R)=df  Axy:((Ez(xRz) ∧ Ez:(yRz)) -> Ez:(xRz ∧ yRz))
Lower-Bounded       L-Bound(R)=df  Axy:((Ez(zRx) ∧ Ez:(zRy)) -> Ez:(zRx ∧ zRy))
Bounded             Bound(R)  =df  U-Bound(R) ∧ L-Bound(R)
Dense               Dense(R)  =df  Axz:((xRz ∧ -x=z)
                                      -> Ey:(-x=y ∧ -y=z ∧ xRy ∧ yRz))

Deontic Logic
=============
   Lexemes
      OB(p), it is obligtory that, p.
      IM(q), it is impermissible that, q.
      PE(r), it is permissible that, r.
      OM(s), it is omissible (not required) that, s.
      OP(t), it is optional that, t.
   Definitions (DeD)
      - Any one of the first four lexemes above is sufficient to define all
        of the remaining 5 operations.  We will define them in terms of OB.
      IM(p) =df OB(-p)
      PE(p) =df ¬OB(-p)
      OM(p) =df ¬OB(p)
      OP(p) =df ¬OB(p) ∧ ¬OB(-p)
   Trifold Classification
      Table:

          OB

          PE  OP  OM

                  IM

      - Items along the long diagonal are mutually exclusive.
      - OB must also be PE and nothing else.
      - PE can be OP, OB or OM and while it can be OP and OM it can't be
        OB and either OP or OM.
         PE
         ------
         OB  OP  IM
             ------
                 OM

      -  OB, OP, IM are mutually exclusive.
      -  for any propositions p,q If referring to the table
         some p is above or below some q above the we can say both
         p is q, and q is p.

   Deontic Square

      OB---contrary----IM
      | \             / |
      |   \         /   |
      |     \     /     |
   sub|       \ /       |sub
      | contradictories |
   alt|       / \       |alt
      |     /     \     |
      |   /         \   |
      | /             \ |
      PE--subcontrary--OM

      - contradictory (cross through the middle)
           means: They have opposite truth values.
           ¬(OB(p) <-> OM(p))
           ¬(IM(p) <-> PE(p))
      - contrary (across the top)
           means: At least one is false (can't both be true)
           ¬OB(p) ∨ ¬IM(p)
      - subcontrary (across the bottom)
           means: At least one is true (can't both be false)
           PE(p) ∨ OM(p)
      - subalt/subalternation (down the sides)
           means: Truth flows downward, Falsehood flows upward
           Or, the Top term implies the lower term
           OB(p) -> PE(p)
           IM(p) -> OM(p)

   Deontic Hexagon

               OB---contrary----IM
             / | \             / | \
           /   |   \         /   |   \
         /     |     \     /     |     \
       /    sub|       \ /       |sub    \
     OP        | contradictories |        OP-
       \    alt|       / \       |alt    /
         \     |     /     \     |     /
           \   |   /         \   |   /
             \ | /             \ | /
               PE--subcontrary--OM

      - OB, IM  are contraries (at least one is false)
           ¬OB(p) ∨ ¬IM(p)
      - OB, OP- are contraries
           ¬OB(p) ∨ ¬OP(-p)
      - OB, OP  are contraries
           ¬OB(p) v ¬OP(p)
      - IM, OP  are contraries
           ¬IM(p) v ¬OP(p)
      - IM, OP- are contraries
           ¬IM(p) ∨ ¬OP(-p)
      - OB, PE  are subalternates
           OB(p) -> PE(p)
      - OP, PE  are subalternates
           OP(p) -> PE(p)
      - OP, OM  are subalternates
           OP(p) -> OM(p)
      - IM, OM  are subalternates
           IM(p) -> OM(p)
      - OP-, OM are subalternates
           OP(-p) -> OM(p)
      - PE, OM  are subcontraries
           PE(p) v OM(p)
      - OP, OP- are equivalent
           OP(p) <-> OP(-p)
 
   Isomorphisms
      Deontic  Alethic
      -------  -------
      OB(p)    □p
      PE(p)    ◇p
      IM(p)    ¬◇p
      OM(p)    ¬□p
      OP(p)    ◇P ∧ ◇¬P  (contingent)

      Deontic                     Alethic
      -------                     -------
      PE(p) =df ¬OB(-p)           ◇p =df ¬□¬p
      IM(p) =df OB(p)             impossible p =df □¬p
      OM(p) =df ¬OB(p)            ¬□p =df ¬□p
      OP(p) =df ¬OB(p) ∧ ¬OB(-p)  contingent p =df ¬□p ∧ ¬□¬p

      - The alethic operations fit in the Hexagon
      
      Differences
      - There are some alethic modal logic axioms, such as axiom T,
        that make sense in alethic modal logic but not in deontic.
      - Axiom T (T or M)
        □A -> A
        Yet it wouldn't make sense to say that anything that is OB is true,
        since clearly there are things that are OB but aren't done.

   Deontic Equivalence Axiom
      Equivalence Axiom (DEA)
         (p <-> q) -> (OB(p) <-> OB(q))

   Tautology and Contradiction Notation
      lexemes
         T     =df  all tautologies or all logical truths
         ⊥   =df  all logical contradictions

      Ex
         □T     all logical truths are necessary
         ¬◇⊥  it's not the case that it's possible that all contradictions
                 are the case

   Omissibility of Contradictions Axiom (OmA)
      ¬OB(⊥) also OM(⊥)
         If something is ⊥, no deontic system can requires that it's OB

   Type os Deontic Contradictions
      OM         DNC (Deontic non¬Contradiction)
      --------   -------------------------------
      ¬OB(⊥)     ¬(OB(p) ∧ OB(-p))

      These are not interderivable 
      
      Omissibility
         ¬OB(⊥)
         means: can't make someone do something that's a contradiction.

      Deontic non-contradiction (DNC)
         ¬(OB(p) ∧ OB(-p))
         means: can't obligate both p and -p.

         - The key differences between these two is in the scope of OB.
         - While the Omissibility Rules is rarely contested, there is a great
           deal of debate around DNC.





Standard Deontic Logic (SDL)
   - The goal here is the have a Deontic logic which is an isomorphism to
     alethic modal logic.
   - Most commonly used and referenced version of Deontic Logic that you will
     find.
   - All it's going to do is take the Axioms we've explored so far and put
     them in a format that makes them isomorphically related to the axioms
     of Alethic Modal Logic

   Definitions
      Definition of Permissible (PEDef)
         PE(p)  =df  ¬OB(-p)

   Axioms
      Axiom K (K)
         Alethic:  □(A -> B) -> (□A -> □B)
         Deontic:  OB(p -> q) -> (OB(p) -> OB(q)) 

      Axiom D (D)
         Alethic:  □A -> ◇A
         Deontic:  OB(p) -> ¬OB(-p)   or by definition,
                   OB(p) -> PE(p)

         Corollary
            IM(p) -> ¬OB(p)

      Necessitation Rule (NR)
         Alethic:  if |- A then □A      for all axioms and theorems A
         Deontic:  if |- p then OB(p)    for all axioms ans theorems p

         - It can be used with D to prove OmA (Omissibility of
           Contradictions Axiom).
         - According to this rule it's not just illogical to have
           p and -p, it's morally wrong.  It's OB(¬(p ∧ -p)).
         - Demonstrating that the liar paradox breaks the LEM is not just
           annoying it's ethically impermissible.

         - Nec doesn't seem to really work right in Deontic logic and it
           may be better to go without it.  The problem here is that it
           sort of breaks the isomorphism with alethic logic, which is
           what SDL (Standard Deontic logic) may be better off doing.

Augmented Standard Deontic Logic
   The idea here is to extend SDL (Standard Deontic Logic).  So
   Everything below is in addition to SDL.

   Axioms
      Double Obligation Axiom (DOA)
         Deontic:  OB(OB(p) -> p)
         - corollary
              OB(OB(p))-> OB(p)
           Similar to Axiom 4
              □A -> □□A

   Notes
   - This axiom is contentius.
   - It ought to be the case that if it ought to be the case you don't
     steal, then you don't steal.
   - It should be the case that if we are obligated to do x that we do x.
   corollary
   - If it's obligatory that it is obligatory that we don't lie, then it is
     obligatory that we don't lie.
   - It ought to be the case that it ought to be the case that x implies
     that it ought to be the case that x.
      
   - what it does is simplifying a stirng of OB down to one OB
       
Semantics of Deontic Logic

   Semantics of Deontic Logic
      The Acceptability Relation in Deontic Sematics
         The Acceptability Relation (DADef - Deontic Acceptability Definition)
         Ai:Aj:(Aij <-> Ap:(OB(p)i -> pj))
         - For any worlds i,j, j is acceptable to i if and only if for all
           propositions p, if p is obligatory in i then p is the case in j.
         - Where i and j are worlds, p is a proposition and xw means x is true
           in a given world w.  We will call this Deontic Acceptability
           Relation.
         - In other worlds, for all worlds i and j, j is acceptable to i
           if and only if for all propositions p, if p is obligatory in i,
           p is true in j.
         - So imagine that world i is some world where the only thing that is
           obligatory is that you do not kill.  And world j where no one ever
           kills bears the acceptability relation i.

         Deontic Acceptance Seriality (DAS)
         A^i =df All world that bear the acceptability relation to i.
         - There must be at least one A^i world since ought implies can  It
           should be possible for us to fulfill all our obligations.  In other
           words Ai:Ej:Aij (for all i there exists some j where j bears the
           acceptability relation to i.

   Semantics of Standard Deontic Logic
      Kripke Semantics
         OB(p)
         - There are no world that bear the acceptability to i and p is false.
         - All worlds that bear the acceptability relation to i are also
           worlds where p is true.
         - It is obligatory that p in i can be understood in terms of an
           Aristotelian categorical logic universal affirmative statement.
         - All A^i worlds are also worlds where p is true (since by definition
           an A^i world is a worlds where all obligations in i are true).
         PE(p)
         - If it is permissible that p at i, that means that there is at
           least one world in which p is true, that bears the acceptability
           relation to i.  In other worlds, there is at least one world where
           all the obligations of world i are fulfilled and p is true.
         IM(p)
         - If it is impermissible that p at i, that means that there is no
           possible world in which all of the obligation in i are true and
           p is true, and there is at least one world where all of the
           obligations in i are true.
         OM(p)
         - If it is omissible that p at i, then there is some A^i world where
           all of the obligations in world i are true, but p is false.
      Example
         It is obligatory that no one lies.
         - If it is obligatory that no one lies in world i, that means that
           there can be no world in which all of the obligations of world i
           hold true, and yet there are people that lie.  And there exists
           one world where all of the obligations of i hold true and no one
           lies.
         It's permissible to swear.
         - If it is permissible to swear in world i, then that means that
           there is at least one world where someone swears and all of the
           obligations of world i are fulfilled.
         It's impermissible to rape.
         - If it's impermissible to rape in world i, then there is no world
           in which all of the obligations in i are fulfilled and a rape is
           committed.  There is also at least one world where all of the
           obligations in i are fulfilled.
         It's omissible to eat oats.
         - If it is omissible to eat oats in world i, then there is some world
           where all of the obligations of i are true, but no one eats oats.
      Relating to Categorical Logic
         OB(p)i: All worlds where all obligations of i are fulfilled are 
            worlds where p is true.
            Correlates to an A.
         PE(p)i: There exists a world where all obligations of i are
            fulfilled and p is true.
            Corresponds to an I.
         IM(p)i: No worlds where all obligations of i are fulfilled  are
            worlds where p is true.
            Corresponds to an E.
         OM(p)i: There exists a world were all obligations of i are
            fulfilled p is not true.
            Corresponds to an O.

   Semantics of Augmented Deontic Logic
      - Recall that Augmented Deontic Logic includes the DOA (Double Obligation
        Axiom):
           OB(OB(p) -> p)
        corollary:
           OB(OB(p)) -> OB(p)
      - This axiom doesn't hold for the semantics of Standard Deontic Logic.
      Semantics
         Imagine 3 possible worlds

            i    j    k

         with relations:
         - Aij, j is acceptable to i
           meaning: all obligations in i are true in j.
         - Ajk, k is acceptable to j
           meaning: all obligations in j are true in k.
         
         - We're going to try to create a counterexample.
           So, in world i we're going to deny DOA.
            ¬OB(OB(p) -> p) in world i
            therefore
            OB¬(OB(p) -> p) in world i
         - But because of our relation, everything in i is true in some j.
           So,
                 ¬(OB(p) -> p) in world j
              ∴ ¬(¬OB(p) v p) in world j
              ∴ OB(p) ∧ -p    where it's -p in world j
           The result may be surprising but it's not a contradiction.
           Often obligations aren't fulfilled in a world.
         - So finally, there exists some world k where
           where:
                 p

         - Since we can provide a counterexample, where DOA is not the case
           that means that adding DOA would create a different situation
           where this would be disallowed.  It would require that for a world
           to be acceptable to i, it must be acceptable to itself.

         - So the DOA requires that for a world to be acceptable to i,
           it must be acceptable to itself.
         - So world j cannot exist because, by the final result above
           (namely OB(p) ∧ -p), because there could be no world where
           it's obligatory that p and p was not done, which would be
           considered acceptable to world i.

         As a consequence of these last points we're going to define a new
         acceptability relation A+.

      A+ Acceptability relation (A+)
         Recall that the acceptability relation is defined as:
                 Ai:Aj:(Aij <-> Ap:( OB(p)i           -> pj))
         We're going to make a new acceptability relation called A+
                 Ai:Aj:(Aij <-> Ap:((OB(p)i ∨ OB(p)j) -> pj)
             World i bears the acceptability relation to world j, if and only
             if for all propositions p, p being obligatory in i or j implies
             that it is true in j.

Deontic Reductionism
   The goal here is to try to reduce deontic logic down to Alethic Modal
   Logic System K.

   Andersonian Kangerian Reduction
      Reduction
         Anderson and Kanger independently discovered methods that they
         claimed could reduce Deontic Logic to Modal Logic using a single
         axiom and propositional constant instead of several asioms and
         a new predicate (namely OB).
      Kanger (System Kd)
         Uses a propositional constant 'd' which means all normative
         demands are met.  Kanger will replace all of the axioms of our
         deontic system with one simple axiom ◇d (it's possible that all
         normative demands are met) and the standard modal axioms for
         System K.  We'll call this system Kd.
      Anderson
         Did the same but used a constant 's' instead of 'd' which means
         some normative demand has been violated.  It should be clear
         that this is identical to -d, and we could take for an equivalent
         axiom to ◇d either ◇¬s or ¬□s.
      Notes
         - This system may seem to reduce SDL to alethic system K.  But we'll
           show that this isn't the case.

   System Kd (Kandger's Deontic Logic)
      System Kd is System K + Axiom d, where axiom d states that d is
      possible.

      System K (K)
         Definitions
            Definition of Possibility (Def◇)
               ◇A  =df  ¬□¬A

         Axioms
            Necessitation Rule (Nec)
               if A is an axiom or theorem of K then □A is too.
            Distribution Axiom (MDist)
               □(A -> B) -> (□A -> □B)

      System Kd
         Uses all of the above plus the following axiom.

         Axiom d (d)
            ◇d, it is possible that all normative demands, or obligations
                 are met.

      We can use this system to derive many of the theorems of SDL (Standard
      Deontic Logic).

      Notes
         - Modal System K is generally non-controversial, and it seems that
           the claim that there is at least oen possible world in which all
           of the normative demands (obligations) are met exists does not
           seem to be too problematic.
         - The claim is that this sysem is equivalent to SDL.  But we'll
           show that this isn't the case.

      Definitions in System Kd (KdD)
         Kd can sufficiently represent all of the deontic terms that we
         have learned in terms of d and □ (and ◇ which can be defined
         in terms of □).  All of these will be referred to as KdD in
         proofs.

         OB(p)  =df  □(d -> p)

         PE(p)  =df  ◇(d ∧ p)

         IM(p)  =df  □(p -> -d)

         OM(p)  =df  ◇(d ∧ -p)

      Examples
         - Let's say:  'it's obligatory that you always wash your hands
           before dinner.'
              OB(w)
           So by definition,
              □(d -> w)
           In all possible worlds where all obligations are fulfilled, you
           always wash your hands before dinner.
         - Let's say, 'Killing is omissible.'
              OM(k)
           Then by definition:
              ◇(d ∧ -k)
           'There exists some possible world in which both all obligations
           are fulfilled and no one is killed.'

   System Ks (Anderson's Deontic Logic)
      Uses a propositional constant 's', which means 'some deontic demand
      has been violated.  This could be defined in terms of Kd as s=-d.
      This system includes instead, all of K and Anderson's axioms,
      which is equivalent to Kanger's axiom.

      System K (K)
         Necessitation Rule (NR)
            if A is an axiom or theorem of K then □A is too.
         Distribution Axiom (MDist)
            □(A -> B) -> (□A -> □B)
         Definition of Possibility (Def◇)
            ◇A =df ¬□¬A

      Anderson's Axom (Axiom s)
         ¬□s     it is not the case that, it's necessary that, s.

      Definitions
         The definitions are basically all the same as those in syste Kd.
         For example.

         OB(p)  =df  □(-p -> s)
            etc.

      Notes
         - Both Systems Kd and Ks will prove to be more powerful than
           SDL (Standard Deontic Logic) and cannot be reduced to it.

   System KTd (KMd)
      Here we assume all of system Kd and add System T (or System M).

      Axioms
         Axiom M (Axiom T)
            Alethic:  □A -> A
            Deontic:  OB(A) -> A

            - corollary
              A -> ◇A
              A -> PE(A)

      Recall System T (System M) where necessity implies truth.  System T
      is System K with Axiom M (or Axiom T).

   Why Deontic Reduction Fails

      Why Kd and Ks are not actually reducible to SDL.

      - While a deontic version of T (OB(p) -> p) might be too strong, it
        seems that a logical system is hard to create without the alethic
        version.  Most systems of alethic modality require that if something
        is in all possible worlds it is in the actual worl, and if
        something is in the actual world it is possible.

      
      While Axiom T (Axiom M) seems important to most alethic systems, it
      does not seem to be a desired property to a deontic system.

      Notes
      - The problem is that while adding the alethic version of T to
        SDL will not create any significant changes, (and it will not
        cause it to turn into the augmented version) adding T to Kd
        will create significant changes and it will allow our
        augmented version of deontic logic including the DOA (Double
        Obligation Axiom) to be able to be deduced.
      - What this means is that either the advocate of Kangerian and
        Andersonian reduction my deny that something that is necessary
        is true in the actual world (which seems to me a difficult
        position to defend considering our understanding of alethic
        modality) or give up on reduction.
      - This does not mean that these fail as deontic systems as a
        whole, merely that they are not reductions of SDL at least
        when axiom M (T) is include in our system.  They can still
        stand as separate systems on their own, but it seems to me that
        their position as reductions of SDL is debunked.
      - This doesn't mean that reductionist systems fail on their own.
        They can still stand as systems on their own. or still deny
        Axiom M (T) and still claim to be a reduction. 

Semantics
   Modal Accessibility Definition relation (MADef)
      Ai:Aj:(ARij <-> Ap:(Pi -> ◇pj))
      Where,
         i and j are worlds
         p is a proposition
         xw means x is true in a given world w
      So, for all worlds i and j, j is accessible to i if and only if for
      all propositions p, if p is true in i, p is possible in j.

      - There's an ambiguity.  Depending on exactly how we construe modality
        (as logical or nomic (of obligation)) it may be the case that all
        worlds are accessible to all other worlds.

      Definitions
         AR^i  =df  all worlds that bear the accessibility relation to i.

         - Just as A^i represented all of the worlds that were acceptable
           to i, AR^i represents all of the worlds that are accessible
           to i, as noted above, this could also be all possible worlds.

   Reductionist Deontic Semantics
      The semantics for Reductionist Deontic Logic will look somewhat
      similar to the semantics for Standard Deontic Logic.  Both can be
      visualized in terms of categorical logic.  We will replace  A^i
      with AR^i and add in all worls in which d is satisfied.

Common Sense Deontic Logic
   Focusing down on optional actions
      Predicates
         MA(p)     Maximal    p is included in the set of things that are the
                              most you can do.  MA (you get tested to see
                              if your kidneys are a match) would mean that
                              getting tested to see if your kidneys are a
                              match is part of the most that you can do.
         MI(p)     Minimal    p is included in the set of things that are the
                              least you can do.  MI (Saying you are very
                              sorry to hear that) would mean that saying
                              you are sorry to hear that is part of the
                              least that you could do.
         BC(p)     beyond     p is included in the set of things that
                   the call   represent going beyond the call of duty (it is
                              not included in the minimal route).  BC
                              (Offering to provide help with the situation)
                              would mean that offering to provide help is
                              going beyond the call of duty.  It is more
                              than the least that you could do.
         PS(p)     Permissibly p is included in the course of action that is
                   Suboptimal  permissible, but not maximal (not included in
                               the maximal route).  PS (Not offering to be
                               tested to see if you could donate) would
                               mean that not offering to see if you could
                               donate would be permissible, but suboptimal,
                               less than the most you could do.
         IN(p)     Indifferent It's indifferent that p (there is not a moral
                               obligation one way or another).  IN (you tie
                               your shoe during the conversation) means that
                               it is morally indifferent that you do or do
                               no tie your shoe during the conversation.
         SI(p)     Significant SI(p) means that it is morally significant
                               that p.  SI (offering to help the person would
                               mean that it is morally significant whether or
                               not you help the person.
      Definitions
         These six terms can be defined in terms of three of them and the
         terms that we already have.

            BC(p)  =df  PE(p) ∧ MI(-p)
            PS(p)  =df  PE(p) ∧ MA(-p)
            SI(p)  =df  ¬IN(p)


      Venn Diagram
         Look at it in terms of a Venn Diagram.


         PE(p)
         +-------------------+
         |                   |     OM(p)
         |  OB(p)  +---------+---------+
         |         |         |         |
         |         |  OP(p)  |         |
         |         |         |         |
         +---------+---------+  IM(p)  |
                   |                   |
                   +-------------------+

         PE(p) is the circle on the left.
         OM(p) is the circle on the right.
         OB(p) is PE(p) minus the part common with OM(p).
         IM(p) is OM(p) miuns the part common with PE(p).
         OP(p) is the part common between PE(p) and OM(p).

         Zoom into OP(p).

         +-------------------------+
         |  OP(P)                  |
         |                         |
         |   +------------------+  |
         |   |  IN(P)           |  |
         |   |                  |  |
         |   |   +-----------+  |  |
         |   |   |  SI(p)    |  |  |
         |   |   +-----------+  |  |
         |   +------------------+  |
         +-------------------------+


         Soom into SI(p)

            The diagram is two pairs of boxes: a horizontal pair, and a
            vertical pair.


         SI(p)

         +---------------------------------------------------------+
         |         +-------------------------+                     |
         |         |         MA(-p)          |                     |
         |         |         PS(p)           |         ¬MA(p) ∧    |
         |         |                         |             ¬MA(-p) |
         | +-------+------------+------------+-------+             |
         | |       |            |            |       | ¬MI(p) ∧    |
         | |       |  MI(-p)    |   MI(p)    |       |     ¬MI(-p) |
         | |       |  MA(-p)    |   MA(-p)   |       |             |
         | |MI(-p) |            |            | MI(p) |             |
         | |BC(p)  |            |            | BC(-p)|             |
         | |       +------------+------------+       |             |
         | |       |            |            |       |             |
         | |       |            |            |       |             |
         | |       |  MI(-p)    |   MI(p)    |       |             |
         | |       |  MA(p)     |   MA(p)    |       |             |
         | |       |            |            |       |             |
         | +-------+------------+------------+-------+             |
         |         |          MA(p)          |                     |
         |         |          PS(p)          |                     |
         |         |                         |                     |
         |         +-------------------------+                     |
         +---------------------------------------------------------+

         - The area around the outermost box is the area SI(p) from the prior
           diagram.  It's that innermost box.

Temporal Logic
==============
   The logic of time.

The Instant Model of Time
   Instants are individual moments in time.  They are points on a timeline.
   They do not have a duration.  Instants are going to be understood in terms
   of the binary relation of precedence (<).  We will generally use x, y,
   and z to represent generic time instants and t,t',t'' to represent
   specific time instants.

The Interval Model of Time
   The interval model deals with time in durations, or intervals.  It's more
   expressive than the instant model, but also more complicated.

   'intervals' are periods of time that are defined by a starting instant and
   a final instant.  Intervals can be used to speak about instants by
   createing 'point intervals' where the start and end points are the same.
   In addition to the precedence relation (<), interval based
   models of time include the overlap relation (O) and the inclusion relation
   (<=).

Language
   The following language is constructed on top of FOL.

   Lexeme
      binary:    <    (called the precedence relation)
      constant:  t    (time now)

   syntax
      i. if x,y are instants, x<y and x<=y are wffs.

   semantics
      (x<y), says 'instant x precedes instant y in time'.
      (x<=y), says 'instant x precedes or is equal to instanty y in time'.

   Definition
      Precedence-Equality Definition (PEqD)
         (x<=y)  =df  ((x<y) ∨ (x=y))
                      Less than or equal to

   Examples
      - OB(a<=m), It is obligatory that you arrive at or before the start
                  of the meeting.

Is Precedence Reflexive?
   If a relation is reflexive, that means that it applies to itself.
   Some people take precedence as reflexive some do not.

   If precedence is irreflexive, that means that no moment is before
   itself.  No instant bears the precedence relation to itself.
      Ax:¬(x<x)      (IrPT)

   But we can also take another meaning of precedence and claim that every
   instant bears the precedence relation to itself.
      Ax:(x<x)       (RePT)

   Generally, one that asserts the precedence relation is reflexive will
   also assert that it is anti-symmetrical (if two instants are before
   the other, they are the same instant)
      Ax:Ay:(((x<y) ∧ (y<x)) -> x=y)          (ASPT)

The Transitivity of Time
   Transitivity (TrPT)
      Ax:Ay:Az:(((x<y) ∧ (y<z)) -> (x<z))     (TrPT)

The Connectedness of Time
   Connectedness, or trichotomy is a property that we have not seen
   before, but it is going to be important for some, but not all of
   the temporal logics that we are going to look at.  Simply, given
   any two instants, either one is before the other or they are
   identical.
      Ax:Ay:(((x<y) ∨ (y<x)) ∨ x=y)      (CoPT)

The Density of Time
   For any two points in time there is a third between them.

   Consider the set of integers.  They are not dense because we could begin
   with two successive integers in which case there will be no third one in
   between them.  However, the set of all real numbers is dense.

   If you accept density (like a real number) then include this property.
      Ax:Ay:((x<y) -> Ez:((x<z) ∧ (z<y)))    (DnPT)

Predecessors and Successors in Time
   Predecessorship claims that each instant has an immediate predecessor
      and there are not other instants in between.
   Successorship claims the same about successors.

   Examples
      - The integers each have one and only one immediate predecessor
        one and only one immediate successor.

   If you think that the instants of time have no beginning, no end and
   are not dense, in effect all have immediate predecessors and successors,
   you would say that the precedence relation has the predecessorship
   and successorship properties.

      Ax:Ey:((x<y) ∧ Az:((x<z) -> (y<=z)))     (ISPT)
         Every instant has an immediate successor.  Take the case where y
         is immediate successor x, then y<=z.

      Ax:Ey:((y<x) ∧ Az:((z<x) -> (z<=y)))     (IPPT)
         Every instant has an immediate predecessor.

Discreteness of Time
   *These definitions may not be quite right*
   Forward Discreteness, every instant has an immediate predecessor.
   Backward Discreteness,every instant has an immediate successor.

   Logically
      *I don't know if these are correct or if they should look like
       the two formal axioms stated in Predecessors and Successors in
       Time.*
      Forward Discreteness  (FDPT)
         Ax:Ey:((x<y) -> Ey:((x<y) ∧ Az:((x<z) -> (y<=z))))

      Backward Discreteness (BDPT)
         Ax:Ey:((y<x) -> Ey:((y<x) ∧ Az:((z<x) -> (z<=y))))

Beginnings and Endings
   To say that there is no beginning and not end to our timeline.

   No Beginning (NBPT)
      Ax:Ey:(y<x)
   No Ending (NEPT)
      Ax:Ey:(x<y)
   Beginning (BePT)
      ¬Ax:Ey:(y<x)            (Negation of No Beginning)
   Ending (EnPT)
      ¬Ax:Ey:(x<y)            (Negation of No Ending)

   Notes:
   - If we have predecessorship we don't need no beginning (because it
     says the same thing).
   - If we have successorship we don't need no ending (because it says
     the same thing).
   - However, they would be needed for a dense time line.

Table - Kinds of time
   Use this table to decide which set of axioms you need to describe the
   timeline for the system you are modeling.

            No End         End             No End         End
            No Begin       No Begin        Begin          Begin

    Not     Integers       Neg Integers    Pos Integers   Integers: 1..9
    Dense   predecessor    Predecessor     Successor      Bkw Discrete
            successor      Fwd Discrete    Bkw Discrete   Fwd Discrete
            NEPT NBPT      End             Begin          Begin
            FDPT BDPT      NBPT, BDPT      NEPT, FDPT     End

    Dense   Rationals      Neg Rationals   Pos Rationals  Rationals: 0..1
            Density        Density         Density        Density
            No Begin       No Begin        Begin          Begin
            No End         End             No End         End

Well Ordering
   Well ordering is actually a property of the precedence relation and the
   timeline that we are not going to be able to express in FOL.

   Well Ordering means that for all (non-empty) sets of instants (even
   infinite sets) there is always a least member.

   Examples
      The set of all positive integers.
      Any subset of all positive integers.
      The set of rational numbers is not well ordered because it's dense.
      
   Formally
      We need to borrow some set theory concepts. We'll use A..Z as sets,
      'in' as the set membership operator, and 'null' as the null set.

         AA:(¬(A=null) -> Ex:((x in A) ∧ Ay:((y in A) -> (x <= y))))

            For all sets A, where A is non-empty implies there exists some
            instant x such that, x in A and for any y, y in A implies x <= y.

   Notes
      - Well Ordering may only be appropriate for discrete sets such as
        integers rather than rationals.

Arthur Prior's Tense Operators
   Operators
      H(r),  It has always been the case that, r.
      P(q),  It has at some point in the past been the case that, q.

      G(s),  It will always be the case that, s.
      F(p),  It will at some point in the future be the case that, p.

      E(p),  It will be the case at some point in time that, p.
      A(p),  It is the case at all points in time that, p.

   Valuation
      Take qy as proposition q is true at instant y.  If no subscript is
      present we'll consider t as now.

   Formal Definitions (TODEF)
      H(p)t  =df  Ax:((x<t) -> px)
         H(p)t, is defined as,
         At all instants prior to now, p is true.
      P(p)t  =df  Ex:((x<t) ∧ px)
         P(p)t, is defined as,
         At some instant prior to now, p is true.

      G(p)t  =df  Ax:((t<x) -> px)
      F(p)t  =df  Ex:((t<x) ∧ Px)
      
      The next two are defined in terms of the above four.

      E(p)t  =df  P(p)t ∨ (pt ∨ F(p)t)
         E(p)t is defined as, p was the case before now, or p is the case
         now, or p will be true the case after now.

      A(p)t  =df  H(p)t ∧ (pt ∧ G(p)t)
         A(p)t is defined as, p had always been the case before now,
         and p is the case now, and p will always be the case after now.

Semantics of Prior's Tense Operators
   The meanings of the operators can be expressed graphically along a
   timeline.  Below we will assume that our timeline is connected (there are
   no branches), transitive, and precedence is irreflexive.

   Examples
      - P(p)t, means that P(p) at time t (in a timeline):

                           P(p)
        <    |    |    |    |    |    |    |    |    >
                            t

        which in turn means, p is true at some instant prior to t.

                  p        P(p)
        <    |    |    |    |    |    |    |    |    >
                            t

   It may seem more complex with combinations of tense operators but 
   just analyze it using the same principles.
      - Try HF(p)t.

                          HF(p)
        <    |    |    |    |    |    |    |    |    >
                            t

        So F(p) is true at every instant prior to t.
            F(p) F(p) F(p)HF(p)
        <    |    |    |    |    |    |    |    |    >
                            t

        Now p is true at some point after F(p), which means at time t or
        later.
                            p    p    p    p    p
            F(p) F(p) F(p)HF(p)
        <    |    |    |    |    |    |    |    |    >
                            t

Naturalism
   Ontological Naturalism
      The kinds of entities we think exist.
      Committed to the claim that there are not entities that can have an
         influence on the physical world which are not themselves physical.
      This still allows for nonphysical entities that lack a direct influence
         on the physical world (eg. math, logic, etc.).  This commits the
         ontological naturalist to the denial that there is something
         outside our brains, a mind or soul, which influences the physical
         world in some way.
      Opponents assert that there are some nonphysical entities which can
         affect the physical world.  Within ontological naturalism there
         is disagreement as to what constitutes influence, and what
         constitutes a physical entity.

   Methodological Naturalism
      How philosophy should use the methods of science.
      Cencerned with the methods of philosophy and their connection to
         science.  Simply put they hold that both science and philosophy
         are searching for non-definitional (synthetic) truths by using
         sense experience (a posteriori means).
      They mad distinguish science and philosophy in different ways.  They
         may do so by content, effectively they study different entities
         (sci studies chems, phil studies conditionals).  They may also 
         differentiate by scope (phil deals with gen questions - e.g. what
         is property? - while sci deals with more specific questions -
         what does it mean for something to have mass?).  No matter the
         method of differentiation they will assert that these two fields
         are engaged in the same project: to learn synthetic truths about
         the world.
      Oppoents assert that phil uses methods independent of experience to
         investigate (a priori) or that phil engages in the pursuit of truths
         about definitions, or analytic truths.

Comparing Alethic & Temporal logic
   Temporal, alethic and deontic are isomorphically similar.

   Operators
      Strong Operators:  □  OB  H  G
      Weak Operators:    ◇  PE  P  F

   Table

      Alethic      Deontic      Temporal
                                Past         Future
      -----------  -----------  -----------  -----------
      □p          OB(p)        H(p)         G(p)
      ◇p          PE(p)        P(p)         F(p)
      □p =df      OB(p) =df    H(p) =df     G(p) =df
         ¬◇¬p        ¬PE(-p)      ¬P(-p)       ¬F(-p)

   Change of Temporal Quantifier (CTQ)
      Definitions
         H(p)  =df  ¬P(-p)
         G(p)  =df  ¬F(-p)

System Kt (Minimal Temporal Logic)
   System Kt is an isomorphism to alethic modal logic's System K.  'K' from
   Saul Kripke.  't' for temporal.  System Kt does not include the precedence
   operator.  System Kt does not assume transitive, reflexive or dense.

   System K (First Principals from Alethic System K)
      Definitions
         Alethic:             □p    =df  ¬◇¬p
         Deontic:             OB(p)  =df  ¬PE(-p)
         Temporal:            H(p)   =df  ¬P(-p)
                              G(p)   =df  ¬F(-p)
      Axioms
         Modal Distribution Axiom (MDist)
            Alethic (MDist):  □(A -> B) -> (□A -> □B)
            Deontic (MDist):  OB(p -> q) -> (OB(p) -> OB(q))
            Temporal (KG):    G(p -> q) -> (G(p) -> G(q))
            Temporal (KH):    H(p -> q) -> (H(p) -> H(q))

            if it had always been the case that, d implies m, then it has always
            been the case that d implies it has always been the case that m.

         Necessitation Rule (NR)
            Alethic:          if |- A then □A
            Deontic:          if |- p then OB(p)
            Temporal (TNR):   if |- p then A(p)
               if A,p are axioms or theorems ...

   System Kt Axioms
      System Kt is all of the System K principles above plus the following
      axioms.  (These axioms relate the past to the future.)
         Axiom GP (TAGP):  p -> GP(p)
         Axiom HF (TAHF):  p -> HF(p)

System K4t (Transitive Temporal Logic)
   Similar to Alethic System K4, which adds axiom s4 to system K.  K4t assumes
   that precedence is transitive, but the axiom is framed in terms of tense
   operators.

   Axioms
      All of the first principals of System Kt, plus the following:

      Axiom 4
         Alethic (4,s4):   □A -> □□A
         Temporal          G(p) -> G(G(p))
           (Kt4 or TA4):   H(p) -> H(H(p))

      Corollary to Axiom 4
         Alethic:          ◇◇A -> ◇A
         Temporal:         F(F(p)) -> F(p)
                           P(P(p)) -> P(p)

   Notes
      Notice how G(G(p)) is two applications of G (which are defined using
         precedence time operator).  So, G(G(p)) is two applications of the
         precedence operator.

System S4t (Reflexive Temporal Logic)
   So far we have been assuming that precedence is irreflexive.  However some
   temporal logics are reflexive due to the inclusion of an axiom equivalent
   to the modal alethic Axiom T (or M).  Here we'll look at S4t which
   includes all of K4 plus Axiom T (or M).

   Axioms
      All of the first principals of system K4t, plus the following:

      Axiom T (T,M)
         Alethic (T,M):    □A -> A
         Deontic (T,M):    OB(p) -> p
         Temporal (TAT):   G(p) -> p
                           H(p) -> p

      Corollary to Axiom T
         Alethic:          A -> ◇A
         Deontic:          p -> PE(p)
         Temporal:         p -> F(p)
                           p -> P(p)

   Notes
      - These axioms and corollaries seem a little fishy to me.  I'm not sure
        I agree with them and they do seem to extend the meanings of G and H
        to include the present instant in time.
      - Because they don't make sense to me I'm generally not going to
        assume reflexivity of precedence.

System Lt (Linear Temporal)
   So far our logic has been assuming that our model is linear.  Linear
   functions effectively the same as connectedness by claiming that there's
   only one non-branching timeline.  Like Axioms GP and HF it mixes past
   and future, so it will not have an analogue in other modal logics.  Lt
   will include all of Kt, as well as 4 (transitivity) and L (Linearity).

   Axioms
      All of the first principals of System K4t

      Temporal Axiom of Linearity
         Temporal (TAL):   (F(P(p)) ∨ P(F(p))) -> E(p)

System Nt (Well Ordered Temporal Logic)  Natural Numbers
   This logic is going to include everything from L, but add on three new
   axioms: No End, Forward Induction (implies backwards discreteness),
   and Well Ordering.  None of these principles is new (discussed WRT
   precedence operator), but here they are expressed with tense operators.
   We'll call this System Nt since it creates a set of time instants that
   is isomorphically similar to the natural numbers (positive integers), with
   a beginning but no end, and every number has an immediate predecessor.

   Axioms
      All of the first principals of system Lt

      Axiom D
         Alethic (D):      □A -> ◇A
         Deontic (D):      OB(p) -> PE(p)
         Temporal Axiom of
            No End (TANE):        G(p) -> F(p)

      Axiom 5 (s5)
         Alethic (5):      ◇A -> □◇A
         Temporal (5):     (F(p) ∧ G(p -> F(p))) -> G(F(p))
            Temporal Forward Induction Axiom

      Temporal Axiom of Well Ordering
         Temporal:         H(H(p) -> p) -> H(p)
            For any set of instances there is a least (or first).

   Notes
      - At first glance it may not be clear why these two axioms imply that
        time has no end or beginning, but you must remember that in the
        final instant of time G(p) is vacuously true for all p, and F(p)
        is false for all p.
      - Forward induction implies backward discreteness.

   Components of System Nt
      System Lt
      Temporal Axiom of Well Ordering
      Temporal Forward Induction Axiom (5)
      Temporal Axiom of No End (D)

System Zt (Inductive Temporal Logic)   Integers
   This system corresponds to the integers.  It will include both forward
   induction and backward induction (therefore both forward and backward
   discreteness).  It will include both no end and no beginning as well.

   Axioms
      All of the first principles of Lt (Liner Temporal).

      Temporal Axiom of
         No End:           G(p) -> F(p)
         No Begin:         H(p) -> P(p)

      Temporal Induction Axiom
         Forward:          (F(p) ∧ G(p -> F(p))) -> G(F(p))
         Backward:         (P(p) ∧ H(p -> P(p))) -> H(P(p))

System Qt (Dense Temporal Logic)    Rationals
   If time is dense that means that between any two instants there is another
   instant.  It's infinitely divisible.  This is in direct contradiction to
   forward and backward induction.  This system, which we will call Qt can
   be mapped onto the ratiional numbers since there is always another
   fraction in between any two fractions.  If you think that there are an
   infinite number of instants between any two instants then you think
   that time is dense.

   Axioms
      All of the first principles of Lt (Linear Temporal Logic)

      Temporal Axiom of
         No End:           G(p) -> F(p)
         No Begin:         H(p) -> P(p)

      Temporal Density Axiom:
                           G(G(p)) -> G(p)
                           F(p) -> F(F(p))

System Rt (Complete Temporal Logic)   Reals
   For a timeline to be complete, that instants that any set of instants that
   is defined by an instant that all instants in the set are before must be
   able to be defined by an instant that all instants in the set are before
   which is an instant in the original timeline.  This is quite perplexing,
   the best way to understand it is in terms of types of numbers.  Of the
   types of numbers we have looked at (natural numbers, integers, rational
   numbers and real numbers) rational numbers are the only ones that are not
   complete.
      
   Axioms
      All of the first principles of Qt

      Temporal Completeness Axiom
                           A(H(p) -> F(H(p)) -> (H(p) -> G(p))





Temporal Logic Comparison

Kt = Ax K + Axioms GP,HF
   K4t = Kt + Ax s4
      s4t = K4t + Ax T
      Lt  = K4t + Linearity                                           line
         Nt = Lt + Ax D (No End) + Ax 5 (Fwd Induct) + Well Ordering  Natural
         Zt = Lt + Ax D (No End/Begin) + Ax 5 (Fwd/Bkw Induct)        Integer
         Qt = Lt + Ax D (No End/Begin) + Density                      Rational
            Rt = Qt + Completeness                                    Real


              ---  -------  ----  ------  -------  ------  --------  --------
            | Kt   K4t      S4t   Lt      Nt       Zt      Qt        Rt
            | Min  Transit  Refl  Linear  Well     Induct  Dense     Complete
            |                             Ordered
First       |
Principles  |                             Natural  Intege  Rational  Reals
----------    ---  -------  ----  ------  -------  ------  --------  --------
Def H,G       *    *        *     *       *        *       *         *
NR            *    *        *     *       *        *       *         *
MDist                                             
- KG          *    *        *     *       *        *       *         *
- KH          *    *        *     *       *        *       *         *
GP,HF         *    *        *     *       *        *       *         *
4                  *        *     *       *        *       *         *
T (M)                       *
Linear                            *       *        *       *         *
Well Ordered                              *         
5
   Fwd Induct                             *        *
   Bkw Induct                                      *
D
   No End                                 *        *       *         *
   No Begin                                        *       *         *
Dense                                                      *         *
Completeness                                                         *


The Next Time Operator
   Lexemes
      X(p), in the instant directly after this one, p.
      Y(p), in the instant directly before this one, p. (Yesterday operator)

   Definitions
      X(p)t  =df  Ex:((t<x) ∧ (Ay:((t<y) -> (x<=y)) ∧ px))
      Y(p)t  =df  Ex:((x<t) ∧ (Ay:((y<t) -> (y<=y)) ∧ px))

   Axioms
      Axiom Kx:            X(P -> q) -> (X(p) -> X(q))
      Functionality:       ¬X(p) <-> X(-p)

   Notes
      - let's break down 'next' to better understand it
        X(p)t  =df  Ex:( (t<x) ∧   (Ay:( (t<y) ->      (x<=y))    ^  px))
        X(p)t  =df  Ex:(  t<x  ^   (Ay:(  t<y  ->       x<=y )    ^  px))
                   some  after &   all   after are      after or  &  px
                   time  now       times now   (implies)identical
                   x                                    to x
                             or
                   some  after and before all other              and p at
                   time  now       instants after now                that time
                             or
                   p is true in the time interval (t..y]
                   where y is arbitrarily after t.

Since and Until Operators
   Lexemes
      S(p)(q), p has been the case since a time when q.
      U(p)(q), p will be the case until such a time when q.

   Definitions
      S(p)(q)t  =df  Ex:( (x<t ∧ qx) ∧ Ay:((y<t ∧ x<y) -> py))
      U(p)(q)t  =df  Ex:( (t<x ∧ qx) ∧ Ay:((t<y ∧ y<x) -> py))

      S(p)(q)   =df  Ax:( x>=q -> px )
   
   Notes
      - Let's break down 'since' to better understand it
        S(p)(q)t =df Ex:( ((x<t) ∧ qx)  ^   Ay:(((y<t) ∧ (x<y)) -> py))
                     Ex:( ( x<t  ^ qx)  ^   Ay:(  x<y<t         -> py))
                    some   in the past  &   all   after then &     p
                    time   when q          times  before now
        p is true since (all instants after) q but before t. Or given the
        instants p,q,t, q < p < t.  Similarly, 'until' is t < p < q.

      - There are two ways to conceive of since and until, either as strict,
        where precedence is defined as irreflexive, or as general where
        precedence is deinfine as reflexive.  We will use U and S to refer
        to the general versions and Us and Ss to refer to the strict versions.

Axioms of Since & Until
   If we assume precedence is reflexive we can define F(p) and P(P) in terms
   of since and until.

      F(p)  =df  U(T)(p)       (where T is the Tautology symbol)
      P(p)  =df  S(T)(p)

   If p is happening in the future then all tautologies have been true up
   until p is true.  If p is happening in the past, there exists some point
   in the past where p since all tautologies have been true.

   We can define the Next and Yesterday operators in terms of the strict
   versions of these operators.

      X(p)  =df  Us(CON)(p)    (where CON is the contradiction symbol)
      Y(p)  =df  Ss(CON)(p)

   So, p will happen in the next instant if there is nothing (a contradiction)
   that will be true from now until p.

   We can defined our general operators in terms of our strict operators.

      U(p)(q)  =df  q ∨ (p ∧ Us(p)(q))
      S(p)(q)  =df  q ∨ (p ∧ Ss(p)(q))

   p is true generally until q is the same as either q is the case now (and
   it is vacuously true) or p is the case and will be structly true until q
   is the case.  The same applies to since.

LTL (Linear Time Logic)
   A common use of the time operators is a system known as LTL (Linear
   Time Logic).  This system only contains operators that deal with the
   future, namely G, X and U.  It's commonly used in Computer Science.

   Definitions
      Definition of X
                           X(p)t  =df  Ex:((t<x) ∧ (Ay:((t<y) -> (x<=y)) ∧ px))

      Reflexive Recursive Definition of G
                           G(p)  =df  (p ∧ X(G(p)))
                                      p is the case now an recursively at all
                                      points into the future.

      Reflexive Recursive Definition of U
                           U(p)(q)  =df  (q ∨ (p ∧ X(U(p)(q))))
   Axioms
      Modal Distribution
         Alethic:          □(p -> q) -> (□p -> □q)
         LTL (KG,MDist):   G(p -> q) -> (G(p) -> G(q))
         LTL (KX,MDist):   X(p -> q) -> (X(p) -> X(q))

      Necessitation Rule
         LTL (NR):         if |- p then A(p)

      Next Time Functionality Axiom
                           ¬X(p) <-> X(-p)

      Inductive Principle regarding X and G
                           p ∧ G(p -> (q ∧ X(p))) -> G(p)

      Principle Regarding Least Fixed Points and Completeness
                           G((p ∨ (q ∧ X(r))) -> q) -> (U(q)(p) -> r)

Branching Time
   Branching time deals with the future only.  It deals with the possibility
   that there is more than one future available to us to choose from, though
   it assumes the past is static.

   Branching time models imagine that now is at the first branch on the
   trunk of a tree.  Everything before is determined, but everything after
   continues to branch off.

   However, branching time always assumes an actual future, which will
   function like the actual world does for alethic modal logic.

Ockhamist Branches of Temporal Logic
   The system of branching temporal logic that we will examine here is
   attributed by Arthur Prior to Ockham of Ockham's razor.  We will not
   get into the specific axioms of this theory here, but rather explain
   how you can express particular propositions using Ockhamist branching
   temporal logic.

   Grammar
      Often branching temporal logic uses ◇ and □ to denote "there exists
      some future timeline" and "for all future timelines" respectively.
      So that we don't confuese these with our alethic operators, we'll
      use <*> to denote "there exists some future timeline" and [*] to
      denote "for all future timelines".

      Lexemes:  [*]p       For all future timelines, p
                <*>p       There exists some future timeline where, p
                           For some future timeline, p

      To be clear, that menas that [*]p means that from the stand point of
      this instant, for all future timelines, p.  Similarly, <*>P means from
      the standpoint of this instant, there exists some future timeline such
      that, p. [*](I will eat ice cream tomorrow) means that from the
      standpoint of this instant, for all future timelines, I will eat ice
      cream tomorrow.

      Furthermore, these symbols can be combined with our future tense
      operators (though it is not clear how they would be combined for past
      tense).  <*>G(p) means that from the standpoint of this instant, there
      exists some future timeline such that, it's going to be the case at
      all future instants that, p.  [*]U(p)(q) means from the standpoint of
      this instant, for all future timelines, p will be the case until such
      time as q.  <*>F(You will eat cake) means that from the standpoint of
      this instant, there exists some future timeline such that, at some
      instant in the future, you will eat cake.

      Just as any non-quantified symbols in modal logic apply to the
      actual world, symbols without a branching temporal quantifier will
      apply to the actual future.  So F(p) -> <*>F(p) means that from the
      standpoint of the current instant, if at some instant in the future
      p then there is some future timeline such that, at some instant in
      the future, p.  Or simply, the actual future is a possible future.

      Imagine that you are the only person in all of history that can invent
      immortality.  In every possible future where you die before you get
      to 100, humans will not have achieved immortality when you die, and
      never will in any future timeline.
         [*](¬U(you live)(you are 100) -> (¬<*>F((you are dead) ∧ (there
             exists some human)(G(that human will live))))

Epistemic & Doxastic Logics
   Knowledge is justified true belief.  Epistemic logic is the logic of
   knowledge.  Alethic Modal Logic is about Truth.  Doxastic Logic, the
   logic of belief.

   Language
      K(s)(b)   s knows b.
      B(s)(p)   s believes p.

   Semantics
      Epistemic Accessibility Relation
      ER(i)(j)(s)  =df Ap:Aq:((K(s)(p)i ∧ qj) -> ¬((p -> -q) ∨ (q -> -p)))

      Doxastic Accessibility Relation
      DR(i)(j)(s)  =df Ap:Aq:((B(s)(p)i ∧ qj) -> ¬((p -> -q) ∨ (q -> -p)))

      agent s believes p in world i
      B(s)(p)i  =df  Aw:Dr(i)(w)(s) -> pw)   (BelDef in Proofs)

      agent s knows that p in world i
      K(s)(p)i  =df  Aw:(ER(i)(w)(s) -> pw)  (KnwDef in Proofs)

Axiom K (Doxastic & Epistemic)
   Alethic (Axiom K):      □(A -> B) -> (□A -> □B)
   Deontic (Axiom K):      OB(p -> q) -> (OB(p) -> OB(q))
   Temporal (Axiom KG):    G(p -> g) -> (G(p) -> G(q))
   Temporal (Axiom KH):    H(p -> q) -> (H(p) -> H(q))
   Epistemic (Axiom K):    K(s)(p -> q) -> (K(s)(p) -> K(s)(q))
   Doxastic (Axiom K):     B(s)(p -> q) -> (B(s)(p) -> B(s)(q))

Axiom D (Doxastic & Epistemic)
   Alethic (Axiom D):      □A -> ◇A
   Deontic (Axiom D):      OB(p) -> PE(p)
   Temporal (No End):      G(p) -> F(p)
   Temporal (No Begin):    H(p) -> P(p)
   Epistemic (Axiom D):    K(s)(p) -> ¬K(s)(-p)
   Doxastic (Axiom D):     B(s)(p) -> ¬B(s)(-p)
            The ¬K(s)(¬P) is akin to ¬◇¬P, but Epist,Doxas don't have
            a weak operator.

Axiom T (Doxastic & Epistemic)
   Alethic (Axtiom T):     □A -> A
   Deontic (Axiom T):      OB(p) -> p
   Temporal (Axiom TG):    G(p) -> p
   Temporal (Axiom TH):    H(p) -> p
   Epistemic (Axiom T):    K(s)(p) -> p
   Doxastic (Axiom T):     B(s)(p) -> p

   Alethic:                A -> ◇A
   Deontic:                p -> PE(p)
   Temporal:               p -> F(p)
   Temporal:               p -> P(p)

Axiom 4 (Doxastic & Epistemic)
   Alethic (4):            □A -> □□A
   Temporal (4):           G(p) -> G(G(p))
   Epistemic (4):          K(s)(p) -> K(s)(K(s)(p))
   Doxastic (4):           B(s)(p) -> B(s)(B(s)(p))

Axiom 5 (Doxastic & Epistemic)
   Alethic (5):            ◇A -> □◇A
   Epistemic (5):          ¬K(s)(p) -> K(s)(¬K(s)(p))
   Doxastic (5):           ¬B(s)(p) -> B(s)(¬B(s)(p))
      These are too strong.

   Corollary
      Epistemic:           K(s)(p) ∨ K(s)(¬K(s)(p))
      Doxastic:            B(s)(p) ∨ B(s)(¬B(s)(p))

Axiom 4.2 (Doxastic & Epistemic)
   Epistemic (4.2):        ¬K(s)(¬K(s)(p)) -> K(s)(¬K(s)(-p))
   Doxastic (4.2):         ¬B(s)(¬B(s)(p)) -> B(s)(¬B(s)(-p))
      These are too strong.

   Corollary
      Epistemic:           K(s)(¬K(s)(p)) ∨ K(s)(¬K(s)(-p))
      Doxastic:            B(s)(¬B(s)(p)) ∨ B(s)(¬B(s)(¬P))

Axiom 4.3 (Doxastic & Epistemic)
   Epistemic (4.3):        K(s)(K(s)(p) -> K(s)(q)) ∨ K(s)(K(s)(q) -> K(s)(p))
   Doxastic (4.3):         B(s)(B(s)(p) -> B(s)(q)) ∨ B(s)(B(s)(q) -> B(s)(p))
      These are too strong.

   Corollary
      Epistemic:           K(s)(¬K(s)(p) ∨ K(s)(q)) ∨ K(s)(¬K(s)(q) ∨ K(s)(p))
      Doxastic:            B(s)(¬B(s)(p) ∨ B(s)(q)) ∨ B(s)(¬B(s)(q) ∨ B(s)(p))

Axiom 4.4 (Doxastic & Epistemic)
   Epistemic (4.4):        p -> (¬K(s)(¬K(s)(p)) -> K(s)(p))
   Doxastic (4.4):         p -> (¬B(s)(¬B(s)(p)) -> B(s)(p))
      These are too strong.




The Axioms of Modal Logics

     Ale  Deo  Tem  Epi  Dox
     ---  ---  ---  ---  ---
K     Y    Y    Y    C    C
Nr    Y    C    Y    N    N
D     Y    Y    C    Y    C
T     Y    N    C    Y    N
4     Y    N    Y    C    C
5     C    N    C    C    C
4.2   Y    N    ?    C    C
4.3   Y    N    ?    C    C
4.4   C    N    ?    C    C
W     N    N    C    N    N
Q     Y    C    C    Y    C

   Y, Yes
   N, No
   C, Controversial

Are Obligations Eternal?

   Ap:(OB(p) -> A(OB(p)))

If not, are any obligations eternal?

   Ep:(OB(p) -> A(Ob(p)))

Agential Deontic Logic
   Definitions
      BA(p),  someone brings about that, p.
      RO(p),  rules out by someone's actions, p
      NR(p),  Not ruled out,p
      NB(p),  not the case that someone bought it about that, p
      PV(p),  someone is passive in regards to, p

      RO(p)  =df  BA(-p)
      NR(p)  =df  ¬BA(-p)
      NB(p)  =df  ¬BA(p)
      PV(p)  =df  ¬BA(p) ∧ BA(-p)

   Square of Opposition
      BA        RO


      NR        NB

   Axioms
      Axiom T:             BA(p) -> p
      Conjunction Axiom:   BA(p ∧ q) -> (BA(p) ∧ BA(q))
      Tautology Axiom:     ¬BA( TAUT )

   OB(BA(p))
   ¬OB(BA(p))






Primitive   1. N (names) is a type
Types
            2. S (sentences) is a type      

Derivative  3. if X and Y are types, then (X -> Y) (functors)
Types

            4. if X and Y are types, then (X X Y)  (products)
                               # This carrot ∧ is pointing to a cross

          The (X -> Y) expression above isnt' an if then statement.

A functor is a kind of function, see here:

   A functor       combines  phrases    to     a phrase
   of type           with    of type  produce  of type
   --------------  --------  -------  -------  --------
   (X -> Y)                     X                  Y

   ((X X Y) -> Z)            X and Y               Z

Examples of Derivative-Types
   N -> N  (1-place operator)
   S -> S  (1-place operator)
   N -> S  (1-place predicator)
   S -> N  (1-place disconnecotr)

So for example the N -> N operator is something like adding Dr in front of
So for example the N -> N operator is something like adding Dr in front of
So for example the N -> N operator is something like adding Dr in front of
a person's name resulting in another name.  The second one takes a sentence,
adds something resulting in a new sentence, etc.

More examples
So for example the N -> N operator is something like adding Dr in front of
a person's name resulting in another name.  The second one takes a sentence,
adds something resulting in a new sentence, etc.

More examples
   (N X N) -> N  (2-place operator)   <-- takes two names, outputs a name
   (S X S) -> S  (2-place operator)
   (N X N) -> S  (2-place predicator)
   (S X S) -> N  (2-place subnector)

   N -> (N -> S)                 transitive verb    (2 place verb)
   N -> (N -> (N -> S))          di-transitive verb (3 place verb)
   N -> (N -> (N -> (N -> S)))   tri-transitive verb ...
   etc.

   N -> S                1st Order Predicate
   (N -> S) -> S         2nd Order Predicate
   ((N -> S) -> S) -> S  3rd Order Predicate
   etc.

